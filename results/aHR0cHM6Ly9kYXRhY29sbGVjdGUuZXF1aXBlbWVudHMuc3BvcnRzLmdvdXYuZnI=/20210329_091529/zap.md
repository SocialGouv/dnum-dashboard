
# ZAP Scanning Report

Generated on Mon, 29 Mar 2021 08:55:37


## Summary of Alerts

| Risk Level | Number of Alerts |
| --- | --- |
| High | 0 |
| Medium | 4 |
| Low | 6 |
| Informational | 5 |

## Alerts

| Name | Risk Level | Number of Instances |
| --- | --- | --- | 
| CSP: Wildcard Directive | Medium | 4 | 
| Source Code Disclosure - Java | Medium | 1 | 
| Sub Resource Integrity Attribute Missing | Medium | 4 | 
| Vulnerable JS Library | Medium | 1 | 
| Cookie Without SameSite Attribute | Low | 3 | 
| Cross-Domain JavaScript Source File Inclusion | Low | 4 | 
| CSP: Notices | Low | 4 | 
| Dangerous JS Functions | Low | 5 | 
| Feature Policy Header Not Set | Low | 10 | 
| Incomplete or No Cache-control and Pragma HTTP Header Set | Low | 4 | 
| Base64 Disclosure | Informational | 8 | 
| Information Disclosure - Suspicious Comments | Informational | 12 | 
| Modern Web Application | Informational | 5 | 
| Storable and Cacheable Content | Informational | 11 | 
| Timestamp Disclosure - Unix | Informational | 9 | 

## Alert Detail


  
  
  
  
### CSP: Wildcard Directive
##### Medium (Medium)
  
  
  
  
#### Description
<p>The following directives either allow wildcard sources (or ancestors), are not defined, or are overly broadly defined: </p><p>script-src, script-src-elem, script-src-attr, style-src, style-src-elem, style-src-attr, img-src, connect-src, frame-src, frame-ancestors, font-src, media-src, object-src, manifest-src, worker-src, prefetch-src, form-action</p><p></p><p>The directive(s): frame-ancestors, form-action are among the directives that do not fallback to default-src, missing/excluding them is the same as allowing anything.</p>
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/robots.txt](https://datacollecte.equipements.sports.gouv.fr/robots.txt)
  
  
  * Method: `GET`
  
  
  * Parameter: `Content-Security-Policy`
  
  
  * Evidence: `upgrade-insecure-requests`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/sitemap.xml](https://datacollecte.equipements.sports.gouv.fr/sitemap.xml)
  
  
  * Method: `GET`
  
  
  * Parameter: `Content-Security-Policy`
  
  
  * Evidence: `upgrade-insecure-requests`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/](https://datacollecte.equipements.sports.gouv.fr/)
  
  
  * Method: `GET`
  
  
  * Parameter: `Content-Security-Policy`
  
  
  * Evidence: `upgrade-insecure-requests`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr](https://datacollecte.equipements.sports.gouv.fr)
  
  
  * Method: `GET`
  
  
  * Parameter: `Content-Security-Policy`
  
  
  * Evidence: `upgrade-insecure-requests`
  
  
  
  
Instances: 4
  
### Solution
<p>Ensure that your web server, application server, load balancer, etc. is properly configured to set the Content-Security-Policy header.</p>
  
### Reference
* http://www.w3.org/TR/CSP2/
* http://www.w3.org/TR/CSP/
* http://caniuse.com/#search=content+security+policy
* http://content-security-policy.com/
* https://github.com/shapesecurity/salvation
* https://developers.google.com/web/fundamentals/security/csp#policy_applies_to_a_wide_variety_of_resources

  
#### CWE Id : 16
  
#### WASC Id : 15
  
#### Source ID : 3

  
  
  
  
### Source Code Disclosure - Java
##### Medium (Medium)
  
  
  
  
#### Description
<p>Application Source Code was disclosed by the web server - Java</p>
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/vendor.bundle.js](https://datacollecte.equipements.sports.gouv.fr/vendor.bundle.js)
  
  
  * Method: `GET`
  
  
  * Evidence: `class for {\@link FormControl}, {\@link FormGroup}, and
 * {\@link FormArray}.
 *
 * It provides some of the shared behavior that all controls and groups of controls have, like
 * running validators, calculating status, and resetting state. It also defines the properties
 * that are shared between all sub-classes, like `value`, `valid`, and `dirty`. It shouldn't be
 * instantiated directly.
 *
 * \@stable
 * @abstract
 */
var AbstractControl = (function () {
    /**
     * @param {?} validator
     * @param {?} asyncValidator
     */
    function AbstractControl(validator, asyncValidator) {
        this.validator = validator;
        this.asyncValidator = asyncValidator;
        /**
         * \@internal
         */
        this._onCollectionChange = function () { };
        this._pristine = true;
        this._touched = false;
        /**
         * \@internal
         */
        this._onDisabledChange = [];
    }
    Object.defineProperty(AbstractControl.prototype, "value", {
        /**
         * The value of the control.
         * @return {?}
         */
        get: function () { return this._value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "parent", {
        /**
         * The parent control.
         * @return {?}
         */
        get: function () { return this._parent; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "status", {
        /**
         * The validation status of the control. There are four possible
         * validation statuses:
         *
         * * **VALID**:  control has passed all validation checks
         * * **INVALID**: control has failed at least one validation check
         * * **PENDING**: control is in the midst of conducting a validation check
         * * **DISABLED**: control is exempt from validation checks
         *
         * These statuses are mutually exclusive, so a control cannot be
         * both valid AND invalid or invalid AND disabled.
         * @return {?}
         */
        get: function () { return this._status; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "valid", {
        /**
         * A control is `valid` when its `status === VALID`.
         *
         * In order to have this status, the control must have passed all its
         * validation checks.
         * @return {?}
         */
        get: function () { return this._status === VALID; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "invalid", {
        /**
         * A control is `invalid` when its `status === INVALID`.
         *
         * In order to have this status, the control must have failed
         * at least one of its validation checks.
         * @return {?}
         */
        get: function () { return this._status === INVALID; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "pending", {
        /**
         * A control is `pending` when its `status === PENDING`.
         *
         * In order to have this status, the control must be in the
         * middle of conducting a validation check.
         * @return {?}
         */
        get: function () { return this._status == PENDING; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "disabled", {
        /**
         * A control is `disabled` when its `status === DISABLED`.
         *
         * Disabled controls are exempt from validation checks and
         * are not included in the aggregate value of their ancestor
         * controls.
         * @return {?}
         */
        get: function () { return this._status === DISABLED; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "enabled", {
        /**
         * A control is `enabled` as long as its `status !== DISABLED`.
         *
         * In other words, it has a status of `VALID`, `INVALID`, or
         * `PENDING`.
         * @return {?}
         */
        get: function () { return this._status !== DISABLED; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "errors", {
        /**
         * Returns any errors generated by failing validation. If there
         * are no errors, it will return null.
         * @return {?}
         */
        get: function () { return this._errors; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "pristine", {
        /**
         * A control is `pristine` if the user has not yet changed
         * the value in the UI.
         *
         * Note that programmatic changes to a control's value will
         * *not* mark it dirty.
         * @return {?}
         */
        get: function () { return this._pristine; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "dirty", {
        /**
         * A control is `dirty` if the user has changed the value
         * in the UI.
         *
         * Note that programmatic changes to a control's value will
         * *not* mark it dirty.
         * @return {?}
         */
        get: function () { return !this.pristine; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "touched", {
        /**
         * A control is marked `touched` once the user has triggered
         * a `blur` event on it.
         * @return {?}
         */
        get: function () { return this._touched; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "untouched", {
        /**
         * A control is `untouched` if the user has not yet triggered
         * a `blur` event on it.
         * @return {?}
         */
        get: function () { return !this._touched; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "valueChanges", {
        /**
         * Emits an event every time the value of the control changes, in
         * the UI or programmatically.
         * @return {?}
         */
        get: function () { return this._valueChanges; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "statusChanges", {
        /**
         * Emits an event every time the validation status of the control
         * is re-calculated.
         * @return {?}
         */
        get: function () { return this._statusChanges; },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets the synchronous validators that are active on this control.  Calling
     * this will overwrite any existing sync validators.
     * @param {?} newValidator
     * @return {?}
     */
    AbstractControl.prototype.setValidators = function (newValidator) {
        this.validator = coerceToValidator(newValidator);
    };
    /**
     * Sets the async validators that are active on this control. Calling this
     * will overwrite any existing async validators.
     * @param {?} newValidator
     * @return {?}
     */
    AbstractControl.prototype.setAsyncValidators = function (newValidator) {
        this.asyncValidator = coerceToAsyncValidator(newValidator);
    };
    /**
     * Empties out the sync validator list.
     * @return {?}
     */
    AbstractControl.prototype.clearValidators = function () { this.validator = null; };
    /**
     * Empties out the async validator list.
     * @return {?}
     */
    AbstractControl.prototype.clearAsyncValidators = function () { this.asyncValidator = null; };
    /**
     * Marks the control as `touched`.
     *
     * This will also mark all direct ancestors as `touched` to maintain
     * the model.
     * @param {?=} opts
     * @return {?}
     */
    AbstractControl.prototype.markAsTouched = function (opts) {
        if (opts === void 0) { opts = {}; }
        this._touched = true;
        if (this._parent && !opts.onlySelf) {
            this._parent.markAsTouched(opts);
        }
    };
    /**
     * Marks the control as `untouched`.
     *
     * If the control has any children, it will also mark all children as `untouched`
     * to maintain the model, and re-calculate the `touched` status of all parent
     * controls.
     * @param {?=} opts
     * @return {?}
     */
    AbstractControl.prototype.markAsUntouched = function (opts) {
        if (opts === void 0) { opts = {}; }
        this._touched = false;
        this._forEachChild(function (control) { control.markAsUntouched({ onlySelf: true }); });
        if (this._parent && !opts.onlySelf) {
            this._parent._updateTouched(opts);
        }
    };
    /**
     * Marks the control as `dirty`.
     *
     * This will also mark all direct ancestors as `dirty` to maintain
     * the model.
     * @param {?=} opts
     * @return {?}
     */
    AbstractControl.prototype.markAsDirty = function (opts) {
        if (opts === void 0) { opts = {}; }
        this._pristine = false;
        if (this._parent && !opts.onlySelf) {
            this._parent.markAsDirty(opts);
        }
    };
    /**
     * Marks the control as `pristine`.
     *
     * If the control has any children, it will also mark all children as `pristine`
     * to maintain the model, and re-calculate the `pristine` status of all parent
     * controls.
     * @param {?=} opts
     * @return {?}
     */
    AbstractControl.prototype.markAsPristine = function (opts) {
        if (opts === void 0) { opts = {}; }
        this._pristine = true;
        this._forEachChild(function (control) { control.markAsPristine({ onlySelf: true }); });
        if (this._parent && !opts.onlySelf) {
            this._parent._updatePristine(opts);
        }
    };
    /**
     * Marks the control as `pending`.
     * @param {?=} opts
     * @return {?}
     */
    AbstractControl.prototype.markAsPending = function (opts) {
        if (opts === void 0) { opts = {}; }
        this._status = PENDING;
        if (this._parent && !opts.onlySelf) {
            this._parent.markAsPending(opts);
        }
    };
    /**
     * Disables the control. This means the control will be exempt from validation checks and
     * excluded from the aggregate value of any parent. Its status is `DISABLED`.
     *
     * If the control has children, all children will be disabled to maintain the model.
     * @param {?=} opts
     * @return {?}
     */
    AbstractControl.prototype.disable = function (opts) {
        if (opts === void 0) { opts = {}; }
        this._status = DISABLED;
        this._errors = null;
        this._forEachChild(function (control) { control.disable({ onlySelf: true }); });
        this._updateValue();
        if (opts.emitEvent !== false) {
            this._valueChanges.emit(this._value);
            this._statusChanges.emit(this._status);
        }
        this._updateAncestors(!!opts.onlySelf);
        this._onDisabledChange.forEach(function (changeFn) { return changeFn(true); });
    };
    /**
     * Enables the control. This means the control will be included in validation checks and
     * the aggregate value of its parent. Its status is re-calculated based on its value and
     * its validators.
     *
     * If the control has children, all children will be enabled.
     * @param {?=} opts
     * @return {?}
     */
    AbstractControl.prototype.enable = function (opts) {
        if (opts === void 0) { opts = {}; }
        this._status = VALID;
        this._forEachChild(function (control) { control.enable({ onlySelf: true }); });
        this.updateValueAndValidity({ onlySelf: true, emitEvent: opts.emitEvent });
        this._updateAncestors(!!opts.onlySelf);
        this._onDisabledChange.forEach(function (changeFn) { return changeFn(false); });
    };
    /**
     * @param {?} onlySelf
     * @return {?}
     */
    AbstractControl.prototype._updateAncestors = function (onlySelf) {
        if (this._parent && !onlySelf) {
            this._parent.updateValueAndValidity();
            this._parent._updatePristine();
            this._parent._updateTouched();
        }
    };
    /**
     * @param {?} parent
     * @return {?}
     */
    AbstractControl.prototype.setParent = function (parent) { this._parent = parent; };
    /**
     * Sets the value of the control. Abstract method (implemented in sub-classes).
     * @abstract
     * @param {?} value
     * @param {?=} options
     * @return {?}
     */
    AbstractControl.prototype.setValue = function (value, options) { };
    /**
     * Patches the value of the control. Abstract method (implemented in sub-classes).
     * @abstract
     * @param {?} value
     * @param {?=} options
     * @return {?}
     */
    AbstractControl.prototype.patchValue = function (value, options) { };
    /**
     * Resets the control. Abstract method (implemented in sub-classes).
     * @abstract
     * @param {?=} value
     * @param {?=} options
     * @return {?}
     */
    AbstractControl.prototype.reset = function (value, options) { };
    /**
     * Re-calculates the value and validation status of the control.
     *
     * By default, it will also update the value and validity of its ancestors.
     * @param {?=} opts
     * @return {?}
     */
    AbstractControl.prototype.updateValueAndValidity = function (opts) {
        if (opts === void 0) { opts = {}; }
        this._setInitialStatus();
        this._updateValue();
        if (this.enabled) {
            this._cancelExistingSubscription();
            this._errors = this._runValidator();
            this._status = this._calculateStatus();
            if (this._status === VALID || this._status === PENDING) {
                this._runAsyncValidator(opts.emitEvent);
            }
        }
        if (opts.emitEvent !== false) {
            this._valueChanges.emit(this._value);
            this._statusChanges.emit(this._status);
        }
        if (this._parent && !opts.onlySelf) {
            this._parent.updateValueAndValidity(opts);
        }
    };
    /**
     * \@internal
     * @param {?=} opts
     * @return {?}
     */
    AbstractControl.prototype._updateTreeValidity = function (opts) {
        if (opts === void 0) { opts = { emitEvent: true }; }
        this._forEachChild(function (ctrl) { return ctrl._updateTreeValidity(opts); });
        this.updateValueAndValidity({ onlySelf: true, emitEvent: opts.emitEvent });
    };
    /**
     * @return {?}
     */
    AbstractControl.prototype._setInitialStatus = function () { this._status = this._allControlsDisabled() ? DISABLED : VALID; };
    /**
     * @return {?}
     */
    AbstractControl.prototype._runValidator = function () {
        return this.validator ? this.validator(this) : null;
    };
    /**
     * @param {?=} emitEvent
     * @return {?}
     */
    AbstractControl.prototype._runAsyncValidator = function (emitEvent) {
        var _this = this;
        if (this.asyncValidator) {
            this._status = PENDING;
            var /** @type {?} */ obs = toObservable(this.asyncValidator(this));
            this._asyncValidationSubscription =
                obs.subscribe(function (errors) { return _this.setErrors(errors, { emitEvent: emitEvent }); });
        }
    };
    /**
     * @return {?}
     */
    AbstractControl.prototype._cancelExistingSubscription = function () {
        if (this._asyncValidationSubscription) {
            this._asyncValidationSubscription.unsubscribe();
        }
    };
    /**
     * Sets errors on a form control.
     *
     * This is used when validations are run manually by the user, rather than automatically.
     *
     * Calling `setErrors` will also update the validity of the parent control.
     *
     * ### Example
     *
     * ```
     * const login = new FormControl("someLogin");
     * login.setErrors({
     *   "notUnique": true
     * });
     *
     * expect(login.valid).toEqual(false);
     * expect(login.errors).toEqual({"notUnique": true});
     *
     * login.setValue("someOtherLogin");
     *
     * expect(login.valid).toEqual(true);
     * ```
     * @param {?} errors
     * @param {?=} opts
     * @return {?}
     */
    AbstractControl.prototype.setErrors = function (errors, opts) {
        if (opts === void 0) { opts = {}; }
        this._errors = errors;
        this._updateControlsErrors(opts.emitEvent !== false);
    };
    /**
     * Retrieves a child control given the control's name or path.
     *
     * Paths can be passed in as an array or a string delimited by a dot.
     *
     * To get a control nested within a `person` sub-group:
     *
     * * `this.form.get('person.name');`
     *
     * -OR-
     *
     * * `this.form.get(['person', 'name']);`
     * @param {?} path
     * @return {?}
     */
    AbstractControl.prototype.get = function (path) { return _find(this, path, '.'); };
    /**
     * Returns error data if the control with the given path has the error specified. Otherwise
     * returns null or undefined.
     *
     * If no path is given, it checks for the error on the present control.
     * @param {?} errorCode
     * @param {?=} path
     * @return {?}
     */
    AbstractControl.prototype.getError = function (errorCode, path) {
        var /** @type {?} */ control = path ? this.get(path) : this;
        return control && control._errors ? control._errors[errorCode] : null;
    };
    /**
     * Returns true if the control with the given path has the error specified. Otherwise
     * returns false.
     *
     * If no path is given, it checks for the error on the present control.
     * @param {?} errorCode
     * @param {?=} path
     * @return {?}
     */
    AbstractControl.prototype.hasError = function (errorCode, path) { return !!this.getError(errorCode, path); };
    Object.defineProperty(AbstractControl.prototype, "root", {
        /**
         * Retrieves the top-level ancestor of this control.
         * @return {?}
         */
        get: function () {
            var /** @type {?} */ x = this;
            while (x._parent) {
                x = x._parent;
            }
            return x;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * \@internal
     * @param {?} emitEvent
     * @return {?}
     */
    AbstractControl.prototype._updateControlsErrors = function (emitEvent) {
        this._status = this._calculateStatus();
        if (emitEvent) {
            this._statusChanges.emit(this._status);
        }
        if (this._parent) {
            this._parent._updateControlsErrors(emitEvent);
        }
    };
    /**
     * \@internal
     * @return {?}
     */
    AbstractControl.prototype._initObservables = function () {
        this._valueChanges = new __WEBPACK_IMPORTED_MODULE_1__angular_core__["EventEmitter"]();
        this._statusChanges = new __WEBPACK_IMPORTED_MODULE_1__angular_core__["EventEmitter"]();
    };
    /**
     * @return {?}
     */
    AbstractControl.prototype._calculateStatus = function () {
        if (this._allControlsDisabled())
            return DISABLED;
        if (this._errors)
            return INVALID;
        if (this._anyControlsHaveStatus(PENDING))
            return PENDING;
        if (this._anyControlsHaveStatus(INVALID))
            return INVALID;
        return VALID;
    };
    /**
     * \@internal
     * @abstract
     * @return {?}
     */
    AbstractControl.prototype._updateValue = function () { };
    /**
     * \@internal
     * @abstract
     * @param {?} cb
     * @return {?}
     */
    AbstractControl.prototype._forEachChild = function (cb) { };
    /**
     * \@internal
     * @abstract
     * @param {?} condition
     * @return {?}
     */
    AbstractControl.prototype._anyControls = function (condition) { };
    /**
     * \@internal
     * @abstract
     * @return {?}
     */
    AbstractControl.prototype._allControlsDisabled = function () { };
    /**
     * \@internal
     * @param {?} status
     * @return {?}
     */
    AbstractControl.prototype._anyControlsHaveStatus = function (status) {
        return this._anyControls(function (control) { return control.status === status; });
    };
    /**
     * \@internal
     * @return {?}
     */
    AbstractControl.prototype._anyControlsDirty = function () {
        return this._anyControls(function (control) { return control.dirty; });
    };
    /**
     * \@internal
     * @return {?}
     */
    AbstractControl.prototype._anyControlsTouched = function () {
        return this._anyControls(function (control) { return control.touched; });
    };
    /**
     * \@internal
     * @param {?=} opts
     * @return {?}
     */
    AbstractControl.prototype._updatePristine = function (opts) {
        if (opts === void 0) { opts = {}; }
        this._pristine = !this._anyControlsDirty();
        if (this._parent && !opts.onlySelf) {
            this._parent._updatePristine(opts);
        }
    };
    /**
     * \@internal
     * @param {?=} opts
     * @return {?}
     */
    AbstractControl.prototype._updateTouched = function (opts) {
        if (opts === void 0) { opts = {}; }
        this._touched = this._anyControlsTouched();
        if (this._parent && !opts.onlySelf) {
            this._parent._updateTouched(opts);
        }
    };
    /**
     * \@internal
     * @param {?} formState
     * @return {?}
     */
    AbstractControl.prototype._isBoxedValue = function (formState) {
        return typeof formState === 'object' && formState !== null &&
            Object.keys(formState).length === 2 && 'value' in formState && 'disabled' in formState;
    };
    /**
     * \@internal
     * @param {?} fn
     * @return {?}
     */
    AbstractControl.prototype._registerOnCollectionChange = function (fn) { this._onCollectionChange = fn; };
    return AbstractControl;
}());
/**
 * \@whatItDoes Tracks the value and validation status of an individual form control.
 *
 * It is one of the three fundamental building blocks of Angular forms, along with
 * {\@link FormGroup} and {\@link FormArray}.
 *
 * \@howToUse
 *
 * When instantiating a {\@link FormControl}, you can pass in an initial value as the
 * first argument. Example:
 *
 * ```ts
 * const ctrl = new FormControl('some value');
 * console.log(ctrl.value);     // 'some value'
 * ```
 *
 * You can also initialize the control with a form state object on instantiation,
 * which includes both the value and whether or not the control is disabled.
 * You can't use the value key without the disabled key; both are required
 * to use this way of initialization.
 *
 * ```ts
 * const ctrl = new FormControl({value: 'n/a', disabled: true});
 * console.log(ctrl.value);     // 'n/a'
 * console.log(ctrl.status);   // 'DISABLED'
 * ```
 *
 * To include a sync validator (or an array of sync validators) with the control,
 * pass it in as the second argument. Async validators are also supported, but
 * have to be passed in separately as the third arg.
 *
 * ```ts
 * const ctrl = new FormControl('', Validators.required);
 * console.log(ctrl.value);     // ''
 * console.log(ctrl.status);   // 'INVALID'
 * ```
 *
 * See its superclass, {\@link AbstractControl}, for more properties and methods.
 *
 * * **npm package**: `\@angular/forms`
 *
 * \@stable
 */
var FormControl = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](FormControl, _super);
    /**
     * @param {?=} formState
     * @param {?=} validator
     * @param {?=} asyncValidator
     */
    function FormControl(formState, validator, asyncValidator) {
        if (formState === void 0) { formState = null; }
        var _this = _super.call(this, coerceToValidator(validator), coerceToAsyncValidator(asyncValidator)) || this;
        /**
         * \@internal
         */
        _this._onChange = [];
        _this._applyFormState(formState);
        _this.updateValueAndValidity({ onlySelf: true, emitEvent: false });
        _this._initObservables();
        return _this;
    }
    /**
     * Set the value of the form control to `value`.
     *
     * If `onlySelf` is `true`, this change will only affect the validation of this `FormControl`
     * and not its parent component. This defaults to false.
     *
     * If `emitEvent` is `true`, this
     * change will cause a `valueChanges` event on the `FormControl` to be emitted. This defaults
     * to true (as it falls through to `updateValueAndValidity`).
     *
     * If `emitModelToViewChange` is `true`, the view will be notified about the new value
     * via an `onChange` event. This is the default behavior if `emitModelToViewChange` is not
     * specified.
     *
     * If `emitViewToModelChange` is `true`, an ngModelChange event will be fired to update the
     * model.  This is the default behavior if `emitViewToModelChange` is not specified.
     * @param {?} value
     * @param {?=} options
     * @return {?}
     */
    FormControl.prototype.setValue = function (value, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        this._value = value;
        if (this._onChange.length && options.emitModelToViewChange !== false) {
            this._onChange.forEach(function (changeFn) { return changeFn(_this._value, options.emitViewToModelChange !== false); });
        }
        this.updateValueAndValidity(options);
    };
    /**
     * Patches the value of a control.
     *
     * This function is functionally the same as {\@link FormControl#setValue} at this level.
     * It exists for symmetry with {\@link FormGroup#patchValue} on `FormGroups` and `FormArrays`,
     * where it does behave differently.
     * @param {?} value
     * @param {?=} options
     * @return {?}
     */
    FormControl.prototype.patchValue = function (value, options) {
        if (options === void 0) { options = {}; }
        this.setValue(value, options);
    };
    /**
     * Resets the form control. This means by default:
     *
     * * it is marked as `pristine`
     * * it is marked as `untouched`
     * * value is set to null
     *
     * You can also reset to a specific form state by passing through a standalone
     * value or a form state object that contains both a value and a disabled state
     * (these are the only two properties that cannot be calculated).
     *
     * Ex:
     *
     * ```ts
     * this.control.reset('Nancy');
     *
     * console.log(this.control.value);  // 'Nancy'
     * ```
     *
     * OR
     *
     * ```
     * this.control.reset({value: 'Nancy', disabled: true});
     *
     * console.log(this.control.value);  // 'Nancy'
     * console.log(this.control.status);  // 'DISABLED'
     * ```
     * @param {?=} formState
     * @param {?=} options
     * @return {?}
     */
    FormControl.prototype.reset = function (formState, options) {
        if (formState === void 0) { formState = null; }
        if (options === void 0) { options = {}; }
        this._applyFormState(formState);
        this.markAsPristine(options);
        this.markAsUntouched(options);
        this.setValue(this._value, options);
    };
    /**
     * \@internal
     * @return {?}
     */
    FormControl.prototype._updateValue = function () { };
    /**
     * \@internal
     * @param {?} condition
     * @return {?}
     */
    FormControl.prototype._anyControls = function (condition) { return false; };
    /**
     * \@internal
     * @return {?}
     */
    FormControl.prototype._allControlsDisabled = function () { return this.disabled; };
    /**
     * Register a listener for change events.
     * @param {?} fn
     * @return {?}
     */
    FormControl.prototype.registerOnChange = function (fn) { this._onChange.push(fn); };
    /**
     * \@internal
     * @return {?}
     */
    FormControl.prototype._clearChangeFns = function () {
        this._onChange = [];
        this._onDisabledChange = [];
        this._onCollectionChange = function () { };
    };
    /**
     * Register a listener for disabled events.
     * @param {?} fn
     * @return {?}
     */
    FormControl.prototype.registerOnDisabledChange = function (fn) {
        this._onDisabledChange.push(fn);
    };
    /**
     * \@internal
     * @param {?} cb
     * @return {?}
     */
    FormControl.prototype._forEachChild = function (cb) { };
    /**
     * @param {?} formState
     * @return {?}
     */
    FormControl.prototype._applyFormState = function (formState) {
        if (this._isBoxedValue(formState)) {
            this._value = formState.value;
            formState.disabled ? this.disable({ onlySelf: true, emitEvent: false }) :
                this.enable({ onlySelf: true, emitEvent: false });
        }
        else {
            this._value = formState;
        }
    };
    return FormControl;
}(AbstractControl));
/**
 * \@whatItDoes Tracks the value and validity state of a group of {\@link FormControl}
 * instances.
 *
 * A `FormGroup` aggregates the values of each child {\@link FormControl} into one object,
 * with each control name as the key.  It calculates its status by reducing the statuses
 * of its children. For example, if one of the controls in a group is invalid, the entire
 * group becomes invalid.
 *
 * `FormGroup` is one of the three fundamental building blocks used to define forms in Angular,
 * along with {\@link FormControl} and {\@link FormArray}.
 *
 * \@howToUse
 *
 * When instantiating a {\@link FormGroup}, pass in a collection of child controls as the first
 * argument. The key for each child will be the name under which it is registered.
 *
 * ### Example
 *
 * ```
 * const form = new FormGroup({
 *   first: new FormControl('Nancy', Validators.minLength(2)),
 *   last: new FormControl('Drew'),
 * });
 *
 * console.log(form.value);   // {first: 'Nancy', last; 'Drew'}
 * console.log(form.status);  // 'VALID'
 * ```
 *
 * You can also include group-level validators as the second arg, or group-level async
 * validators as the third arg. These come in handy when you want to perform validation
 * that considers the value of more than one child control.
 *
 * ### Example
 *
 * ```
 * const form = new FormGroup({
 *   password: new FormControl('', Validators.minLength(2)),
 *   passwordConfirm: new FormControl('', Validators.minLength(2)),
 * }, passwordMatchValidator);
 *
 *
 * function passwordMatchValidator(g: FormGroup) {
 *    return g.get('password').value === g.get('passwordConfirm').value
 *       ? null : {'mismatch': true};
 * }
 * ```
 *
 * * **npm package**: `\@angular/forms`
 *
 * \@stable
 */
var FormGroup = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](FormGroup, _super);
    /**
     * @param {?} controls
     * @param {?=} validator
     * @param {?=} asyncValidator
     */
    function FormGroup(controls, validator, asyncValidator) {
        var _this = _super.call(this, validator || null, asyncValidator || null) || this;
        _this.controls = controls;
        _this._initObservables();
        _this._setUpControls();
        _this.updateValueAndValidity({ onlySelf: true, emitEvent: false });
        return _this;
    }
    /**
     * Registers a control with the group's list of controls.
     *
     * This method does not update value or validity of the control, so for
     * most cases you'll want to use {\@link FormGroup#addControl} instead.
     * @param {?} name
     * @param {?} control
     * @return {?}
     */
    FormGroup.prototype.registerControl = function (name, control) {
        if (this.controls[name])
            return this.controls[name];
        this.controls[name] = control;
        control.setParent(this);
        control._registerOnCollectionChange(this._onCollectionChange);
        return control;
    };
    /**
     * Add a control to this group.
     * @param {?} name
     * @param {?} control
     * @return {?}
     */
    FormGroup.prototype.addControl = function (name, control) {
        this.registerControl(name, control);
        this.updateValueAndValidity();
        this._onCollectionChange();
    };
    /**
     * Remove a control from this group.
     * @param {?} name
     * @return {?}
     */
    FormGroup.prototype.removeControl = function (name) {
        if (this.controls[name])
            this.controls[name]._registerOnCollectionChange(function () { });
        delete (this.controls[name]);
        this.updateValueAndValidity();
        this._onCollectionChange();
    };
    /**
     * Replace an existing control.
     * @param {?} name
     * @param {?} control
     * @return {?}
     */
    FormGroup.prototype.setControl = function (name, control) {
        if (this.controls[name])
            this.controls[name]._registerOnCollectionChange(function () { });
        delete (this.controls[name]);
        if (control)
            this.registerControl(name, control);
        this.updateValueAndValidity();
        this._onCollectionChange();
    };
    /**
     * Check whether there is an enabled control with the given name in the group.
     *
     * It will return false for disabled controls. If you'd like to check for
     * existence in the group only, use {\@link AbstractControl#get} instead.
     * @param {?} controlName
     * @return {?}
     */
    FormGroup.prototype.contains = function (controlName) {
        return this.controls.hasOwnProperty(controlName) && this.controls[controlName].enabled;
    };
    /**
     *  Sets the value of the {\@link FormGroup}. It accepts an object that matches
     *  the structure of the group, with control names as keys.
     *
     * This method performs strict checks, so it will throw an error if you try
     * to set the value of a control that doesn't exist or if you exclude the
     * value of a control.
     *
     *  ### Example
     *
     *  ```
     *  const form = new FormGroup({
     *     first: new FormControl(),
     *     last: new FormControl()
     *  });
     *  console.log(form.value);   // {first: null, last: null}
     *
     *  form.setValue({first: 'Nancy', last: 'Drew'});
     *  console.log(form.value);   // {first: 'Nancy', last: 'Drew'}
     *
     *  ```
     * @param {?} value
     * @param {?=} options
     * @return {?}
     */
    FormGroup.prototype.setValue = function (value, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        this._checkAllValuesPresent(value);
        Object.keys(value).forEach(function (name) {
            _this._throwIfControlMissing(name);
            _this.controls[name].setValue(value[name], { onlySelf: true, emitEvent: options.emitEvent });
        });
        this.updateValueAndValidity(options);
    };
    /**
     *  Patches the value of the {\@link FormGroup}. It accepts an object with control
     *  names as keys, and will do its best to match the values to the correct controls
     *  in the group.
     *
     *  It accepts both super-sets and sub-sets of the group without throwing an error.
     *
     *  ### Example
     *
     *  ```
     *  const form = new FormGroup({
     *     first: new FormControl(),
     *     last: new FormControl()
     *  });
     *  console.log(form.value);   // {first: null, last: null}
     *
     *  form.patchValue({first: 'Nancy'});
     *  console.log(form.value);   // {first: 'Nancy', last: null}
     *
     *  ```
     * @param {?} value
     * @param {?=} options
     * @return {?}
     */
    FormGroup.prototype.patchValue = function (value, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        Object.keys(value).forEach(function (name) {
            if (_this.controls[name]) {
                _this.controls[name].patchValue(value[name], { onlySelf: true, emitEvent: options.emitEvent });
            }
        });
        this.updateValueAndValidity(options);
    };
    /**
     * Resets the {\@link FormGroup}. This means by default:
     *
     * * The group and all descendants are marked `pristine`
     * * The group and all descendants are marked `untouched`
     * * The value of all descendants will be null or null maps
     *
     * You can also reset to a specific form state by passing in a map of states
     * that matches the structure of your form, with control names as keys. The state
     * can be a standalone value or a form state object with both a value and a disabled
     * status.
     *
     * ### Example
     *
     * ```ts
     * this.form.reset({first: 'name', last: 'last name'});
     *
     * console.log(this.form.value);  // {first: 'name', last: 'last name'}
     * ```
     *
     * - OR -
     *
     * ```
     * this.form.reset({
     *   first: {value: 'name', disabled: true},
     *   last: 'last'
     * });
     *
     * console.log(this.form.value);  // {first: 'name', last: 'last name'}
     * console.log(this.form.get('first').status);  // 'DISABLED'
     * ```
     * @param {?=} value
     * @param {?=} options
     * @return {?}
     */
    FormGroup.prototype.reset = function (value, options) {
        if (value === void 0) { value = {}; }
        if (options === void 0) { options = {}; }
        this._forEachChild(function (control, name) {
            control.reset(value[name], { onlySelf: true, emitEvent: options.emitEvent });
        });
        this.updateValueAndValidity(options);
        this._updatePristine(options);
        this._updateTouched(options);
    };
    /**
     * The aggregate value of the {\@link FormGroup}, including any disabled controls.
     *
     * If you'd like to include all values regardless of disabled status, use this method.
     * Otherwise, the `value` property is the best way to get the value of the group.
     * @return {?}
     */
    FormGroup.prototype.getRawValue = function () {
        return this._reduceChildren({}, function (acc, control, name) {
            acc[name] = control instanceof FormControl ? control.value : ((control)).getRawValue();
            return acc;
        });
    };
    /**
     * \@internal
     * @param {?} name
     * @return {?}
     */
    FormGroup.prototype._throwIfControlMissing = function (name) {
        if (!Object.keys(this.controls).length) {
            throw new Error("\n        There are no form controls registered with this group yet.  If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      ");
        }
        if (!this.controls[name]) {
            throw new Error("Cannot find form control with name: " + name + ".");
        }
    };
    /**
     * \@internal
     * @param {?} cb
     * @return {?}
     */
    FormGroup.prototype._forEachChild = function (cb) {
        var _this = this;
        Object.keys(this.controls).forEach(function (k) { return cb(_this.controls[k], k); });
    };
    /**
     * \@internal
     * @return {?}
     */
    FormGroup.prototype._setUpControls = function () {
        var _this = this;
        this._forEachChild(function (control) {
            control.setParent(_this);
            control._registerOnCollectionChange(_this._onCollectionChange);
        });
    };
    /**
     * \@internal
     * @return {?}
     */
    FormGroup.prototype._updateValue = function () { this._value = this._reduceValue(); };
    /**
     * \@internal
     * @param {?} condition
     * @return {?}
     */
    FormGroup.prototype._anyControls = function (condition) {
        var _this = this;
        var /** @type {?} */ res = false;
        this._forEachChild(function (control, name) {
            res = res || (_this.contains(name) && condition(control));
        });
        return res;
    };
    /**
     * \@internal
     * @return {?}
     */
    FormGroup.prototype._reduceValue = function () {
        var _this = this;
        return this._reduceChildren({}, function (acc, control, name) {
            if (control.enabled || _this.disabled) {
                acc[name] = control.value;
            }
            return acc;
        });
    };
    /**
     * \@internal
     * @param {?} initValue
     * @param {?} fn
     * @return {?}
     */
    FormGroup.prototype._reduceChildren = function (initValue, fn) {
        var /** @type {?} */ res = initValue;
        this._forEachChild(function (control, name) { res = fn(res, control, name); });
        return res;
    };
    /**
     * \@internal
     * @return {?}
     */
    FormGroup.prototype._allControlsDisabled = function () {
        for (var _i = 0, _a = Object.keys(this.controls); _i < _a.length; _i++) {
            var controlName = _a[_i];
            if (this.controls[controlName].enabled) {
                return false;
            }
        }
        return Object.keys(this.controls).length > 0 || this.disabled;
    };
    /**
     * \@internal
     * @param {?} value
     * @return {?}
     */
    FormGroup.prototype._checkAllValuesPresent = function (value) {
        this._forEachChild(function (control, name) {
            if (value[name] === undefined) {
                throw new Error("Must supply a value for form control with name: '" + name + "'.");
            }
        });
    };
    return FormGroup;
}(AbstractControl));
/**
 * \@whatItDoes Tracks the value and validity state of an array of {\@link FormControl},
 * {\@link FormGroup} or {\@link FormArray} instances.
 *
 * A `FormArray` aggregates the values of each child {\@link FormControl} into an array.
 * It calculates its status by reducing the statuses of its children. For example, if one of
 * the controls in a `FormArray` is invalid, the entire array becomes invalid.
 *
 * `FormArray` is one of the three fundamental building blocks used to define forms in Angular,
 * along with {\@link FormControl} and {\@link FormGroup}.
 *
 * \@howToUse
 *
 * When instantiating a {\@link FormArray}, pass in an array of child controls as the first
 * argument.
 *
 * ### Example
 *
 * ```
 * const arr = new FormArray([
 *   new FormControl('Nancy', Validators.minLength(2)),
 *   new FormControl('Drew'),
 * ]);
 *
 * console.log(arr.value);   // ['Nancy', 'Drew']
 * console.log(arr.status);  // 'VALID'
 * ```
 *
 * You can also include array-level validators as the second arg, or array-level async
 * validators as the third arg. These come in handy when you want to perform validation
 * that considers the value of more than one child control.
 *
 * ### Adding or removing controls
 *
 * To change the controls in the array, use the `push`, `insert`, or `removeAt` methods
 * in `FormArray` itself. These methods ensure the controls are properly tracked in the
 * form's hierarchy. Do not modify the array of `AbstractControl`s used to instantiate
 * the `FormArray` directly, as that will result in strange and unexpected behavior such
 * as broken change detection.
 *
 * * **npm package**: `\@angular/forms`
 *
 * \@stable
 */
var FormArray = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](FormArray, _super);
    /**
     * @param {?} controls
     * @param {?=} validator
     * @param {?=} asyncValidator
     */
    function FormArray(controls, validator, asyncValidator) {
        var _this = _super.call(this, validator || null, asyncValidator || null) || this;
        _this.controls = controls;
        _this._initObservables();
        _this._setUpControls();
        _this.updateValueAndValidity({ onlySelf: true, emitEvent: false });
        return _this;
    }
    /**
     * Get the {\@link AbstractControl} at the given `index` in the array.
     * @param {?} index
     * @return {?}
     */
    FormArray.prototype.at = function (index) { return this.controls[index]; };
    /**
     * Insert a new {\@link AbstractControl} at the end of the array.
     * @param {?} control
     * @return {?}
     */
    FormArray.prototype.push = function (control) {
        this.controls.push(control);
        this._registerControl(control);
        this.updateValueAndValidity();
        this._onCollectionChange();
    };
    /**
     * Insert a new {\@link AbstractControl} at the given `index` in the array.
     * @param {?} index
     * @param {?} control
     * @return {?}
     */
    FormArray.prototype.insert = function (index, control) {
        this.controls.splice(index, 0, control);
        this._registerControl(control);
        this.updateValueAndValidity();
        this._onCollectionChange();
    };
    /**
     * Remove the control at the given `index` in the array.
     * @param {?} index
     * @return {?}
     */
    FormArray.prototype.removeAt = function (index) {
        if (this.controls[index])
            this.controls[index]._registerOnCollectionChange(function () { });
        this.controls.splice(index, 1);
        this.updateValueAndValidity();
        this._onCollectionChange();
    };
    /**
     * Replace an existing control.
     * @param {?} index
     * @param {?} control
     * @return {?}
     */
    FormArray.prototype.setControl = function (index, control) {
        if (this.controls[index])
            this.controls[index]._registerOnCollectionChange(function () { });
        this.controls.splice(index, 1);
        if (control) {
            this.controls.splice(index, 0, control);
            this._registerControl(control);
        }
        this.updateValueAndValidity();
        this._onCollectionChange();
    };
    Object.defineProperty(FormArray.prototype, "length", {
        /**
         * Length of the control array.
         * @return {?}
         */
        get: function () { return this.controls.length; },
        enumerable: true,
        configurable: true
    });
    /**
     *  Sets the value of the {\@link FormArray}. It accepts an array that matches
     *  the structure of the control.
     *
     * This method performs strict checks, so it will throw an error if you try
     * to set the value of a control that doesn't exist or if you exclude the
     * value of a control.
     *
     *  ### Example
     *
     *  ```
     *  const arr = new FormArray([
     *     new FormControl(),
     *     new FormControl()
     *  ]);
     *  console.log(arr.value);   // [null, null]
     *
     *  arr.setValue(['Nancy', 'Drew']);
     *  console.log(arr.value);   // ['Nancy', 'Drew']
     *  ```
     * @param {?} value
     * @param {?=} options
     * @return {?}
     */
    FormArray.prototype.setValue = function (value, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        this._checkAllValuesPresent(value);
        value.forEach(function (newValue, index) {
            _this._throwIfControlMissing(index);
            _this.at(index).setValue(newValue, { onlySelf: true, emitEvent: options.emitEvent });
        });
        this.updateValueAndValidity(options);
    };
    /**
     *  Patches the value of the {\@link FormArray}. It accepts an array that matches the
     *  structure of the control, and will do its best to match the values to the correct
     *  controls in the group.
     *
     *  It accepts both super-sets and sub-sets of the array without throwing an error.
     *
     *  ### Example
     *
     *  ```
     *  const arr = new FormArray([
     *     new FormControl(),
     *     new FormControl()
     *  ]);
     *  console.log(arr.value);   // [null, null]
     *
     *  arr.patchValue(['Nancy']);
     *  console.log(arr.value);   // ['Nancy', null]
     *  ```
     * @param {?} value
     * @param {?=} options
     * @return {?}
     */
    FormArray.prototype.patchValue = function (value, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        value.forEach(function (newValue, index) {
            if (_this.at(index)) {
                _this.at(index).patchValue(newValue, { onlySelf: true, emitEvent: options.emitEvent });
            }
        });
        this.updateValueAndValidity(options);
    };
    /**
     * Resets the {\@link FormArray}. This means by default:
     *
     * * The array and all descendants are marked `pristine`
     * * The array and all descendants are marked `untouched`
     * * The value of all descendants will be null or null maps
     *
     * You can also reset to a specific form state by passing in an array of states
     * that matches the structure of the control. The state can be a standalone value
     * or a form state object with both a value and a disabled status.
     *
     * ### Example
     *
     * ```ts
     * this.arr.reset(['name', 'last name']);
     *
     * console.log(this.arr.value);  // ['name', 'last name']
     * ```
     *
     * - OR -
     *
     * ```
     * this.arr.reset([
     *   {value: 'name', disabled: true},
     *   'last'
     * ]);
     *
     * console.log(this.arr.value);  // ['name', 'last name']
     * console.log(this.arr.get(0).status);  // 'DISABLED'
     * ```
     * @param {?=} value
     * @param {?=} options
     * @return {?}
     */
    FormArray.prototype.reset = function (value, options) {
        if (value === void 0) { value = []; }
        if (options === void 0) { options = {}; }
        this._forEachChild(function (control, index) {
            control.reset(value[index], { onlySelf: true, emitEvent: options.emitEvent });
        });
        this.updateValueAndValidity(options);
        this._updatePristine(options);
        this._updateTouched(options);
    };
    /**
     * The aggregate value of the array, including any disabled controls.
     *
     * If you'd like to include all values regardless of disabled status, use this method.
     * Otherwise, the `value` property is the best way to get the value of the array.
     * @return {?}
     */
    FormArray.prototype.getRawValue = function () {
        return this.controls.map(function (control) {
            return control instanceof FormControl ? control.value : ((control)).getRawValue();
        });
    };
    /**
     * \@internal
     * @param {?} index
     * @return {?}
     */
    FormArray.prototype._throwIfControlMissing = function (index) {
        if (!this.controls.length) {
            throw new Error("\n        There are no form controls registered with this array yet.  If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      ");
        }
        if (!this.at(index)) {
            throw new Error("Cannot find form control at index " + index);
        }
    };
    /**
     * \@internal
     * @param {?} cb
     * @return {?}
     */
    FormArray.prototype._forEachChild = function (cb) {
        this.controls.forEach(function (control, index) { cb(control, index); });
    };
    /**
     * \@internal
     * @return {?}
     */
    FormArray.prototype._updateValue = function () {
        var _this = this;
        this._value = this.controls.filter(function (control) { return control.enabled || _this.disabled; })
            .map(function (control) { return control.value; });
    };
    /**
     * \@internal
     * @param {?} condition
     * @return {?}
     */
    FormArray.prototype._anyControls = function (condition) {
        return this.controls.some(function (control) { return control.enabled && condition(control); });
    };
    /**
     * \@internal
     * @return {?}
     */
    FormArray.prototype._setUpControls = function () {
        var _this = this;
        this._forEachChild(function (control) { return _this._registerControl(control); });
    };
    /**
     * \@internal
     * @param {?} value
     * @return {?}
     */
    FormArray.prototype._checkAllValuesPresent = function (value) {
        this._forEachChild(function (control, i) {
            if (value[i] === undefined) {
                throw new Error("Must supply a value for form control at index: " + i + ".");
            }
        });
    };
    /**
     * \@internal
     * @return {?}
     */
    FormArray.prototype._allControlsDisabled = function () {
        for (var _i = 0, _a = this.controls; _i < _a.length; _i++) {
            var control = _a[_i];
            if (control.enabled)
                return false;
        }
        return this.controls.length > 0 || this.disabled;
    };
    /**
     * @param {?} control
     * @return {?}
     */
    FormArray.prototype._registerControl = function (control) {
        control.setParent(this);
        control._registerOnCollectionChange(this._onCollectionChange);
    };
    return FormArray;
}(AbstractControl));
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var formDirectiveProvider = {
    provide: ControlContainer,
    useExisting: Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["forwardRef"])(function () { return NgForm; })
};
var resolvedPromise = Promise.resolve(null);
/**
 * \@whatItDoes Creates a top-level {\@link FormGroup} instance and binds it to a form
 * to track aggregate form value and validation status.
 *
 * \@howToUse
 *
 * As soon as you import the `FormsModule`, this directive becomes active by default on
 * all `<form>` tags.  You don't need to add a special selector.
 *
 * You can export the directive into a local template variable using `ngForm` as the key
 * (ex: `#myForm="ngForm"`). This is optional, but useful.  Many properties from the underlying
 * {\@link FormGroup} instance are duplicated on the directive itself, so a reference to it
 * will give you access to the aggregate value and validity status of the form, as well as
 * user interaction properties like `dirty` and `touched`.
 *
 * To register child controls with the form, you'll want to use {\@link NgModel} with a
 * `name` attribute.  You can also use {\@link NgModelGroup} if you'd like to create
 * sub-groups within the form.
 *
 * You can listen to the directive's `ngSubmit` event to be notified when the user has
 * triggered a form submission. The `ngSubmit` event will be emitted with the original form
 * submission event.
 *
 * {\@example forms/ts/simpleForm/simple_form_example.ts region='Component'}
 *
 * * **npm package**: `\@angular/forms`
 *
 * * **NgModule**: `FormsModule`
 *
 *  \@stable
 */
var NgForm = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](NgForm, _super);
    /**
     * @param {?} validators
     * @param {?} asyncValidators
     */
    function NgForm(validators, asyncValidators) {
        var _this = _super.call(this) || this;
        _this._submitted = false;
        _this.ngSubmit = new __WEBPACK_IMPORTED_MODULE_1__angular_core__["EventEmitter"]();
        _this.form =
            new FormGroup({}, composeValidators(validators), composeAsyncValidators(asyncValidators));
        return _this;
    }
    Object.defineProperty(NgForm.prototype, "submitted", {
        /**
         * @return {?}
         */
        get: function () { return this._submitted; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgForm.prototype, "formDirective", {
        /**
         * @return {?}
         */
        get: function () { return this; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgForm.prototype, "control", {
        /**
         * @return {?}
         */
        get: function () { return this.form; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgForm.prototype, "path", {
        /**
         * @return {?}
         */
        get: function () { return []; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgForm.prototype, "controls", {
        /**
         * @return {?}
         */
        get: function () { return this.form.controls; },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} dir
     * @return {?}
     */
    NgForm.prototype.addControl = function (dir) {
        var _this = this;
        resolvedPromise.then(function () {
            var /** @type {?} */ container = _this._findContainer(dir.path);
            dir._control = (container.registerControl(dir.name, dir.control));
            setUpControl(dir.control, dir);
            dir.control.updateValueAndValidity({ emitEvent: false });
        });
    };
    /**
     * @param {?} dir
     * @return {?}
     */
    NgForm.prototype.getControl = function (dir) { return (this.form.get(dir.path)); };
    /**
     * @param {?} dir
     * @return {?}
     */
    NgForm.prototype.removeControl = function (dir) {
        var _this = this;
        resolvedPromise.then(function () {
            var /** @type {?} */ container = _this._findContainer(dir.path);
            if (container) {
                container.removeControl(dir.name);
            }
        });
    };
    /**
     * @param {?} dir
     * @return {?}
     */
    NgForm.prototype.addFormGroup = function (dir) {
        var _this = this;
        resolvedPromise.then(function () {
            var /** @type {?} */ container = _this._findContainer(dir.path);
            var /** @type {?} */ group = new FormGroup({});
            setUpFormContainer(group, dir);
            container.registerControl(dir.name, group);
            group.updateValueAndValidity({ emitEvent: false });
        });
    };
    /**
     * @param {?} dir
     * @return {?}
     */
    NgForm.prototype.removeFormGroup = function (dir) {
        var _this = this;
        resolvedPromise.then(function () {
            var /** @type {?} */ container = _this._findContainer(dir.path);
            if (container) {
                container.removeControl(dir.name);
            }
        });
    };
    /**
     * @param {?} dir
     * @return {?}
     */
    NgForm.prototype.getFormGroup = function (dir) { return (this.form.get(dir.path)); };
    /**
     * @param {?} dir
     * @param {?} value
     * @return {?}
     */
    NgForm.prototype.updateModel = function (dir, value) {
        var _this = this;
        resolvedPromise.then(function () {
            var /** @type {?} */ ctrl = (_this.form.get(/** @type {?} */ ((dir.path))));
            ctrl.setValue(value);
        });
    };
    /**
     * @param {?} value
     * @return {?}
     */
    NgForm.prototype.setValue = function (value) { this.control.setValue(value); };
    /**
     * @param {?} $event
     * @return {?}
     */
    NgForm.prototype.onSubmit = function ($event) {
        this._submitted = true;
        this.ngSubmit.emit($event);
        return false;
    };
    /**
     * @return {?}
     */
    NgForm.prototype.onReset = function () { this.resetForm(); };
    /**
     * @param {?=} value
     * @return {?}
     */
    NgForm.prototype.resetForm = function (value) {
        if (value === void 0) { value = undefined; }
        this.form.reset(value);
        this._submitted = false;
    };
    /**
     * \@internal
     * @param {?} path
     * @return {?}
     */
    NgForm.prototype._findContainer = function (path) {
        path.pop();
        return path.length ? (this.form.get(path)) : this.form;
    };
    return NgForm;
}(ControlContainer));
NgForm.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Directive"], args: [{
                selector: 'form:not([ngNoForm]):not([formGroup]),ngForm,[ngForm]',
                providers: [formDirectiveProvider],
                host: { '(submit)': 'onSubmit($event)', '(reset)': 'onReset()' },
                outputs: ['ngSubmit'],
                exportAs: 'ngForm'
            },] },
];
/**
 * @nocollapse
 */
NgForm.ctorParameters = function () { return [
    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Self"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Inject"], args: [NG_VALIDATORS,] },] },
    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Self"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Inject"], args: [NG_ASYNC_VALIDATORS,] },] },
]; };
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var FormErrorExamples = {
    formControlName: "\n    <div [formGroup]=\"myGroup\">\n      <input formControlName=\"firstName\">\n    </div>\n\n    In your class:\n\n    this.myGroup = new FormGroup({\n       firstName: new FormControl()\n    });",
    formGroupName: "\n    <div [formGroup]=\"myGroup\">\n       <div formGroupName=\"person\">\n          <input formControlName=\"firstName\">\n       </div>\n    </div>\n\n    In your class:\n\n    this.myGroup = new FormGroup({\n       person: new FormGroup({ firstName: new FormControl() })\n    });",
    formArrayName: "\n    <div [formGroup]=\"myGroup\">\n      <div formArrayName=\"cities\">\n        <div *ngFor=\"let city of cityArray.controls; index as i\">\n          <input [formControlName]=\"i\">\n        </div>\n      </div>\n    </div>\n\n    In your class:\n\n    this.cityArray = new FormArray([new FormControl('SF')]);\n    this.myGroup = new FormGroup({\n      cities: this.cityArray\n    });",
    ngModelGroup: "\n    <form>\n       <div ngModelGroup=\"person\">\n          <input [(ngModel)]=\"person.name\" name=\"firstName\">\n       </div>\n    </form>",
    ngModelWithFormGroup: "\n    <div [formGroup]=\"myGroup\">\n       <input formControlName=\"firstName\">\n       <input [(ngModel)]=\"showMoreControls\" [ngModelOptions]=\"{standalone: true}\">\n    </div>\n  "
};
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var TemplateDrivenErrors = (function () {
    function TemplateDrivenErrors() {
    }
    /**
     * @return {?}
     */
    TemplateDrivenErrors.modelParentException = function () {
        throw new Error("\n      ngModel cannot be used to register form controls with a parent formGroup directive.  Try using\n      formGroup's partner directive \"formControlName\" instead.  Example:\n\n      " + FormErrorExamples.formControlName + "\n\n      Or, if you'd like to avoid registering this form control, indicate that it's standalone in ngModelOptions:\n\n      Example:\n\n      " + FormErrorExamples.ngModelWithFormGroup);
    };
    /**
     * @return {?}
     */
    TemplateDrivenErrors.formGroupNameException = function () {
        throw new Error("\n      ngModel cannot be used to register form controls with a parent formGroupName or formArrayName directive.\n\n      Option 1: Use formControlName instead of ngModel (reactive strategy):\n\n      " + FormErrorExamples.formGroupName + "\n\n      Option 2:  Update ngModel's parent be ngModelGroup (template-driven strategy):\n\n      " + FormErrorExamples.ngModelGroup);
    };
    /**
     * @return {?}
     */
    TemplateDrivenErrors.missingNameException = function () {
        throw new Error("If ngModel is used within a form tag, either the name attribute must be set or the form\n      control must be defined as 'standalone' in ngModelOptions.\n\n      Example 1: <input [(ngModel)]=\"person.firstName\" name=\"first\">\n      Example 2: <input [(ngModel)]=\"person.firstName\" [ngModelOptions]=\"{standalone: true}\">");
    };
    /**
     * @return {?}
     */
    TemplateDrivenErrors.modelGroupParentException = function () {
        throw new Error("\n      ngModelGroup cannot be used with a parent formGroup directive.\n\n      Option 1: Use formGroupName instead of ngModelGroup (reactive strategy):\n\n      " + FormErrorExamples.formGroupName + "\n\n      Option 2:  Use a regular form tag instead of the formGroup directive (template-driven strategy):\n\n      " + FormErrorExamples.ngModelGroup);
    };
    return TemplateDrivenErrors;
}());
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var modelGroupProvider = {
    provide: ControlContainer,
    useExisting: Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["forwardRef"])(function () { return NgModelGroup; })
};
/**
 * \@whatItDoes Creates and binds a {\@link FormGroup} instance to a DOM element.
 *
 * \@howToUse
 *
 * This directive can only be used as a child of {\@link NgForm} (or in other words,
 * within `<form>` tags).
 *
 * Use this directive if you'd like to create a sub-group within a form. This can
 * come in handy if you want to validate a sub-group of your form separately from
 * the rest of your form, or if some values in your domain model make more sense to
 * consume together in a nested object.
 *
 * Pass in the name you'd like this sub-group to have and it will become the key
 * for the sub-group in the form's full value. You can also export the directive into
 * a local template variable using `ngModelGroup` (ex: `#myGroup="ngModelGroup"`).
 *
 * {\@example forms/ts/ngModelGroup/ng_model_group_example.ts region='Component'}
 *
 * * **npm package**: `\@angular/forms`
 *
 * * **NgModule**: `FormsModule`
 *
 * \@stable
 */
var NgModelGroup = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](NgModelGroup, _super);
    /**
     * @param {?} parent
     * @param {?} validators
     * @param {?} asyncValidators
     */
    function NgModelGroup(parent, validators, asyncValidators) {
        var _this = _super.call(this) || this;
        _this._parent = parent;
        _this._validators = validators;
        _this._asyncValidators = asyncValidators;
        return _this;
    }
    /**
     * \@internal
     * @return {?}
     */
    NgModelGroup.prototype._checkParentType = function () {
        if (!(this._parent instanceof NgModelGroup) && !(this._parent instanceof NgForm)) {
            TemplateDrivenErrors.modelGroupParentException();
        }
    };
    return NgModelGroup;
}(AbstractFormGroupDirective));
NgModelGroup.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Directive"], args: [{ selector: '[ngModelGroup]', providers: [modelGroupProvider], exportAs: 'ngModelGroup' },] },
];
/**
 * @nocollapse
 */
NgModelGroup.ctorParameters = function () { return [
    { type: ControlContainer, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Host"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["SkipSelf"] },] },
    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Self"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Inject"], args: [NG_VALIDATORS,] },] },
    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Self"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Inject"], args: [NG_ASYNC_VALIDATORS,] },] },
]; };
NgModelGroup.propDecorators = {
    'name': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"], args: ['ngModelGroup',] },],
};
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var formControlBinding = {
    provide: NgControl,
    useExisting: Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["forwardRef"])(function () { return NgModel; })
};
/**
 * `ngModel` forces an additional change detection run when its inputs change:
 * E.g.:
 * ```
 * <div>{{myModel.valid}}</div>
 * <input [(ngModel)]="myValue" #myModel="ngModel">
 * ```
 * I.e. `ngModel` can export itself on the element and then be used in the template.
 * Normally, this would result in expressions before the `input` that use the exported directive
 * to have and old value as they have been
 * dirty checked before. As this is a very common case for `ngModel`, we added this second change
 * detection run.
 *
 * Notes:
 * - this is just one extra run no matter how many `ngModel` have been changed.
 * - this is a general problem when using `exportAs` for directives!
 */
var resolvedPromise$1 = Promise.resolve(null);
/**
 * \@whatItDoes Creates a {\@link FormControl} instance from a domain model and binds it
 * to a form control element.
 *
 * The {\@link FormControl} instance will track the value, user interaction, and
 * validation status of the control and keep the view synced with the model. If used
 * within a parent form, the directive will also register itself with the form as a child
 * control.
 *
 * \@howToUse
 *
 * This directive can be used by itself or as part of a larger form. All you need is the
 * `ngModel` selector to activate it.
 *
 * It accepts a domain model as an optional {\@link Input}. If you have a one-way binding
 * to `ngModel` with `[]` syntax, changing the value of the domain model in the component
 * class will set the value in the view. If you have a two-way binding with `[()]` syntax
 * (also known as 'banana-box syntax'), the value in the UI will always be synced back to
 * the domain model in your class as well.
 *
 * If you wish to inspect the properties of the associated {\@link FormControl} (like
 * validity state), you can also export the directive into a local template variable using
 * `ngModel` as the key (ex: `#myVar="ngModel"`). You can then access the control using the
 * directive's `control` property, but most properties you'll need (like `valid` and `dirty`)
 * will fall through to the control anyway, so you can access them directly. You can see a
 * full list of properties directly available in {\@link AbstractControlDirective}.
 *
 * The following is an example of a simple standalone control using `ngModel`:
 *
 * {\@example forms/ts/simpleNgModel/simple_ng_model_example.ts region='Component'}
 *
 * When using the `ngModel` within `<form>` tags, you'll also need to supply a `name` attribute
 * so that the control can be registered with the parent form under that name.
 *
 * It's worth noting that in the context of a parent form, you often can skip one-way or
 * two-way binding because the parent form will sync the value for you. You can access
 * its properties by exporting it into a local template variable using `ngForm` (ex:
 * `#f="ngForm"`). Then you can pass it where it needs to go on submit.
 *
 * If you do need to populate initial values into your form, using a one-way binding for
 * `ngModel` tends to be sufficient as long as you use the exported form's value rather
 * than the domain model's value on submit.
 *
 * Take a look at an example of using `ngModel` within a form:
 *
 * {\@example forms/ts/simpleForm/simple_form_example.ts region='Component'}
 *
 * To see `ngModel` examples with different form control types, see:
 *
 * * Radio buttons: {\@link RadioControlValueAccessor}
 * * Selects: {\@link SelectControlValueAccessor}
 *
 * **npm package**: `\@angular/forms`
 *
 * **NgModule**: `FormsModule`
 *
 *  \@stable
 */
var NgModel = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](NgModel, _super);
    /**
     * @param {?} parent
     * @param {?} validators
     * @param {?} asyncValidators
     * @param {?} valueAccessors
     */
    function NgModel(parent, validators, asyncValidators, valueAccessors) {
        var _this = _super.call(this) || this;
        /**
         * \@internal
         */
        _this._control = new FormControl();
        /**
         * \@internal
         */
        _this._registered = false;
        _this.update = new __WEBPACK_IMPORTED_MODULE_1__angular_core__["EventEmitter"]();
        _this._parent = parent;
        _this._rawValidators = validators || [];
        _this._rawAsyncValidators = asyncValidators || [];
        _this.valueAccessor = selectValueAccessor(_this, valueAccessors);
        return _this;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    NgModel.prototype.ngOnChanges = function (changes) {
        this._checkForErrors();
        if (!this._registered)
            this._setUpControl();
        if ('isDisabled' in changes) {
            this._updateDisabled(changes);
        }
        if (isPropertyUpdated(changes, this.viewModel)) {
            this._updateValue(this.model);
            this.viewModel = this.model;
        }
    };
    /**
     * @return {?}
     */
    NgModel.prototype.ngOnDestroy = function () { this.formDirective && this.formDirective.removeControl(this); };
    Object.defineProperty(NgModel.prototype, "control", {
        /**
         * @return {?}
         */
        get: function () { return this._control; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgModel.prototype, "path", {
        /**
         * @return {?}
         */
        get: function () {
            return this._parent ? controlPath(this.name, this._parent) : [this.name];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgModel.prototype, "formDirective", {
        /**
         * @return {?}
         */
        get: function () { return this._parent ? this._parent.formDirective : null; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgModel.prototype, "validator", {
        /**
         * @return {?}
         */
        get: function () { return composeValidators(this._rawValidators); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgModel.prototype, "asyncValidator", {
        /**
         * @return {?}
         */
        get: function () {
            return composeAsyncValidators(this._rawAsyncValidators);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} newValue
     * @return {?}
     */
    NgModel.prototype.viewToModelUpdate = function (newValue) {
        this.viewModel = newValue;
        this.update.emit(newValue);
    };
    /**
     * @return {?}
     */
    NgModel.prototype._setUpControl = function () {
        this._isStandalone() ? this._setUpStandalone() :
            this.formDirective.addControl(this);
        this._registered = true;
    };
    /**
     * @return {?}
     */
    NgModel.prototype._isStandalone = function () {
        return !this._parent || !!(this.options && this.options.standalone);
    };
    /**
     * @return {?}
     */
    NgModel.prototype._setUpStandalone = function () {
        setUpControl(this._control, this);
        this._control.updateValueAndValidity({ emitEvent: false });
    };
    /**
     * @return {?}
     */
    NgModel.prototype._checkForErrors = function () {
        if (!this._isStandalone()) {
            this._checkParentType();
        }
        this._checkName();
    };
    /**
     * @return {?}
     */
    NgModel.prototype._checkParentType = function () {
        if (!(this._parent instanceof NgModelGroup) &&
            this._parent instanceof AbstractFormGroupDirective) {
            TemplateDrivenErrors.formGroupNameException();
        }
        else if (!(this._parent instanceof NgModelGroup) && !(this._parent instanceof NgForm)) {
            TemplateDrivenErrors.modelParentException();
        }
    };
    /**
     * @return {?}
     */
    NgModel.prototype._checkName = function () {
        if (this.options && this.options.name)
            this.name = this.options.name;
        if (!this._isStandalone() && !this.name) {
            TemplateDrivenErrors.missingNameException();
        }
    };
    /**
     * @param {?} value
     * @return {?}
     */
    NgModel.prototype._updateValue = function (value) {
        var _this = this;
        resolvedPromise$1.then(function () { _this.control.setValue(value, { emitViewToModelChange: false }); });
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    NgModel.prototype._updateDisabled = function (changes) {
        var _this = this;
        var /** @type {?} */ disabledValue = changes['isDisabled'].currentValue;
        var /** @type {?} */ isDisabled = disabledValue === '' || (disabledValue && disabledValue !== 'false');
        resolvedPromise$1.then(function () {
            if (isDisabled && !_this.control.disabled) {
                _this.control.disable();
            }
            else if (!isDisabled && _this.control.disabled) {
                _this.control.enable();
            }
        });
    };
    return NgModel;
}(NgControl));
NgModel.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Directive"], args: [{
                selector: '[ngModel]:not([formControlName]):not([formControl])',
                providers: [formControlBinding],
                exportAs: 'ngModel'
            },] },
];
/**
 * @nocollapse
 */
NgModel.ctorParameters = function () { return [
    { type: ControlContainer, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Host"] },] },
    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Self"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Inject"], args: [NG_VALIDATORS,] },] },
    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Self"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Inject"], args: [NG_ASYNC_VALIDATORS,] },] },
    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Self"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Inject"], args: [NG_VALUE_ACCESSOR,] },] },
]; };
NgModel.propDecorators = {
    'name': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"] },],
    'isDisabled': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"], args: ['disabled',] },],
    'model': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"], args: ['ngModel',] },],
    'options': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"], args: ['ngModelOptions',] },],
    'update': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Output"], args: ['ngModelChange',] },],
};
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var ReactiveErrors = (function () {
    function ReactiveErrors() {
    }
    /**
     * @return {?}
     */
    ReactiveErrors.controlParentException = function () {
        throw new Error("formControlName must be used with a parent formGroup directive.  You'll want to add a formGroup\n       directive and pass it an existing FormGroup instance (you can create one in your class).\n\n      Example:\n\n      " + FormErrorExamples.formControlName);
    };
    /**
     * @return {?}
     */
    ReactiveErrors.ngModelGroupException = function () {
        throw new Error("formControlName cannot be used with an ngModelGroup parent. It is only compatible with parents\n       that also have a \"form\" prefix: formGroupName, formArrayName, or formGroup.\n\n       Option 1:  Update the parent to be formGroupName (reactive form strategy)\n\n        " + FormErrorExamples.formGroupName + "\n\n        Option 2: Use ngModel instead of formControlName (template-driven strategy)\n\n        " + FormErrorExamples.ngModelGroup);
    };
    /**
     * @return {?}
     */
    ReactiveErrors.missingFormException = function () {
        throw new Error("formGroup expects a FormGroup instance. Please pass one in.\n\n       Example:\n\n       " + FormErrorExamples.formControlName);
    };
    /**
     * @return {?}
     */
    ReactiveErrors.groupParentException = function () {
        throw new Error("formGroupName must be used with a parent formGroup directive.  You'll want to add a formGroup\n      directive and pass it an existing FormGroup instance (you can create one in your class).\n\n      Example:\n\n      " + FormErrorExamples.formGroupName);
    };
    /**
     * @return {?}
     */
    ReactiveErrors.arrayParentException = function () {
        throw new Error("formArrayName must be used with a parent formGroup directive.  You'll want to add a formGroup\n       directive and pass it an existing FormGroup instance (you can create one in your class).\n\n        Example:\n\n        " + FormErrorExamples.formArrayName);
    };
    /**
     * @return {?}
     */
    ReactiveErrors.disabledAttrWarning = function () {
        console.warn("\n      It looks like you're using the disabled attribute with a reactive form directive. If you set disabled to true\n      when you set up this control in your component class, the disabled attribute will actually be set in the DOM for\n      you. We recommend using this approach to avoid 'changed after checked' errors.\n       \n      Example: \n      form = new FormGroup({\n        first: new FormControl({value: 'Nancy', disabled: true}, Validators.required),\n        last: new FormControl('Drew', Validators.required)\n      });\n    ");
    };
    return ReactiveErrors;
}());
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var formControlBinding$1 = {
    provide: NgControl,
    useExisting: Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["forwardRef"])(function () { return FormControlDirective; })
};
/**
 * \@whatItDoes Syncs a standalone {\@link FormControl} instance to a form control element.
 *
 * In other words, this directive ensures that any values written to the {\@link FormControl}
 * instance programmatically will be written to the DOM element (model -> view). Conversely,
 * any values written to the DOM element through user input will be reflected in the
 * {\@link FormControl} instance (view -> model).
 *
 * \@howToUse
 *
 * Use this directive if you'd like to create and manage a {\@link FormControl} instance directly.
 * Simply create a {\@link FormControl}, save it to your component class, and pass it into the
 * {\@link FormControlDirective}.
 *
 * This directive is designed to be used as a standalone control.  Unlike {\@link FormControlName},
 * it does not require that your {\@link FormControl} instance be part of any parent
 * {\@link FormGroup}, and it won't be registered to any {\@link FormGroupDirective} that
 * exists above it.
 *
 * **Get the value**: the `value` property is always synced and available on the
 * {\@link FormControl} instance. See a full list of available properties in
 * {\@link AbstractControl}.
 *
 * **Set the value**: You can pass in an initial value when instantiating the {\@link FormControl},
 * or you can set it programmatically later using {\@link AbstractControl#setValue} or
 * {\@link AbstractControl#patchValue}.
 *
 * **Listen to value**: If you want to listen to changes in the value of the control, you can
 * subscribe to the {\@link AbstractControl#valueChanges} event.  You can also listen to
 * {\@link AbstractControl#statusChanges} to be notified when the validation status is
 * re-calculated.
 *
 * ### Example
 *
 * {\@example forms/ts/simpleFormControl/simple_form_control_example.ts region='Component'}
 *
 * * **npm package**: `\@angular/forms`
 *
 * * **NgModule**: `ReactiveFormsModule`
 *
 *  \@stable
 */
var FormControlDirective = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](FormControlDirective, _super);
    /**
     * @param {?} validators
     * @param {?} asyncValidators
     * @param {?} valueAccessors
     */
    function FormControlDirective(validators, asyncValidators, valueAccessors) {
        var _this = _super.call(this) || this;
        _this.update = new __WEBPACK_IMPORTED_MODULE_1__angular_core__["EventEmitter"]();
        _this._rawValidators = validators || [];
        _this._rawAsyncValidators = asyncValidators || [];
        _this.valueAccessor = selectValueAccessor(_this, valueAccessors);
        return _this;
    }
    Object.defineProperty(FormControlDirective.prototype, "isDisabled", {
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        set: function (isDisabled) { ReactiveErrors.disabledAttrWarning(); },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} changes
     * @return {?}
     */
    FormControlDirective.prototype.ngOnChanges = function (changes) {
        if (this._isControlChanged(changes)) {
            setUpControl(this.form, this);
            if (this.control.disabled && ((this.valueAccessor)).setDisabledState) {
                ((((this.valueAccessor)).setDisabledState))(true);
            }
            this.form.updateValueAndValidity({ emitEvent: false });
        }
        if (isPropertyUpdated(changes, this.viewModel)) {
            this.form.setValue(this.model);
            this.viewModel = this.model;
        }
    };
    Object.defineProperty(FormControlDirective.prototype, "path", {
        /**
         * @return {?}
         */
        get: function () { return []; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FormControlDirective.prototype, "validator", {
        /**
         * @return {?}
         */
        get: function () { return composeValidators(this._rawValidators); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FormControlDirective.prototype, "asyncValidator", {
        /**
         * @return {?}
         */
        get: function () {
            return composeAsyncValidators(this._rawAsyncValidators);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FormControlDirective.prototype, "control", {
        /**
         * @return {?}
         */
        get: function () { return this.form; },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} newValue
     * @return {?}
     */
    FormControlDirective.prototype.viewToModelUpdate = function (newValue) {
        this.viewModel = newValue;
        this.update.emit(newValue);
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    FormControlDirective.prototype._isControlChanged = function (changes) {
        return changes.hasOwnProperty('form');
    };
    return FormControlDirective;
}(NgControl));
FormControlDirective.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Directive"], args: [{ selector: '[formControl]', providers: [formControlBinding$1], exportAs: 'ngForm' },] },
];
/**
 * @nocollapse
 */
FormControlDirective.ctorParameters = function () { return [
    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Self"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Inject"], args: [NG_VALIDATORS,] },] },
    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Self"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Inject"], args: [NG_ASYNC_VALIDATORS,] },] },
    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Self"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Inject"], args: [NG_VALUE_ACCESSOR,] },] },
]; };
FormControlDirective.propDecorators = {
    'form': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"], args: ['formControl',] },],
    'model': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"], args: ['ngModel',] },],
    'update': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Output"], args: ['ngModelChange',] },],
    'isDisabled': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"], args: ['disabled',] },],
};
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var formDirectiveProvider$1 = {
    provide: ControlContainer,
    useExisting: Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["forwardRef"])(function () { return FormGroupDirective; })
};
/**
 * \@whatItDoes Binds an existing {\@link FormGroup} to a DOM element.
 *
 * \@howToUse
 *
 * This directive accepts an existing {\@link FormGroup} instance. It will then use this
 * {\@link FormGroup} instance to match any child {\@link FormControl}, {\@link FormGroup},
 * and {\@link FormArray} instances to child {\@link FormControlName}, {\@link FormGroupName},
 * and {\@link FormArrayName} directives.
 *
 * **Set value**: You can set the form's initial value when instantiating the
 * {\@link FormGroup}, or you can set it programmatically later using the {\@link FormGroup}'s
 * {\@link AbstractControl#setValue} or {\@link AbstractControl#patchValue} methods.
 *
 * **Listen to value**: If you want to listen to changes in the value of the form, you can subscribe
 * to the {\@link FormGroup}'s {\@link AbstractControl#valueChanges} event.  You can also listen to
 * its {\@link AbstractControl#statusChanges} event to be notified when the validation status is
 * re-calculated.
 *
 * Furthermore, you can listen to the directive's `ngSubmit` event to be notified when the user has
 * triggered a form submission. The `ngSubmit` event will be emitted with the original form
 * submission event.
 *
 * ### Example
 *
 * In this example, we create form controls for first name and last name.
 *
 * {\@example forms/ts/simpleFormGroup/simple_form_group_example.ts region='Component'}
 *
 * **npm package**: `\@angular/forms`
 *
 * **NgModule**: {\@link ReactiveFormsModule}
 *
 *  \@stable
 */
var FormGroupDirective = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](FormGroupDirective, _super);
    /**
     * @param {?} _validators
     * @param {?} _asyncValidators
     */
    function FormGroupDirective(_validators, _asyncValidators) {
        var _this = _super.call(this) || this;
        _this._validators = _validators;
        _this._asyncValidators = _asyncValidators;
        _this._submitted = false;
        _this.directives = [];
        _this.form = ((null));
        _this.ngSubmit = new __WEBPACK_IMPORTED_MODULE_1__angular_core__["EventEmitter"]();
        return _this;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    FormGroupDirective.prototype.ngOnChanges = function (changes) {
        this._checkFormPresent();
        if (changes.hasOwnProperty('form')) {
            this._updateValidators();
            this._updateDomValue();
            this._updateRegistrations();
        }
    };
    Object.defineProperty(FormGroupDirective.prototype, "submitted", {
        /**
         * @return {?}
         */
        get: function () { return this._submitted; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FormGroupDirective.prototype, "formDirective", {
        /**
         * @return {?}
         */
        get: function () { return this; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FormGroupDirective.prototype, "control", {
        /**
         * @return {?}
         */
        get: function () { return this.form; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FormGroupDirective.prototype, "path", {
        /**
         * @return {?}
         */
        get: function () { return []; },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} dir
     * @return {?}
     */
    FormGroupDirective.prototype.addControl = function (dir) {
        var /** @type {?} */ ctrl = this.form.get(dir.path);
        setUpControl(ctrl, dir);
        ctrl.updateValueAndValidity({ emitEvent: false });
        this.directives.push(dir);
        return ctrl;
    };
    /**
     * @param {?} dir
     * @return {?}
     */
    FormGroupDirective.prototype.getControl = function (dir) { return (this.form.get(dir.path)); };
    /**
     * @param {?} dir
     * @return {?}
     */
    FormGroupDirective.prototype.removeControl = function (dir) { remove(this.directives, dir); };
    /**
     * @param {?} dir
     * @return {?}
     */
    FormGroupDirective.prototype.addFormGroup = function (dir) {
        var /** @type {?} */ ctrl = this.form.get(dir.path);
        setUpFormContainer(ctrl, dir);
        ctrl.updateValueAndValidity({ emitEvent: false });
    };
    /**
     * @param {?} dir
     * @return {?}
     */
    FormGroupDirective.prototype.removeFormGroup = function (dir) { };
    /**
     * @param {?} dir
     * @return {?}
     */
    FormGroupDirective.prototype.getFormGroup = function (dir) { return (this.form.get(dir.path)); };
    /**
     * @param {?} dir
     * @return {?}
     */
    FormGroupDirective.prototype.addFormArray = function (dir) {
        var /** @type {?} */ ctrl = this.form.get(dir.path);
        setUpFormContainer(ctrl, dir);
        ctrl.updateValueAndValidity({ emitEvent: false });
    };
    /**
     * @param {?} dir
     * @return {?}
     */
    FormGroupDirective.prototype.removeFormArray = function (dir) { };
    /**
     * @param {?} dir
     * @return {?}
     */
    FormGroupDirective.prototype.getFormArray = function (dir) { return (this.form.get(dir.path)); };
    /**
     * @param {?} dir
     * @param {?} value
     * @return {?}
     */
    FormGroupDirective.prototype.updateModel = function (dir, value) {
        var /** @type {?} */ ctrl = (this.form.get(dir.path));
        ctrl.setValue(value);
    };
    /**
     * @param {?} $event
     * @return {?}
     */
    FormGroupDirective.prototype.onSubmit = function ($event) {
        this._submitted = true;
        this.ngSubmit.emit($event);
        return false;
    };
    /**
     * @return {?}
     */
    FormGroupDirective.prototype.onReset = function () { this.resetForm(); };
    /**
     * @param {?=} value
     * @return {?}
     */
    FormGroupDirective.prototype.resetForm = function (value) {
        if (value === void 0) { value = undefined; }
        this.form.reset(value);
        this._submitted = false;
    };
    /**
     * \@internal
     * @return {?}
     */
    FormGroupDirective.prototype._updateDomValue = function () {
        var _this = this;
        this.directives.forEach(function (dir) {
            var /** @type {?} */ newCtrl = _this.form.get(dir.path);
            if (dir._control !== newCtrl) {
                cleanUpControl(dir._control, dir);
                if (newCtrl)
                    setUpControl(newCtrl, dir);
                dir._control = newCtrl;
            }
        });
        this.form._updateTreeValidity({ emitEvent: false });
    };
    /**
     * @return {?}
     */
    FormGroupDirective.prototype._updateRegistrations = function () {
        var _this = this;
        this.form._registerOnCollectionChange(function () { return _this._updateDomValue(); });
        if (this._oldForm)
            this._oldForm._registerOnCollectionChange(function () { });
        this._oldForm = this.form;
    };
    /**
     * @return {?}
     */
    FormGroupDirective.prototype._updateValidators = function () {
        var /** @type {?} */ sync = composeValidators(this._validators);
        this.form.validator = Validators.compose([/** @type {?} */ ((this.form.validator)), /** @type {?} */ ((sync))]);
        var /** @type {?} */ async = composeAsyncValidators(this._asyncValidators);
        this.form.asyncValidator = Validators.composeAsync([/** @type {?} */ ((this.form.asyncValidator)), /** @type {?} */ ((async))]);
    };
    /**
     * @return {?}
     */
    FormGroupDirective.prototype._checkFormPresent = function () {
        if (!this.form) {
            ReactiveErrors.missingFormException();
        }
    };
    return FormGroupDirective;
}(ControlContainer));
FormGroupDirective.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Directive"], args: [{
                selector: '[formGroup]',
                providers: [formDirectiveProvider$1],
                host: { '(submit)': 'onSubmit($event)', '(reset)': 'onReset()' },
                exportAs: 'ngForm'
            },] },
];
/**
 * @nocollapse
 */
FormGroupDirective.ctorParameters = function () { return [
    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Self"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Inject"], args: [NG_VALIDATORS,] },] },
    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Self"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Inject"], args: [NG_ASYNC_VALIDATORS,] },] },
]; };
FormGroupDirective.propDecorators = {
    'form': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"], args: ['formGroup',] },],
    'ngSubmit': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Output"] },],
};
/**
 * @template T
 * @param {?} list
 * @param {?} el
 * @return {?}
 */
function remove(list, el) {
    var /** @type {?} */ index = list.indexOf(el);
    if (index > -1) {
        list.splice(index, 1);
    }
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var formGroupNameProvider = {
    provide: ControlContainer,
    useExisting: Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["forwardRef"])(function () { return FormGroupName; })
};
/**
 * \@whatItDoes Syncs a nested {\@link FormGroup} to a DOM element.
 *
 * \@howToUse
 *
 * This directive can only be used with a parent {\@link FormGroupDirective} (selector:
 * `[formGroup]`).
 *
 * It accepts the string name of the nested {\@link FormGroup} you want to link, and
 * will look for a {\@link FormGroup} registered with that name in the parent
 * {\@link FormGroup} instance you passed into {\@link FormGroupDirective}.
 *
 * Nested form groups can come in handy when you want to validate a sub-group of a
 * form separately from the rest or when you'd like to group the values of certain
 * controls into their own nested object.
 *
 * **Access the group**: You can access the associated {\@link FormGroup} using the
 * {\@link AbstractControl#get} method. Ex: `this.form.get('name')`.
 *
 * You can also access individual controls within the group using dot syntax.
 * Ex: `this.form.get('name.first')`
 *
 * **Get the value**: the `value` property is always synced and available on the
 * {\@link FormGroup}. See a full list of available properties in {\@link AbstractControl}.
 *
 * **Set the value**: You can set an initial value for each child control when instantiating
 * the {\@link FormGroup}, or you can set it programmatically later using
 * {\@link AbstractControl#setValue} or {\@link AbstractControl#patchValue}.
 *
 * **Listen to value**: If you want to listen to changes in the value of the group, you can
 * subscribe to the {\@link AbstractControl#valueChanges} event.  You can also listen to
 * {\@link AbstractControl#statusChanges} to be notified when the validation status is
 * re-calculated.
 *
 * ### Example
 *
 * {\@example forms/ts/nestedFormGroup/nested_form_group_example.ts region='Component'}
 *
 * * **npm package**: `\@angular/forms`
 *
 * * **NgModule**: `ReactiveFormsModule`
 *
 * \@stable
 */
var FormGroupName = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](FormGroupName, _super);
    /**
     * @param {?} parent
     * @param {?} validators
     * @param {?} asyncValidators
     */
    function FormGroupName(parent, validators, asyncValidators) {
        var _this = _super.call(this) || this;
        _this._parent = parent;
        _this._validators = validators;
        _this._asyncValidators = asyncValidators;
        return _this;
    }
    /**
     * \@internal
     * @return {?}
     */
    FormGroupName.prototype._checkParentType = function () {
        if (_hasInvalidParent(this._parent)) {
            ReactiveErrors.groupParentException();
        }
    };
    return FormGroupName;
}(AbstractFormGroupDirective));
FormGroupName.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Directive"], args: [{ selector: '[formGroupName]', providers: [formGroupNameProvider] },] },
];
/**
 * @nocollapse
 */
FormGroupName.ctorParameters = function () { return [
    { type: ControlContainer, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Host"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["SkipSelf"] },] },
    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Self"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Inject"], args: [NG_VALIDATORS,] },] },
    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Self"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Inject"], args: [NG_ASYNC_VALIDATORS,] },] },
]; };
FormGroupName.propDecorators = {
    'name': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"], args: ['formGroupName',] },],
};
var formArrayNameProvider = {
    provide: ControlContainer,
    useExisting: Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["forwardRef"])(function () { return FormArrayName; })
};
/**
 * \@whatItDoes Syncs a nested {\@link FormArray} to a DOM element.
 *
 * \@howToUse
 *
 * This directive is designed to be used with a parent {\@link FormGroupDirective} (selector:
 * `[formGroup]`).
 *
 * It accepts the string name of the nested {\@link FormArray} you want to link, and
 * will look for a {\@link FormArray} registered with that name in the parent
 * {\@link FormGroup} instance you passed into {\@link FormGroupDirective}.
 *
 * Nested form arrays can come in handy when you have a group of form controls but
 * you're not sure how many there will be. Form arrays allow you to create new
 * form controls dynamically.
 *
 * **Access the array**: You can access the associated {\@link FormArray} using the
 * {\@link AbstractControl#get} method on the parent {\@link FormGroup}.
 * Ex: `this.form.get('cities')`.
 *
 * **Get the value**: the `value` property is always synced and available on the
 * {\@link FormArray}. See a full list of available properties in {\@link AbstractControl}.
 *
 * **Set the value**: You can set an initial value for each child control when instantiating
 * the {\@link FormArray}, or you can set the value programmatically later using the
 * {\@link FormArray}'s {\@link AbstractControl#setValue} or {\@link AbstractControl#patchValue}
 * methods.
 *
 * **Listen to value**: If you want to listen to changes in the value of the array, you can
 * subscribe to the {\@link FormArray}'s {\@link AbstractControl#valueChanges} event.  You can also
 * listen to its {\@link AbstractControl#statusChanges} event to be notified when the validation
 * status is re-calculated.
 *
 * **Add new controls**: You can add new controls to the {\@link FormArray} dynamically by
 * calling its {\@link FormArray#push} method.
 *  Ex: `this.form.get('cities').push(new FormControl());`
 *
 * ### Example
 *
 * {\@example forms/ts/nestedFormArray/nested_form_array_example.ts region='Component'}
 *
 * * **npm package**: `\@angular/forms`
 *
 * * **NgModule**: `ReactiveFormsModule`
 *
 * \@stable
 */
var FormArrayName = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](FormArrayName, _super);
    /**
     * @param {?} parent
     * @param {?} validators
     * @param {?} asyncValidators
     */
    function FormArrayName(parent, validators, asyncValidators) {
        var _this = _super.call(this) || this;
        _this._parent = parent;
        _this._validators = validators;
        _this._asyncValidators = asyncValidators;
        return _this;
    }
    /**
     * @return {?}
     */
    FormArrayName.prototype.ngOnInit = function () {
        this._checkParentType(); /** @type {?} */
        ((this.formDirective)).addFormArray(this);
    };
    /**
     * @return {?}
     */
    FormArrayName.prototype.ngOnDestroy = function () {
        if (this.formDirective) {
            this.formDirective.removeFormArray(this);
        }
    };
    Object.defineProperty(FormArrayName.prototype, "control", {
        /**
         * @return {?}
         */
        get: function () { return ((this.formDirective)).getFormArray(this); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FormArrayName.prototype, "formDirective", {
        /**
         * @return {?}
         */
        get: function () {
            return this._parent ? (this._parent.formDirective) : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FormArrayName.prototype, "path", {
        /**
         * @return {?}
         */
        get: function () { return controlPath(this.name, this._parent); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FormArrayName.prototype, "validator", {
        /**
         * @return {?}
         */
        get: function () { return composeValidators(this._validators); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FormArrayName.prototype, "asyncValidator", {
        /**
         * @return {?}
         */
        get: function () {
            return composeAsyncValidators(this._asyncValidators);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    FormArrayName.prototype._checkParentType = function () {
        if (_hasInvalidParent(this._parent)) {
            ReactiveErrors.arrayParentException();
        }
    };
    return FormArrayName;
}(ControlContainer));
FormArrayName.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Directive"], args: [{ selector: '[formArrayName]', providers: [formArrayNameProvider] },] },
];
/**
 * @nocollapse
 */
FormArrayName.ctorParameters = function () { return [
    { type: ControlContainer, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Host"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["SkipSelf"] },] },
    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Self"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Inject"], args: [NG_VALIDATORS,] },] },
    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Self"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Inject"], args: [NG_ASYNC_VALIDATORS,] },] },
]; };
FormArrayName.propDecorators = {
    'name': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"], args: ['formArrayName',] },],
};
/**
 * @param {?} parent
 * @return {?}
 */
function _hasInvalidParent(parent) {
    return !(parent instanceof FormGroupName) && !(parent instanceof FormGroupDirective) &&
        !(parent instanceof FormArrayName);
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var controlNameBinding = {
    provide: NgControl,
    useExisting: Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["forwardRef"])(function () { return FormControlName; })
};
/**
 * \@whatItDoes Syncs a {\@link FormControl} in an existing {\@link FormGroup} to a form control
 * element by name.
 *
 * In other words, this directive ensures that any values written to the {\@link FormControl}
 * instance programmatically will be written to the DOM element (model -> view). Conversely,
 * any values written to the DOM element through user input will be reflected in the
 * {\@link FormControl} instance (view -> model).
 *
 * \@howToUse
 *
 * This directive is designed to be used with a parent {\@link FormGroupDirective} (selector:
 * `[formGroup]`).
 *
 * It accepts the string name of the {\@link FormControl} instance you want to
 * link, and will look for a {\@link FormControl} registered with that name in the
 * closest {\@link FormGroup} or {\@link FormArray} above it.
 *
 * **Access the control**: You can access the {\@link FormControl} associated with
 * this directive by using the {\@link AbstractControl#get} method.
 * Ex: `this.form.get('first');`
 *
 * **Get value**: the `value` property is always synced and available on the {\@link FormControl}.
 * See a full list of available properties in {\@link AbstractControl}.
 *
 *  **Set value**: You can set an initial value for the control when instantiating the
 *  {\@link FormControl}, or you can set it programmatically later using
 *  {\@link AbstractControl#setValue} or {\@link AbstractControl#patchValue}.
 *
 * **Listen to value**: If you want to listen to changes in the value of the control, you can
 * subscribe to the {\@link AbstractControl#valueChanges} event.  You can also listen to
 * {\@link AbstractControl#statusChanges} to be notified when the validation status is
 * re-calculated.
 *
 * ### Example
 *
 * In this example, we create form controls for first name and last name.
 *
 * {\@example forms/ts/simpleFormGroup/simple_form_group_example.ts region='Component'}
 *
 * To see `formControlName` examples with different form control types, see:
 *
 * * Radio buttons: {\@link RadioControlValueAccessor}
 * * Selects: {\@link SelectControlValueAccessor}
 *
 * **npm package**: `\@angular/forms`
 *
 * **NgModule**: {\@link ReactiveFormsModule}
 *
 *  \@stable
 */
var FormControlName = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](FormControlName, _super);
    /**
     * @param {?} parent
     * @param {?} validators
     * @param {?} asyncValidators
     * @param {?} valueAccessors
     */
    function FormControlName(parent, validators, asyncValidators, valueAccessors) {
        var _this = _super.call(this) || this;
        _this._added = false;
        _this.update = new __WEBPACK_IMPORTED_MODULE_1__angular_core__["EventEmitter"]();
        _this._parent = parent;
        _this._rawValidators = validators || [];
        _this._rawAsyncValidators = asyncValidators || [];
        _this.valueAccessor = selectValueAccessor(_this, valueAccessors);
        return _this;
    }
    Object.defineProperty(FormControlName.prototype, "isDisabled", {
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        set: function (isDisabled) { ReactiveErrors.disabledAttrWarning(); },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} changes
     * @return {?}
     */
    FormControlName.prototype.ngOnChanges = function (changes) {
        if (!this._added)
            this._setUpControl();
        if (isPropertyUpdated(changes, this.viewModel)) {
            this.viewModel = this.model;
            this.formDirective.updateModel(this, this.model);
        }
    };
    /**
     * @return {?}
     */
    FormControlName.prototype.ngOnDestroy = function () {
        if (this.formDirective) {
            this.formDirective.removeControl(this);
        }
    };
    /**
     * @param {?} newValue
     * @return {?}
     */
    FormControlName.prototype.viewToModelUpdate = function (newValue) {
        this.viewModel = newValue;
        this.update.emit(newValue);
    };
    Object.defineProperty(FormControlName.prototype, "path", {
        /**
         * @return {?}
         */
        get: function () { return controlPath(this.name, /** @type {?} */ ((this._parent))); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FormControlName.prototype, "formDirective", {
        /**
         * @return {?}
         */
        get: function () { return this._parent ? this._parent.formDirective : null; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FormControlName.prototype, "validator", {
        /**
         * @return {?}
         */
        get: function () { return composeValidators(this._rawValidators); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FormControlName.prototype, "asyncValidator", {
        /**
         * @return {?}
         */
        get: function () {
            return ((composeAsyncValidators(this._rawAsyncValidators)));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FormControlName.prototype, "control", {
        /**
         * @return {?}
         */
        get: function () { return this._control; },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    FormControlName.prototype._checkParentType = function () {
        if (!(this._parent instanceof FormGroupName) &&
            this._parent instanceof AbstractFormGroupDirective) {
            ReactiveErrors.ngModelGroupException();
        }
        else if (!(this._parent instanceof FormGroupName) && !(this._parent instanceof FormGroupDirective) &&
            !(this._parent instanceof FormArrayName)) {
            ReactiveErrors.controlParentException();
        }
    };
    /**
     * @return {?}
     */
    FormControlName.prototype._setUpControl = function () {
        this._checkParentType();
        this._control = this.formDirective.addControl(this);
        if (this.control.disabled && ((this.valueAccessor)).setDisabledState) {
            ((((this.valueAccessor)).setDisabledState))(true);
        }
        this._added = true;
    };
    return FormControlName;
}(NgControl));
FormControlName.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Directive"], args: [{ selector: '[formControlName]', providers: [controlNameBinding] },] },
];
/**
 * @nocollapse
 */
FormControlName.ctorParameters = function () { return [
    { type: ControlContainer, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Host"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["SkipSelf"] },] },
    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Self"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Inject"], args: [NG_VALIDATORS,] },] },
    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Self"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Inject"], args: [NG_ASYNC_VALIDATORS,] },] },
    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Self"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Inject"], args: [NG_VALUE_ACCESSOR,] },] },
]; };
FormControlName.propDecorators = {
    'name': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"], args: ['formControlName',] },],
    'model': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"], args: ['ngModel',] },],
    'update': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Output"], args: ['ngModelChange',] },],
    'isDisabled': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"], args: ['disabled',] },],
};
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var REQUIRED_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["forwardRef"])(function () { return RequiredValidator; }),
    multi: true
};
var CHECKBOX_REQUIRED_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["forwardRef"])(function () { return CheckboxRequiredValidator; }),
    multi: true
};
/**
 * A Directive that adds the `required` validator to any controls marked with the
 * `required` attribute, via the {\@link NG_VALIDATORS} binding.
 *
 * ### Example
 *
 * ```
 * <input name="fullName" ngModel required>
 * ```
 *
 * \@stable
 */
var RequiredValidator = (function () {
    function RequiredValidator() {
    }
    Object.defineProperty(RequiredValidator.prototype, "required", {
        /**
         * @return {?}
         */
        get: function () { return this._required; },
        /**
         * @param {?} value
         * @return {?}
         */
        set: function (value) {
            this._required = value != null && value !== false && "" + value !== 'false';
            if (this._onChange)
                this._onChange();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} c
     * @return {?}
     */
    RequiredValidator.prototype.validate = function (c) {
        return this.required ? Validators.required(c) : null;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    RequiredValidator.prototype.registerOnValidatorChange = function (fn) { this._onChange = fn; };
    return RequiredValidator;
}());
RequiredValidator.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Directive"], args: [{
                selector: ':not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]',
                providers: [REQUIRED_VALIDATOR],
                host: { '[attr.required]': 'required ? "" : null' }
            },] },
];
/**
 * @nocollapse
 */
RequiredValidator.ctorParameters = function () { return []; };
RequiredValidator.propDecorators = {
    'required': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"] },],
};
/**
 * A Directive that adds the `required` validator to checkbox controls marked with the
 * `required` attribute, via the {\@link NG_VALIDATORS} binding.
 *
 * ### Example
 *
 * ```
 * <input type="checkbox" name="active" ngModel required>
 * ```
 *
 * \@experimental
 */
var CheckboxRequiredValidator = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](CheckboxRequiredValidator, _super);
    function CheckboxRequiredValidator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @param {?} c
     * @return {?}
     */
    CheckboxRequiredValidator.prototype.validate = function (c) {
        return this.required ? Validators.requiredTrue(c) : null;
    };
    return CheckboxRequiredValidator;
}(RequiredValidator));
CheckboxRequiredValidator.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Directive"], args: [{
                selector: 'input[type=checkbox][required][formControlName],input[type=checkbox][required][formControl],input[type=checkbox][required][ngModel]',
                providers: [CHECKBOX_REQUIRED_VALIDATOR],
                host: { '[attr.required]': 'required ? "" : null' }
            },] },
];
/**
 * @nocollapse
 */
CheckboxRequiredValidator.ctorParameters = function () { return []; };
/**
 * Provider which adds {\@link EmailValidator} to {\@link NG_VALIDATORS}.
 */
var EMAIL_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["forwardRef"])(function () { return EmailValidator; }),
    multi: true
};
/**
 * A Directive that adds the `email` validator to controls marked with the
 * `email` attribute, via the {\@link NG_VALIDATORS} binding.
 *
 * ### Example
 *
 * ```
 * <input type="email" name="email" ngModel email>
 * <input type="email" name="email" ngModel email="true">
 * <input type="email" name="email" ngModel [email]="true">
 * ```
 *
 * \@experimental
 */
var EmailValidator = (function () {
    function EmailValidator() {
    }
    Object.defineProperty(EmailValidator.prototype, "email", {
        /**
         * @param {?} value
         * @return {?}
         */
        set: function (value) {
            this._enabled = value === '' || value === true || value === 'true';
            if (this._onChange)
                this._onChange();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} c
     * @return {?}
     */
    EmailValidator.prototype.validate = function (c) {
        return this._enabled ? Validators.email(c) : null;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    EmailValidator.prototype.registerOnValidatorChange = function (fn) { this._onChange = fn; };
    return EmailValidator;
}());
EmailValidator.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Directive"], args: [{
                selector: '[email][formControlName],[email][formControl],[email][ngModel]',
                providers: [EMAIL_VALIDATOR]
            },] },
];
/**
 * @nocollapse
 */
EmailValidator.ctorParameters = function () { return []; };
EmailValidator.propDecorators = {
    'email': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"] },],
};
/**
 * Provider which adds {\@link MinLengthValidator} to {\@link NG_VALIDATORS}.
 *
 * ## Example:
 *
 * {\@example common/forms/ts/validators/validators.ts region='min'}
 */
var MIN_LENGTH_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["forwardRef"])(function () { return MinLengthValidator; }),
    multi: true
};
/**
 * A directive which installs the {\@link MinLengthValidator} for any `formControlName`,
 * `formControl`, or control with `ngModel` that also has a `minlength` attribute.
 *
 * \@stable
 */
var MinLengthValidator = (function () {
    function MinLengthValidator() {
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    MinLengthValidator.prototype.ngOnChanges = function (changes) {
        if ('minlength' in changes) {
            this._createValidator();
            if (this._onChange)
                this._onChange();
        }
    };
    /**
     * @param {?} c
     * @return {?}
     */
    MinLengthValidator.prototype.validate = function (c) {
        return this.minlength == null ? null : this._validator(c);
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    MinLengthValidator.prototype.registerOnValidatorChange = function (fn) { this._onChange = fn; };
    /**
     * @return {?}
     */
    MinLengthValidator.prototype._createValidator = function () {
        this._validator = Validators.minLength(parseInt(this.minlength, 10));
    };
    return MinLengthValidator;
}());
MinLengthValidator.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Directive"], args: [{
                selector: '[minlength][formControlName],[minlength][formControl],[minlength][ngModel]',
                providers: [MIN_LENGTH_VALIDATOR],
                host: { '[attr.minlength]': 'minlength ? minlength : null' }
            },] },
];
/**
 * @nocollapse
 */
MinLengthValidator.ctorParameters = function () { return []; };
MinLengthValidator.propDecorators = {
    'minlength': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"] },],
};
/**
 * Provider which adds {\@link MaxLengthValidator} to {\@link NG_VALIDATORS}.
 *
 * ## Example:
 *
 * {\@example common/forms/ts/validators/validators.ts region='max'}
 */
var MAX_LENGTH_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["forwardRef"])(function () { return MaxLengthValidator; }),
    multi: true
};
/**
 * A directive which installs the {\@link MaxLengthValidator} for any `formControlName,
 * `formControl`,
 * or control with `ngModel` that also has a `maxlength` attribute.
 *
 * \@stable
 */
var MaxLengthValidator = (function () {
    function MaxLengthValidator() {
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    MaxLengthValidator.prototype.ngOnChanges = function (changes) {
        if ('maxlength' in changes) {
            this._createValidator();
            if (this._onChange)
                this._onChange();
        }
    };
    /**
     * @param {?} c
     * @return {?}
     */
    MaxLengthValidator.prototype.validate = function (c) {
        return this.maxlength != null ? this._validator(c) : null;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    MaxLengthValidator.prototype.registerOnValidatorChange = function (fn) { this._onChange = fn; };
    /**
     * @return {?}
     */
    MaxLengthValidator.prototype._createValidator = function () {
        this._validator = Validators.maxLength(parseInt(this.maxlength, 10));
    };
    return MaxLengthValidator;
}());
MaxLengthValidator.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Directive"], args: [{
                selector: '[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]',
                providers: [MAX_LENGTH_VALIDATOR],
                host: { '[attr.maxlength]': 'maxlength ? maxlength : null' }
            },] },
];
/**
 * @nocollapse
 */
MaxLengthValidator.ctorParameters = function () { return []; };
MaxLengthValidator.propDecorators = {
    'maxlength': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"] },],
};
var PATTERN_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["forwardRef"])(function () { return PatternValidator; }),
    multi: true
};
/**
 * A Directive that adds the `pattern` validator to any controls marked with the
 * `pattern` attribute, via the {\@link NG_VALIDATORS} binding. Uses attribute value
 * as the regex to validate Control value against.  Follows pattern attribute
 * semantics; i.e. regex must match entire Control value.
 *
 * ### Example
 *
 * ```
 * <input [name]="fullName" pattern="[a-zA-Z ]*" ngModel>
 * ```
 * \@stable
 */
var PatternValidator = (function () {
    function PatternValidator() {
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    PatternValidator.prototype.ngOnChanges = function (changes) {
        if ('pattern' in changes) {
            this._createValidator();
            if (this._onChange)
                this._onChange();
        }
    };
    /**
     * @param {?} c
     * @return {?}
     */
    PatternValidator.prototype.validate = function (c) { return this._validator(c); };
    /**
     * @param {?} fn
     * @return {?}
     */
    PatternValidator.prototype.registerOnValidatorChange = function (fn) { this._onChange = fn; };
    /**
     * @return {?}
     */
    PatternValidator.prototype._createValidator = function () { this._validator = Validators.pattern(this.pattern); };
    return PatternValidator;
}());
PatternValidator.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Directive"], args: [{
                selector: '[pattern][formControlName],[pattern][formControl],[pattern][ngModel]',
                providers: [PATTERN_VALIDATOR],
                host: { '[attr.pattern]': 'pattern ? pattern : null' }
            },] },
];
/**
 * @nocollapse
 */
PatternValidator.ctorParameters = function () { return []; };
PatternValidator.propDecorators = {
    'pattern': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"] },],
};
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * \@whatItDoes Creates an {\@link AbstractControl} from a user-specified configuration.
 *
 * It is essentially syntactic sugar that shortens the `new FormGroup()`,
 * `new FormControl()`, and `new FormArray()` boilerplate that can build up in larger
 * forms.
 *
 * \@howToUse
 *
 * To use, inject `FormBuilder` into your component class. You can then call its methods
 * directly.
 *
 * {\@example forms/ts/formBuilder/form_builder_example.ts region='Component'}
 *
 *  * **npm package**: `\@angular/forms`
 *
 *  * **NgModule**: {\@link ReactiveFormsModule}
 *
 * \@stable
 */
var FormBuilder = (function () {
    function FormBuilder() {
    }
    /**
     * Construct a new {\@link FormGroup} with the given map of configuration.
     * Valid keys for the `extra` parameter map are `validator` and `asyncValidator`.
     *
     * See the {\@link FormGroup} constructor for more details.
     * @param {?} controlsConfig
     * @param {?=} extra
     * @return {?}
     */
    FormBuilder.prototype.group = function (controlsConfig, extra) {
        if (extra === void 0) { extra = null; }
        var /** @type {?} */ controls = this._reduceControls(controlsConfig);
        var /** @type {?} */ validator = extra != null ? extra['validator'] : null;
        var /** @type {?} */ asyncValidator = extra != null ? extra['asyncValidator'] : null;
        return new FormGroup(controls, validator, asyncValidator);
    };
    /**
     * Construct a new {\@link FormControl} with the given `formState`,`validator`, and
     * `asyncValidator`.
     *
     * `formState` can either be a standalone value for the form control or an object
     * that contains both a value and a disabled status.
     *
     * @param {?} formState
     * @param {?=} validator
     * @param {?=} asyncValidator
     * @return {?}
     */
    FormBuilder.prototype.control = function (formState, validator, asyncValidator) {
        return new FormControl(formState, validator, asyncValidator);
    };
    /**
     * Construct a {\@link FormArray} from the given `controlsConfig` array of
     * configuration, with the given optional `validator` and `asyncValidator`.
     * @param {?} controlsConfig
     * @param {?=} validator
     * @param {?=} asyncValidator
     * @return {?}
     */
    FormBuilder.prototype.array = function (controlsConfig, validator, asyncValidator) {
        var _this = this;
        var /** @type {?} */ controls = controlsConfig.map(function (c) { return _this._createControl(c); });
        return new FormArray(controls, validator, asyncValidator);
    };
    /**
     * \@internal
     * @param {?} controlsConfig
     * @return {?}
     */
    FormBuilder.prototype._reduceControls = function (controlsConfig) {
        var _this = this;
        var /** @type {?} */ controls = {};
        Object.keys(controlsConfig).forEach(function (controlName) {
            controls[controlName] = _this._createControl(controlsConfig[controlName]);
        });
        return controls;
    };
    /**
     * \@internal
     * @param {?} controlConfig
     * @return {?}
     */
    FormBuilder.prototype._createControl = function (controlConfig) {
        if (controlConfig instanceof FormControl || controlConfig instanceof FormGroup ||
            controlConfig instanceof FormArray) {
            return controlConfig;
        }
        else if (Array.isArray(controlConfig)) {
            var /** @type {?} */ value = controlConfig[0];
            var /** @type {?} */ validator = controlConfig.length > 1 ? controlConfig[1] : null;
            var /** @type {?} */ asyncValidator = controlConfig.length > 2 ? controlConfig[2] : null;
            return this.control(value, validator, asyncValidator);
        }
        else {
            return this.control(controlConfig);
        }
    };
    return FormBuilder;
}());
FormBuilder.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"] },
];
/**
 * @nocollapse
 */
FormBuilder.ctorParameters = function () { return []; };
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @module
 * @description
 * Entry point for all public APIs of the common package.
 */
/**
 * \@stable
 */
var VERSION = new __WEBPACK_IMPORTED_MODULE_1__angular_core__["Version"]('4.3.5');
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * \@whatItDoes Adds `novalidate` attribute to all forms by default.
 *
 * `novalidate` is used to disable browser's native form validation.
 *
 * If you want to use native validation with Angular forms, just add `ngNativeValidate` attribute:
 *
 * ```
 * <form ngNativeValidate></form>
 * ```
 *
 * \@experimental
 */
var NgNoValidate = (function () {
    function NgNoValidate() {
    }
    return NgNoValidate;
}());
NgNoValidate.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Directive"], args: [{
                selector: 'form:not([ngNoForm]):not([ngNativeValidate])',
                host: { 'novalidate': '' },
            },] },
];
/**
 * @nocollapse
 */
NgNoValidate.ctorParameters = function () { return []; };
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var SHARED_FORM_DIRECTIVES = [
    NgNoValidate,
    NgSelectOption,
    NgSelectMultipleOption,
    DefaultValueAccessor,
    NumberValueAccessor,
    RangeValueAccessor,
    CheckboxControlValueAccessor,
    SelectControlValueAccessor,
    SelectMultipleControlValueAccessor,
    RadioControlValueAccessor,
    NgControlStatus,
    NgControlStatusGroup,
    RequiredValidator,
    MinLengthValidator,
    MaxLengthValidator,
    PatternValidator,
    CheckboxRequiredValidator,
    EmailValidator,
];
var TEMPLATE_DRIVEN_DIRECTIVES = [NgModel, NgModelGroup, NgForm];
var REACTIVE_DRIVEN_DIRECTIVES = [FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName];
/**
 * Internal module used for sharing directives between FormsModule and ReactiveFormsModule
 */
var InternalFormsSharedModule = (function () {
    function InternalFormsSharedModule() {
    }
    return InternalFormsSharedModule;
}());
InternalFormsSharedModule.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["NgModule"], args: [{
                declarations: SHARED_FORM_DIRECTIVES,
                exports: SHARED_FORM_DIRECTIVES,
            },] },
];
/**
 * @nocollapse
 */
InternalFormsSharedModule.ctorParameters = function () { return []; };
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * The ng module for forms.
 * \@stable
 */
var FormsModule = (function () {
    function FormsModule() {
    }
    return FormsModule;
}());
FormsModule.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["NgModule"], args: [{
                declarations: TEMPLATE_DRIVEN_DIRECTIVES,
                providers: [RadioControlRegistry],
                exports: [InternalFormsSharedModule, TEMPLATE_DRIVEN_DIRECTIVES]
            },] },
];
/**
 * @nocollapse
 */
FormsModule.ctorParameters = function () { return []; };
/**
 * The ng module for reactive forms.
 * \@stable
 */
var ReactiveFormsModule = (function () {
    function ReactiveFormsModule() {
    }
    return ReactiveFormsModule;
}());
ReactiveFormsModule.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["NgModule"], args: [{
                declarations: [REACTIVE_DRIVEN_DIRECTIVES],
                providers: [FormBuilder, RadioControlRegistry],
                exports: [InternalFormsSharedModule, REACTIVE_DRIVEN_DIRECTIVES]
            },] },
];
/**
 * @nocollapse
 */
ReactiveFormsModule.ctorParameters = function () { return []; };
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @module
 * @description
 * This module is used for handling user input, by defining and building a {@link FormGroup} that
 * consists of {@link FormControl} objects, and mapping them onto the DOM. {@link FormControl}
 * objects can then be used to read information from the form DOM elements.
 *
 * Forms providers are not included in default providers; you must import these providers
 * explicitly.
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @module
 * @description
 * Entry point for all public APIs of the forms package.
 */
// This file only reexports content of the `src` folder. Keep it that way.
/**
 * Generated bundle index. Do not edit.
 */

//# sourceMappingURL=forms.es5.js.map


/***/ }),

/***/ "../../../http/@angular/http.es5.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return BrowserXhr; });
/* unused harmony export JSONPBackend */
/* unused harmony export JSONPConnection */
/* unused harmony export CookieXSRFStrategy */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return XHRBackend; });
/* unused harmony export XHRConnection */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BaseRequestOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return RequestOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return BaseResponseOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return ResponseOptions; });
/* unused harmony export ReadyState */
/* unused harmony export RequestMethod */
/* unused harmony export ResponseContentType */
/* unused harmony export ResponseType */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return Headers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return Http; });
/* unused harmony export Jsonp */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return HttpModule; });
/* unused harmony export JsonpModule */
/* unused harmony export Connection */
/* unused harmony export ConnectionBackend */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return XSRFStrategy; });
/* unused harmony export Request */
/* unused harmony export Response */
/* unused harmony export QueryEncoder */
/* unused harmony export URLSearchParams */
/* unused harmony export VERSION */
/* unused harmony export ɵg */
/* unused harmony export ɵa */
/* unused harmony export ɵf */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return _createDefaultCookieXSRFStrategy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return httpFactory; });
/* unused harmony export ɵd */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__("../../../../tslib/tslib.es6.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__("../../../core/@angular/core.es5.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs_Observable__ = __webpack_require__("../../../../rxjs/Observable.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_rxjs_Observable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__angular_platform_browser__ = __webpack_require__("../../../platform-browser/@angular/platform-browser.es5.js");

/**
 * @license Angular v4.3.5
 * (c) 2010-2017 Google, Inc. https://angular.io/
 * License: MIT
 */



/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * A backend for http that uses the `XMLHttpRequest` browser API.
 *
 * Take care not to evaluate this in non-browser contexts.
 *
 * \@experimental
 */
var BrowserXhr = (function () {
    function BrowserXhr() {
    }
    /**
     * @return {?}
     */
    BrowserXhr.prototype.build = function () { return ((new XMLHttpRequest())); };
    return BrowserXhr;
}());
BrowserXhr.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"] },
];
/**
 * @nocollapse
 */
BrowserXhr.ctorParameters = function () { return []; };
var RequestMethod = {};
RequestMethod.Get = 0;
RequestMethod.Post = 1;
RequestMethod.Put = 2;
RequestMethod.Delete = 3;
RequestMethod.Options = 4;
RequestMethod.Head = 5;
RequestMethod.Patch = 6;
RequestMethod[RequestMethod.Get] = "Get";
RequestMethod[RequestMethod.Post] = "Post";
RequestMethod[RequestMethod.Put] = "Put";
RequestMethod[RequestMethod.Delete] = "Delete";
RequestMethod[RequestMethod.Options] = "Options";
RequestMethod[RequestMethod.Head] = "Head";
RequestMethod[RequestMethod.Patch] = "Patch";
var ReadyState = {};
ReadyState.Unsent = 0;
ReadyState.Open = 1;
ReadyState.HeadersReceived = 2;
ReadyState.Loading = 3;
ReadyState.Done = 4;
ReadyState.Cancelled = 5;
ReadyState[ReadyState.Unsent] = "Unsent";
ReadyState[ReadyState.Open] = "Open";
ReadyState[ReadyState.HeadersReceived] = "HeadersReceived";
ReadyState[ReadyState.Loading] = "Loading";
ReadyState[ReadyState.Done] = "Done";
ReadyState[ReadyState.Cancelled] = "Cancelled";
var ResponseType = {};
ResponseType.Basic = 0;
ResponseType.Cors = 1;
ResponseType.Default = 2;
ResponseType.Error = 3;
ResponseType.Opaque = 4;
ResponseType[ResponseType.Basic] = "Basic";
ResponseType[ResponseType.Cors] = "Cors";
ResponseType[ResponseType.Default] = "Default";
ResponseType[ResponseType.Error] = "Error";
ResponseType[ResponseType.Opaque] = "Opaque";
var ContentType = {};
ContentType.NONE = 0;
ContentType.JSON = 1;
ContentType.FORM = 2;
ContentType.FORM_DATA = 3;
ContentType.TEXT = 4;
ContentType.BLOB = 5;
ContentType.ARRAY_BUFFER = 6;
ContentType[ContentType.NONE] = "NONE";
ContentType[ContentType.JSON] = "JSON";
ContentType[ContentType.FORM] = "FORM";
ContentType[ContentType.FORM_DATA] = "FORM_DATA";
ContentType[ContentType.TEXT] = "TEXT";
ContentType[ContentType.BLOB] = "BLOB";
ContentType[ContentType.ARRAY_BUFFER] = "ARRAY_BUFFER";
var ResponseContentType = {};
ResponseContentType.Text = 0;
ResponseContentType.Json = 1;
ResponseContentType.ArrayBuffer = 2;
ResponseContentType.Blob = 3;
ResponseContentType[ResponseContentType.Text] = "Text";
ResponseContentType[ResponseContentType.Json] = "Json";
ResponseContentType[ResponseContentType.ArrayBuffer] = "ArrayBuffer";
ResponseContentType[ResponseContentType.Blob] = "Blob";
/**
 * Polyfill for [Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers/Headers), as
 * specified in the [Fetch Spec](https://fetch.spec.whatwg.org/#headers-class).
 *
 * The only known difference between this `Headers` implementation and the spec is the
 * lack of an `entries` method.
 *
 * ### Example
 *
 * ```
 * import {Headers} from '\@angular/http';
 *
 * var firstHeaders = new Headers();
 * firstHeaders.append('Content-Type', 'image/jpeg');
 * console.log(firstHeaders.get('Content-Type')) //'image/jpeg'
 *
 * // Create headers from Plain Old JavaScript Object
 * var secondHeaders = new Headers({
 *   'X-My-Custom-Header': 'Angular'
 * });
 * console.log(secondHeaders.get('X-My-Custom-Header')); //'Angular'
 *
 * var thirdHeaders = new Headers(secondHeaders);
 * console.log(thirdHeaders.get('X-My-Custom-Header')); //'Angular'
 * ```
 *
 * \@experimental
 */
var Headers = (function () {
    /**
     * @param {?=} headers
     */
    function Headers(headers) {
        var _this = this;
        /**
         * \@internal header names are lower case
         */
        this._headers = new Map();
        /**
         * \@internal map lower case names to actual names
         */
        this._normalizedNames = new Map();
        if (!headers) {
            return;
        }
        if (headers instanceof Headers) {
            headers.forEach(function (values, name) {
                values.forEach(function (value) { return _this.append(name, value); });
            });
            return;
        }
        Object.keys(headers).forEach(function (name) {
            var values = Array.isArray(headers[name]) ? headers[name] : [headers[name]];
            _this.delete(name);
            values.forEach(function (value) { return _this.append(name, value); });
        });
    }
    /**
     * Returns a new Headers instance from the given DOMString of Response Headers
     * @param {?} headersString
     * @return {?}
     */
    Headers.fromResponseHeaderString = function (headersString) {
        var /** @type {?} */ headers = new Headers();
        headersString.split('\n').forEach(function (line) {
            var /** @type {?} */ index = line.indexOf(':');
            if (index > 0) {
                var /** @type {?} */ name = line.slice(0, index);
                var /** @type {?} */ value = line.slice(index + 1).trim();
                headers.set(name, value);
            }
        });
        return headers;
    };
    /**
     * Appends a header to existing list of header values for a given header name.
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    Headers.prototype.append = function (name, value) {
        var /** @type {?} */ values = this.getAll(name);
        if (values === null) {
            this.set(name, value);
        }
        else {
            values.push(value);
        }
    };
    /**
     * Deletes all header values for the given name.
     * @param {?} name
     * @return {?}
     */
    Headers.prototype.delete = function (name) {
        var /** @type {?} */ lcName = name.toLowerCase();
        this._normalizedNames.delete(lcName);
        this._headers.delete(lcName);
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    Headers.prototype.forEach = function (fn) {
        var _this = this;
        this._headers.forEach(function (values, lcName) { return fn(values, _this._normalizedNames.get(lcName), _this._headers); });
    };
    /**
     * Returns first header that matches given name.
     * @param {?} name
     * @return {?}
     */
    Headers.prototype.get = function (name) {
        var /** @type {?} */ values = this.getAll(name);
        if (values === null) {
            return null;
        }
        return values.length > 0 ? values[0] : null;
    };
    /**
     * Checks for existence of header by given name.
     * @param {?} name
     * @return {?}
     */
    Headers.prototype.has = function (name) { return this._headers.has(name.toLowerCase()); };
    /**
     * Returns the names of the headers
     * @return {?}
     */
    Headers.prototype.keys = function () { return Array.from(this._normalizedNames.values()); };
    /**
     * Sets or overrides header value for given name.
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    Headers.prototype.set = function (name, value) {
        if (Array.isArray(value)) {
            if (value.length) {
                this._headers.set(name.toLowerCase(), [value.join(',')]);
            }
        }
        else {
            this._headers.set(name.toLowerCase(), [value]);
        }
        this.mayBeSetNormalizedName(name);
    };
    /**
     * Returns values of all headers.
     * @return {?}
     */
    Headers.prototype.values = function () { return Array.from(this._headers.values()); };
    /**
     * @return {?}
     */
    Headers.prototype.toJSON = function () {
        var _this = this;
        var /** @type {?} */ serialized = {};
        this._headers.forEach(function (values, name) {
            var /** @type {?} */ split = [];
            values.forEach(function (v) { return split.push.apply(split, v.split(',')); });
            serialized[((_this._normalizedNames.get(name)))] = split;
        });
        return serialized;
    };
    /**
     * Returns list of header values for a given name.
     * @param {?} name
     * @return {?}
     */
    Headers.prototype.getAll = function (name) {
        return this.has(name) ? this._headers.get(name.toLowerCase()) || null : null;
    };
    /**
     * This method is not implemented.
     * @return {?}
     */
    Headers.prototype.entries = function () { throw new Error('"entries" method is not implemented on Headers class'); };
    /**
     * @param {?} name
     * @return {?}
     */
    Headers.prototype.mayBeSetNormalizedName = function (name) {
        var /** @type {?} */ lcName = name.toLowerCase();
        if (!this._normalizedNames.has(lcName)) {
            this._normalizedNames.set(lcName, name);
        }
    };
    return Headers;
}());
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Creates a response options object to be optionally provided when instantiating a
 * {\@link Response}.
 *
 * This class is based on the `ResponseInit` description in the [Fetch
 * Spec](https://fetch.spec.whatwg.org/#responseinit).
 *
 * All values are null by default. Typical defaults can be found in the
 * {\@link BaseResponseOptions} class, which sub-classes `ResponseOptions`.
 *
 * This class may be used in tests to build {\@link Response Responses} for
 * mock responses (see {\@link MockBackend}).
 *
 * ### Example ([live demo](http://plnkr.co/edit/P9Jkk8e8cz6NVzbcxEsD?p=preview))
 *
 * ```typescript
 * import {ResponseOptions, Response} from '\@angular/http';
 *
 * var options = new ResponseOptions({
 *   body: '{"name":"Jeff"}'
 * });
 * var res = new Response(options);
 *
 * console.log('res.json():', res.json()); // Object {name: "Jeff"}
 * ```
 *
 * \@experimental
 */
var ResponseOptions = (function () {
    /**
     * @param {?=} opts
     */
    function ResponseOptions(opts) {
        if (opts === void 0) { opts = {}; }
        var body = opts.body, status = opts.status, headers = opts.headers, statusText = opts.statusText, type = opts.type, url = opts.url;
        this.body = body != null ? body : null;
        this.status = status != null ? status : null;
        this.headers = headers != null ? headers : null;
        this.statusText = statusText != null ? statusText : null;
        this.type = type != null ? type : null;
        this.url = url != null ? url : null;
    }
    /**
     * Creates a copy of the `ResponseOptions` instance, using the optional input as values to
     * override
     * existing values. This method will not change the values of the instance on which it is being
     * called.
     *
     * This may be useful when sharing a base `ResponseOptions` object inside tests,
     * where certain properties may change from test to test.
     *
     * ### Example ([live demo](http://plnkr.co/edit/1lXquqFfgduTFBWjNoRE?p=preview))
     *
     * ```typescript
     * import {ResponseOptions, Response} from '\@angular/http';
     *
     * var options = new ResponseOptions({
     *   body: {name: 'Jeff'}
     * });
     * var res = new Response(options.merge({
     *   url: 'https://google.com'
     * }));
     * console.log('options.url:', options.url); // null
     * console.log('res.json():', res.json()); // Object {name: "Jeff"}
     * console.log('res.url:', res.url); // https://google.com
     * ```
     * @param {?=} options
     * @return {?}
     */
    ResponseOptions.prototype.merge = function (options) {
        return new ResponseOptions({
            body: options && options.body != null ? options.body : this.body,
            status: options && options.status != null ? options.status : this.status,
            headers: options && options.headers != null ? options.headers : this.headers,
            statusText: options && options.statusText != null ? options.statusText : this.statusText,
            type: options && options.type != null ? options.type : this.type,
            url: options && options.url != null ? options.url : this.url,
        });
    };
    return ResponseOptions;
}());
/**
 * Subclass of {\@link ResponseOptions}, with default values.
 *
 * Default values:
 *  * status: 200
 *  * headers: empty {\@link Headers} object
 *
 * This class could be extended and bound to the {\@link ResponseOptions} class
 * when configuring an {\@link Injector}, in order to override the default options
 * used by {\@link Http} to create {\@link Response Responses}.
 *
 * ### Example ([live demo](http://plnkr.co/edit/qv8DLT?p=preview))
 *
 * ```typescript
 * import {provide} from '\@angular/core';
 * import {bootstrap} from '\@angular/platform-browser/browser';
 * import {HTTP_PROVIDERS, Headers, Http, BaseResponseOptions, ResponseOptions} from
 * '\@angular/http';
 * import {App} from './myapp';
 *
 * class MyOptions extends BaseResponseOptions {
 *   headers:Headers = new Headers({network: 'github'});
 * }
 *
 * bootstrap(App, [HTTP_PROVIDERS, {provide: ResponseOptions, useClass: MyOptions}]);
 * ```
 *
 * The options could also be extended when manually creating a {\@link Response}
 * object.
 *
 * ### Example ([live demo](http://plnkr.co/edit/VngosOWiaExEtbstDoix?p=preview))
 *
 * ```
 * import {BaseResponseOptions, Response} from '\@angular/http';
 *
 * var options = new BaseResponseOptions();
 * var res = new Response(options.merge({
 *   body: 'Angular',
 *   headers: new Headers({framework: 'angular'})
 * }));
 * console.log('res.headers.get("framework"):', res.headers.get('framework')); // angular
 * console.log('res.text():', res.text()); // Angular;
 * ```
 *
 * \@experimental
 */
var BaseResponseOptions = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](BaseResponseOptions, _super);
    function BaseResponseOptions() {
        return _super.call(this, { status: 200, statusText: 'Ok', type: ResponseType.Default, headers: new Headers() }) || this;
    }
    return BaseResponseOptions;
}(ResponseOptions));
BaseResponseOptions.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"] },
];
/**
 * @nocollapse
 */
BaseResponseOptions.ctorParameters = function () { return []; };
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Abstract class from which real backends are derived.
 *
 * The primary purpose of a `ConnectionBackend` is to create new connections to fulfill a given
 * {\@link Request}.
 *
 * \@experimental
 * @abstract
 */
var ConnectionBackend = (function () {
    function ConnectionBackend() {
    }
    /**
     * @abstract
     * @param {?} request
     * @return {?}
     */
    ConnectionBackend.prototype.createConnection = function (request) { };
    return ConnectionBackend;
}());
/**
 * Abstract class from which real connections are derived.
 *
 * \@experimental
 * @abstract
 */
var Connection = (function () {
    function Connection() {
    }
    return Connection;
}());
/**
 * An XSRFStrategy configures XSRF protection (e.g. via headers) on an HTTP request.
 *
 * \@experimental
 * @abstract
 */
var XSRFStrategy = (function () {
    function XSRFStrategy() {
    }
    /**
     * @abstract
     * @param {?} req
     * @return {?}
     */
    XSRFStrategy.prototype.configureRequest = function (req) { };
    return XSRFStrategy;
}());
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @param {?} method
 * @return {?}
 */
function normalizeMethodName(method) {
    if (typeof method !== 'string')
        return method;
    switch (method.toUpperCase()) {
        case 'GET':
            return RequestMethod.Get;
        case 'POST':
            return RequestMethod.Post;
        case 'PUT':
            return RequestMethod.Put;
        case 'DELETE':
            return RequestMethod.Delete;
        case 'OPTIONS':
            return RequestMethod.Options;
        case 'HEAD':
            return RequestMethod.Head;
        case 'PATCH':
            return RequestMethod.Patch;
    }
    throw new Error("Invalid request method. The method \"" + method + "\" is not supported.");
}
var isSuccess = function (status) { return (status >= 200 && status < 300); };
/**
 * @param {?} xhr
 * @return {?}
 */
function getResponseURL(xhr) {
    if ('responseURL' in xhr) {
        return xhr.responseURL;
    }
    if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
        return xhr.getResponseHeader('X-Request-URL');
    }
    return null;
}
/**
 * @param {?} input
 * @return {?}
 */
/**
 * @param {?} input
 * @return {?}
 */
function stringToArrayBuffer(input) {
    var /** @type {?} */ view = new Uint16Array(input.length);
    for (var /** @type {?} */ i = 0, /** @type {?} */ strLen = input.length; i < strLen; i++) {
        view[i] = input.charCodeAt(i);
    }
    return view.buffer;
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 * @param {?=} rawParams
 * @return {?}
 */
function paramParser(rawParams) {
    if (rawParams === void 0) { rawParams = ''; }
    var /** @type {?} */ map = new Map();
    if (rawParams.length > 0) {
        var /** @type {?} */ params = rawParams.split('&');
        params.forEach(function (param) {
            var /** @type {?} */ eqIdx = param.indexOf('=');
            var _a = eqIdx == -1 ? [param, ''] : [param.slice(0, eqIdx), param.slice(eqIdx + 1)], key = _a[0], val = _a[1];
            var /** @type {?} */ list = map.get(key) || [];
            list.push(val);
            map.set(key, list);
        });
    }
    return map;
}
/**
 * \@experimental
 *
 */
var QueryEncoder = (function () {
    function QueryEncoder() {
    }
    /**
     * @param {?} k
     * @return {?}
     */
    QueryEncoder.prototype.encodeKey = function (k) { return standardEncoding(k); };
    /**
     * @param {?} v
     * @return {?}
     */
    QueryEncoder.prototype.encodeValue = function (v) { return standardEncoding(v); };
    return QueryEncoder;
}());
/**
 * @param {?} v
 * @return {?}
 */
function standardEncoding(v) {
    return encodeURIComponent(v)
        .replace(/%40/gi, '@')
        .replace(/%3A/gi, ':')
        .replace(/%24/gi, '$')
        .replace(/%2C/gi, ',')
        .replace(/%3B/gi, ';')
        .replace(/%2B/gi, '+')
        .replace(/%3D/gi, '=')
        .replace(/%3F/gi, '?')
        .replace(/%2F/gi, '/');
}
/**
 * Map-like representation of url search parameters, based on
 * [URLSearchParams](https://url.spec.whatwg.org/#urlsearchparams) in the url living standard,
 * with several extensions for merging URLSearchParams objects:
 *   - setAll()
 *   - appendAll()
 *   - replaceAll()
 *
 * This class accepts an optional second parameter of ${\@link QueryEncoder},
 * which is used to serialize parameters before making a request. By default,
 * `QueryEncoder` encodes keys and values of parameters using `encodeURIComponent`,
 * and then un-encodes certain characters that are allowed to be part of the query
 * according to IETF RFC 3986: https://tools.ietf.org/html/rfc3986.
 *
 * These are the characters that are not encoded: `! $ \' ( ) * + , ; A 9 - . _ ~ ? /`
 *
 * If the set of allowed query characters is not acceptable for a particular backend,
 * `QueryEncoder` can be subclassed and provided as the 2nd argument to URLSearchParams.
 *
 * ```
 * import {URLSearchParams, QueryEncoder} from '\@angular/http';
 * class MyQueryEncoder extends QueryEncoder {
 *   encodeKey(k: string): string {
 *     return myEncodingFunction(k);
 *   }
 *
 *   encodeValue(v: string): string {
 *     return myEncodingFunction(v);
 *   }
 * }
 *
 * let params = new URLSearchParams('', new MyQueryEncoder());
 * ```
 * \@experimental
 */
var URLSearchParams = (function () {
    /**
     * @param {?=} rawParams
     * @param {?=} queryEncoder
     */
    function URLSearchParams(rawParams, queryEncoder) {
        if (rawParams === void 0) { rawParams = ''; }
        if (queryEncoder === void 0) { queryEncoder = new QueryEncoder(); }
        this.rawParams = rawParams;
        this.queryEncoder = queryEncoder;
        this.paramsMap = paramParser(rawParams);
    }
    /**
     * @return {?}
     */
    URLSearchParams.prototype.clone = function () {
        var /** @type {?} */ clone = new URLSearchParams('', this.queryEncoder);
        clone.appendAll(this);
        return clone;
    };
    /**
     * @param {?} param
     * @return {?}
     */
    URLSearchParams.prototype.has = function (param) { return this.paramsMap.has(param); };
    /**
     * @param {?} param
     * @return {?}
     */
    URLSearchParams.prototype.get = function (param) {
        var /** @type {?} */ storedParam = this.paramsMap.get(param);
        return Array.isArray(storedParam) ? storedParam[0] : null;
    };
    /**
     * @param {?} param
     * @return {?}
     */
    URLSearchParams.prototype.getAll = function (param) { return this.paramsMap.get(param) || []; };
    /**
     * @param {?} param
     * @param {?} val
     * @return {?}
     */
    URLSearchParams.prototype.set = function (param, val) {
        if (val === void 0 || val === null) {
            this.delete(param);
            return;
        }
        var /** @type {?} */ list = this.paramsMap.get(param) || [];
        list.length = 0;
        list.push(val);
        this.paramsMap.set(param, list);
    };
    /**
     * @param {?} searchParams
     * @return {?}
     */
    URLSearchParams.prototype.setAll = function (searchParams) {
        var _this = this;
        searchParams.paramsMap.forEach(function (value, param) {
            var /** @type {?} */ list = _this.paramsMap.get(param) || [];
            list.length = 0;
            list.push(value[0]);
            _this.paramsMap.set(param, list);
        });
    };
    /**
     * @param {?} param
     * @param {?} val
     * @return {?}
     */
    URLSearchParams.prototype.append = function (param, val) {
        if (val === void 0 || val === null)
            return;
        var /** @type {?} */ list = this.paramsMap.get(param) || [];
        list.push(val);
        this.paramsMap.set(param, list);
    };
    /**
     * @param {?} searchParams
     * @return {?}
     */
    URLSearchParams.prototype.appendAll = function (searchParams) {
        var _this = this;
        searchParams.paramsMap.forEach(function (value, param) {
            var /** @type {?} */ list = _this.paramsMap.get(param) || [];
            for (var /** @type {?} */ i = 0; i < value.length; ++i) {
                list.push(value[i]);
            }
            _this.paramsMap.set(param, list);
        });
    };
    /**
     * @param {?} searchParams
     * @return {?}
     */
    URLSearchParams.prototype.replaceAll = function (searchParams) {
        var _this = this;
        searchParams.paramsMap.forEach(function (value, param) {
            var /** @type {?} */ list = _this.paramsMap.get(param) || [];
            list.length = 0;
            for (var /** @type {?} */ i = 0; i < value.length; ++i) {
                list.push(value[i]);
            }
            _this.paramsMap.set(param, list);
        });
    };
    /**
     * @return {?}
     */
    URLSearchParams.prototype.toString = function () {
        var _this = this;
        var /** @type {?} */ paramsList = [];
        this.paramsMap.forEach(function (values, k) {
            values.forEach(function (v) { return paramsList.push(_this.queryEncoder.encodeKey(k) + '=' + _this.queryEncoder.encodeValue(v)); });
        });
        return paramsList.join('&');
    };
    /**
     * @param {?} param
     * @return {?}
     */
    URLSearchParams.prototype.delete = function (param) { this.paramsMap.delete(param); };
    return URLSearchParams;
}());
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * HTTP request body used by both {\@link Request} and {\@link Response}
 * https://fetch.spec.whatwg.org/#body
 * @abstract
 */
var Body = (function () {
    function Body() {
    }
    /**
     * Attempts to return body as parsed `JSON` object, or raises an exception.
     * @return {?}
     */
    Body.prototype.json = function () {
        if (typeof this._body === 'string') {
            return JSON.parse(/** @type {?} */ (this._body));
        }
        if (this._body instanceof ArrayBuffer) {
            return JSON.parse(this.text());
        }
        return this._body;
    };
    /**
     * Returns the body as a string, presuming `toString()` can be called on the response body.
     *
     * When decoding an `ArrayBuffer`, the optional `encodingHint` parameter determines how the
     * bytes in the buffer will be interpreted. Valid values are:
     *
     * - `legacy` - incorrectly interpret the bytes as UTF-16 (technically, UCS-2). Only characters
     *   in the Basic Multilingual Plane are supported, surrogate pairs are not handled correctly.
     *   In addition, the endianness of the 16-bit octet pairs in the `ArrayBuffer` is not taken
     *   into consideration. This is the default behavior to avoid breaking apps, but should be
     *   considered deprecated.
     *
     * - `iso-8859` - interpret the bytes as ISO-8859 (which can be used for ASCII encoded text).
     * @param {?=} encodingHint
     * @return {?}
     */
    Body.prototype.text = function (encodingHint) {
        if (encodingHint === void 0) { encodingHint = 'legacy'; }
        if (this._body instanceof URLSearchParams) {
            return this._body.toString();
        }
        if (this._body instanceof ArrayBuffer) {
            switch (encodingHint) {
                case 'legacy':
                    return String.fromCharCode.apply(null, new Uint16Array(/** @type {?} */ (this._body)));
                case 'iso-8859':
                    return String.fromCharCode.apply(null, new Uint8Array(/** @type {?} */ (this._body)));
                default:
                    throw new Error("Invalid value for encodingHint: " + encodingHint);
            }
        }
        if (this._body == null) {
            return '';
        }
        if (typeof this._body === 'object') {
            return JSON.stringify(this._body, null, 2);
        }
        return this._body.toString();
    };
    /**
     * Return the body as an ArrayBuffer
     * @return {?}
     */
    Body.prototype.arrayBuffer = function () {
        if (this._body instanceof ArrayBuffer) {
            return (this._body);
        }
        return stringToArrayBuffer(this.text());
    };
    /**
     * Returns the request's body as a Blob, assuming that body exists.
     * @return {?}
     */
    Body.prototype.blob = function () {
        if (this._body instanceof Blob) {
            return (this._body);
        }
        if (this._body instanceof ArrayBuffer) {
            return new Blob([this._body]);
        }
        throw new Error('The request body isn\'t either a blob or an array buffer');
    };
    return Body;
}());
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Creates `Response` instances from provided values.
 *
 * Though this object isn't
 * usually instantiated by end-users, it is the primary object interacted with when it comes time to
 * add data to a view.
 *
 * ### Example
 *
 * ```
 * http.request('my-friends.txt').subscribe(response => this.friends = response.text());
 * ```
 *
 * The Response's interface is inspired by the Response constructor defined in the [Fetch
 * Spec](https://fetch.spec.whatwg.org/#response-class), but is considered a static value whose body
 * can be accessed many times. There are other differences in the implementation, but this is the
 * most significant.
 *
 * \@experimental
 */
var Response = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](Response, _super);
    /**
     * @param {?} responseOptions
     */
    function Response(responseOptions) {
        var _this = _super.call(this) || this;
        _this._body = responseOptions.body;
        _this.status = responseOptions.status;
        _this.ok = (_this.status >= 200 && _this.status <= 299);
        _this.statusText = responseOptions.statusText;
        _this.headers = responseOptions.headers;
        _this.type = responseOptions.type;
        _this.url = responseOptions.url;
        return _this;
    }
    /**
     * @return {?}
     */
    Response.prototype.toString = function () {
        return "Response with status: " + this.status + " " + this.statusText + " for URL: " + this.url;
    };
    return Response;
}(Body));
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var _nextRequestId = 0;
var JSONP_HOME = '__ng_jsonp__';
var _jsonpConnections = null;
/**
 * @return {?}
 */
function _getJsonpConnections() {
    var /** @type {?} */ w = typeof window == 'object' ? window : {};
    if (_jsonpConnections === null) {
        _jsonpConnections = w[JSONP_HOME] = {};
    }
    return _jsonpConnections;
}
var BrowserJsonp = (function () {
    function BrowserJsonp() {
    }
    /**
     * @param {?} url
     * @return {?}
     */
    BrowserJsonp.prototype.build = function (url) {
        var /** @type {?} */ node = document.createElement('script');
        node.src = url;
        return node;
    };
    /**
     * @return {?}
     */
    BrowserJsonp.prototype.nextRequestID = function () { return "__req" + _nextRequestId++; };
    /**
     * @param {?} id
     * @return {?}
     */
    BrowserJsonp.prototype.requestCallback = function (id) { return JSONP_HOME + "." + id + ".finished"; };
    /**
     * @param {?} id
     * @param {?} connection
     * @return {?}
     */
    BrowserJsonp.prototype.exposeConnection = function (id, connection) {
        var /** @type {?} */ connections = _getJsonpConnections();
        connections[id] = connection;
    };
    /**
     * @param {?} id
     * @return {?}
     */
    BrowserJsonp.prototype.removeConnection = function (id) {
        var /** @type {?} */ connections = _getJsonpConnections();
        connections[id] = null;
    };
    /**
     * @param {?} node
     * @return {?}
     */
    BrowserJsonp.prototype.send = function (node) { document.body.appendChild(/** @type {?} */ ((node))); };
    /**
     * @param {?} node
     * @return {?}
     */
    BrowserJsonp.prototype.cleanup = function (node) {
        if (node.parentNode) {
            node.parentNode.removeChild(/** @type {?} */ ((node)));
        }
    };
    return BrowserJsonp;
}());
BrowserJsonp.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"] },
];
/**
 * @nocollapse
 */
BrowserJsonp.ctorParameters = function () { return []; };
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var JSONP_ERR_NO_CALLBACK = 'JSONP injected script did not invoke callback.';
var JSONP_ERR_WRONG_METHOD = 'JSONP requests must use GET request method.';
/**
 * Abstract base class for an in-flight JSONP request.
 *
 * \@experimental
 * @abstract
 */
var JSONPConnection = (function () {
    function JSONPConnection() {
    }
    /**
     * Callback called when the JSONP request completes, to notify the application
     * of the new data.
     * @abstract
     * @param {?=} data
     * @return {?}
     */
    JSONPConnection.prototype.finished = function (data) { };
    return JSONPConnection;
}());
var JSONPConnection_ = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](JSONPConnection_, _super);
    /**
     * @param {?} req
     * @param {?} _dom
     * @param {?=} baseResponseOptions
     */
    function JSONPConnection_(req, _dom, baseResponseOptions) {
        var _this = _super.call(this) || this;
        _this._dom = _dom;
        _this.baseResponseOptions = baseResponseOptions;
        _this._finished = false;
        if (req.method !== RequestMethod.Get) {
            throw new TypeError(JSONP_ERR_WRONG_METHOD);
        }
        _this.request = req;
        _this.response = new __WEBPACK_IMPORTED_MODULE_2_rxjs_Observable__["Observable"](function (responseObserver) {
            _this.readyState = ReadyState.Loading;
            var id = _this._id = _dom.nextRequestID();
            _dom.exposeConnection(id, _this);
            // Workaround Dart
            // url = url.replace(/=JSONP_CALLBACK(&|$)/, `generated method`);
            var callback = _dom.requestCallback(_this._id);
            var url = req.url;
            if (url.indexOf('=JSONP_CALLBACK&') > -1) {
                url = url.replace('=JSONP_CALLBACK&', "=" + callback + "&");
            }
            else if (url.lastIndexOf('=JSONP_CALLBACK') === url.length - '=JSONP_CALLBACK'.length) {
                url = url.substring(0, url.length - '=JSONP_CALLBACK'.length) + ("=" + callback);
            }
            var script = _this._script = _dom.build(url);
            var onLoad = function (event) {
                if (_this.readyState === ReadyState.Cancelled)
                    return;
                _this.readyState = ReadyState.Done;
                _dom.cleanup(script);
                if (!_this._finished) {
                    var responseOptions_1 = new ResponseOptions({ body: JSONP_ERR_NO_CALLBACK, type: ResponseType.Error, url: url });
                    if (baseResponseOptions) {
                        responseOptions_1 = baseResponseOptions.merge(responseOptions_1);
                    }
                    responseObserver.error(new Response(responseOptions_1));
                    return;
                }
                var responseOptions = new ResponseOptions({ body: _this._responseData, url: url });
                if (_this.baseResponseOptions) {
                    responseOptions = _this.baseResponseOptions.merge(responseOptions);
                }
                responseObserver.next(new Response(responseOptions));
                responseObserver.complete();
            };
            var onError = function (error) {
                if (_this.readyState === ReadyState.Cancelled)
                    return;
                _this.readyState = ReadyState.Done;
                _dom.cleanup(script);
                var responseOptions = new ResponseOptions({ body: error.message, type: ResponseType.Error });
                if (baseResponseOptions) {
                    responseOptions = baseResponseOptions.merge(responseOptions);
                }
                responseObserver.error(new Response(responseOptions));
            };
            script.addEventListener('load', onLoad);
            script.addEventListener('error', onError);
            _dom.send(script);
            return function () {
                _this.readyState = ReadyState.Cancelled;
                script.removeEventListener('load', onLoad);
                script.removeEventListener('error', onError);
                _this._dom.cleanup(script);
            };
        });
        return _this;
    }
    /**
     * @param {?=} data
     * @return {?}
     */
    JSONPConnection_.prototype.finished = function (data) {
        // Don't leak connections
        this._finished = true;
        this._dom.removeConnection(this._id);
        if (this.readyState === ReadyState.Cancelled)
            return;
        this._responseData = data;
    };
    return JSONPConnection_;
}(JSONPConnection));
/**
 * A {\@link ConnectionBackend} that uses the JSONP strategy of making requests.
 *
 * \@experimental
 * @abstract
 */
var JSONPBackend = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](JSONPBackend, _super);
    function JSONPBackend() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return JSONPBackend;
}(ConnectionBackend));
var JSONPBackend_ = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](JSONPBackend_, _super);
    /**
     * @param {?} _browserJSONP
     * @param {?} _baseResponseOptions
     */
    function JSONPBackend_(_browserJSONP, _baseResponseOptions) {
        var _this = _super.call(this) || this;
        _this._browserJSONP = _browserJSONP;
        _this._baseResponseOptions = _baseResponseOptions;
        return _this;
    }
    /**
     * @param {?} request
     * @return {?}
     */
    JSONPBackend_.prototype.createConnection = function (request) {
        return new JSONPConnection_(request, this._browserJSONP, this._baseResponseOptions);
    };
    return JSONPBackend_;
}(JSONPBackend));
JSONPBackend_.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"] },
];
/**
 * @nocollapse
 */
JSONPBackend_.ctorParameters = function () { return [
    { type: BrowserJsonp, },
    { type: ResponseOptions, },
]; };
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var XSSI_PREFIX = /^\)\]\}',?\n/;
/**
 * Creates connections using `XMLHttpRequest`. Given a fully-qualified
 * request, an `XHRConnection` will immediately create an `XMLHttpRequest` object and send the
 * request.
 *
 * This class would typically not be created or interacted with directly inside applications, though
 * the {\@link MockConnection} may be interacted with in tests.
 *
 * \@experimental
 */
var XHRConnection = (function () {
    /**
     * @param {?} req
     * @param {?} browserXHR
     * @param {?=} baseResponseOptions
     */
    function XHRConnection(req, browserXHR, baseResponseOptions) {
        var _this = this;
        this.request = req;
        this.response = new __WEBPACK_IMPORTED_MODULE_2_rxjs_Observable__["Observable"](function (responseObserver) {
            var _xhr = browserXHR.build();
            _xhr.open(RequestMethod[req.method].toUpperCase(), req.url);
            if (req.withCredentials != null) {
                _xhr.withCredentials = req.withCredentials;
            }
            // load event handler
            var onLoad = function () {
                // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)
                var status = _xhr.status === 1223 ? 204 : _xhr.status;
                var body = null;
                // HTTP 204 means no content
                if (status !== 204) {
                    // responseText is the old-school way of retrieving response (supported by IE8 & 9)
                    // response/responseType properties were introduced in ResourceLoader Level2 spec
                    // (supported by IE10)
                    body = (typeof _xhr.response === 'undefined') ? _xhr.responseText : _xhr.response;
                    // Implicitly strip a potential XSSI prefix.
                    if (typeof body === 'string') {
                        body = body.replace(XSSI_PREFIX, '');
                    }
                }
                // fix status code when it is 0 (0 status is undocumented).
                // Occurs when accessing file resources or on Android 4.1 stock browser
                // while retrieving files from application cache.
                if (status === 0) {
                    status = body ? 200 : 0;
                }
                var headers = Headers.fromResponseHeaderString(_xhr.getAllResponseHeaders());
                // IE 9 does not provide the way to get URL of response
                var url = getResponseURL(_xhr) || req.url;
                var statusText = _xhr.statusText || 'OK';
                var responseOptions = new ResponseOptions({ body: body, status: status, headers: headers, statusText: statusText, url: url });
                if (baseResponseOptions != null) {
                    responseOptions = baseResponseOptions.merge(responseOptions);
                }
                var response = new Response(responseOptions);
                response.ok = isSuccess(status);
                if (response.ok) {
                    responseObserver.next(response);
                    // TODO(gdi2290): defer complete if array buffer until done
                    responseObserver.complete();
                    return;
                }
                responseObserver.error(response);
            };
            // error event handler
            var onError = function (err) {
                var responseOptions = new ResponseOptions({
                    body: err,
                    type: ResponseType.Error,
                    status: _xhr.status,
                    statusText: _xhr.statusText,
                });
                if (baseResponseOptions != null) {
                    responseOptions = baseResponseOptions.merge(responseOptions);
                }
                responseObserver.error(new Response(responseOptions));
            };
            _this.setDetectedContentType(req, _xhr);
            if (req.headers == null) {
                req.headers = new Headers();
            }
            if (!req.headers.has('Accept')) {
                req.headers.append('Accept', 'application/json, text/plain, */*');
            }
            req.headers.forEach(function (values, name) { return _xhr.setRequestHeader(name, values.join(',')); });
            // Select the correct buffer type to store the response
            if (req.responseType != null && _xhr.responseType != null) {
                switch (req.responseType) {
                    case ResponseContentType.ArrayBuffer:
                        _xhr.responseType = 'arraybuffer';
                        break;
                    case ResponseContentType.Json:
                        _xhr.responseType = 'json';
                        break;
                    case ResponseContentType.Text:
                        _xhr.responseType = 'text';
                        break;
                    case ResponseContentType.Blob:
                        _xhr.responseType = 'blob';
                        break;
                    default:
                        throw new Error('The selected responseType is not supported');
                }
            }
            _xhr.addEventListener('load', onLoad);
            _xhr.addEventListener('error', onError);
            _xhr.send(_this.request.getBody());
            return function () {
                _xhr.removeEventListener('load', onLoad);
                _xhr.removeEventListener('error', onError);
                _xhr.abort();
            };
        });
    }
    /**
     * @param {?} req
     * @param {?} _xhr
     * @return {?}
     */
    XHRConnection.prototype.setDetectedContentType = function (req /** TODO Request */, _xhr /** XMLHttpRequest */) {
        // Skip if a custom Content-Type header is provided
        if (req.headers != null && req.headers.get('Content-Type') != null) {
            return;
        }
        // Set the detected content type
        switch (req.contentType) {
            case ContentType.NONE:
                break;
            case ContentType.JSON:
                _xhr.setRequestHeader('content-type', 'application/json');
                break;
            case ContentType.FORM:
                _xhr.setRequestHeader('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
                break;
            case ContentType.TEXT:
                _xhr.setRequestHeader('content-type', 'text/plain');
                break;
            case ContentType.BLOB:
                var /** @type {?} */ blob = req.blob();
                if (blob.type) {
                    _xhr.setRequestHeader('content-type', blob.type);
                }
                break;
        }
    };
    return XHRConnection;
}());
/**
 * `XSRFConfiguration` sets up Cross Site Request Forgery (XSRF) protection for the application
 * using a cookie. See https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)
 * for more information on XSRF.
 *
 * Applications can configure custom cookie and header names by binding an instance of this class
 * with different `cookieName` and `headerName` values. See the main HTTP documentation for more
 * details.
 *
 * \@experimental
 */
var CookieXSRFStrategy = (function () {
    /**
     * @param {?=} _cookieName
     * @param {?=} _headerName
     */
    function CookieXSRFStrategy(_cookieName, _headerName) {
        if (_cookieName === void 0) { _cookieName = 'XSRF-TOKEN'; }
        if (_headerName === void 0) { _headerName = 'X-XSRF-TOKEN'; }
        this._cookieName = _cookieName;
        this._headerName = _headerName;
    }
    /**
     * @param {?} req
     * @return {?}
     */
    CookieXSRFStrategy.prototype.configureRequest = function (req) {
        var /** @type {?} */ xsrfToken = Object(__WEBPACK_IMPORTED_MODULE_3__angular_platform_browser__["ɵgetDOM"])().getCookie(this._cookieName);
        if (xsrfToken) {
            req.headers.set(this._headerName, xsrfToken);
        }
    };
    return CookieXSRFStrategy;
}());
/**
 * Creates {\@link XHRConnection} instances.
 *
 * This class would typically not be used by end users, but could be
 * overridden if a different backend implementation should be used,
 * such as in a node backend.
 *
 * ### Example
 *
 * ```
 * import {Http, MyNodeBackend, HTTP_PROVIDERS, BaseRequestOptions} from '\@angular/http';
 * \@Component({
 *   viewProviders: [
 *     HTTP_PROVIDERS,
 *     {provide: Http, useFactory: (backend, options) => {
 *       return new Http(backend, options);
 *     }, deps: [MyNodeBackend, BaseRequestOptions]}]
 * })
 * class MyComponent {
 *   constructor(http:Http) {
 *     http.request('people.json').subscribe(res => this.people = res.json());
 *   }
 * }
 * ```
 * \@experimental
 */
var XHRBackend = (function () {
    /**
     * @param {?} _browserXHR
     * @param {?} _baseResponseOptions
     * @param {?} _xsrfStrategy
     */
    function XHRBackend(_browserXHR, _baseResponseOptions, _xsrfStrategy) {
        this._browserXHR = _browserXHR;
        this._baseResponseOptions = _baseResponseOptions;
        this._xsrfStrategy = _xsrfStrategy;
    }
    /**
     * @param {?} request
     * @return {?}
     */
    XHRBackend.prototype.createConnection = function (request) {
        this._xsrfStrategy.configureRequest(request);
        return new XHRConnection(request, this._browserXHR, this._baseResponseOptions);
    };
    return XHRBackend;
}());
XHRBackend.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"] },
];
/**
 * @nocollapse
 */
XHRBackend.ctorParameters = function () { return [
    { type: BrowserXhr, },
    { type: ResponseOptions, },
    { type: XSRFStrategy, },
]; };
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Creates a request options object to be optionally provided when instantiating a
 * {\@link Request}.
 *
 * This class is based on the `RequestInit` description in the [Fetch
 * Spec](https://fetch.spec.whatwg.org/#requestinit).
 *
 * All values are null by default. Typical defaults can be found in the {\@link BaseRequestOptions}
 * class, which sub-classes `RequestOptions`.
 *
 * ```typescript
 * import {RequestOptions, Request, RequestMethod} from '\@angular/http';
 *
 * const options = new RequestOptions({
 *   method: RequestMethod.Post,
 *   url: 'https://google.com'
 * });
 * const req = new Request(options);
 * console.log('req.method:', RequestMethod[req.method]); // Post
 * console.log('options.url:', options.url); // https://google.com
 * ```
 *
 * \@experimental
 */
var RequestOptions = (function () {
    /**
     * @param {?=} opts
     */
    function RequestOptions(opts) {
        if (opts === void 0) { opts = {}; }
        var method = opts.method, headers = opts.headers, body = opts.body, url = opts.url, search = opts.search, params = opts.params, withCredentials = opts.withCredentials, responseType = opts.responseType;
        this.method = method != null ? normalizeMethodName(method) : null;
        this.headers = headers != null ? headers : null;
        this.body = body != null ? body : null;
        this.url = url != null ? url : null;
        this.params = this._mergeSearchParams(params || search);
        this.withCredentials = withCredentials != null ? withCredentials : null;
        this.responseType = responseType != null ? responseType : null;
    }
    Object.defineProperty(RequestOptions.prototype, "search", {
        /**
         * @deprecated from 4.0.0. Use params instead.
         * @return {?}
         */
        get: function () { return this.params; },
        /**
         * @deprecated from 4.0.0. Use params instead.
         * @param {?} params
         * @return {?}
         */
        set: function (params) { this.params = params; },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates a copy of the `RequestOptions` instance, using the optional input as values to override
     * existing values. This method will not change the values of the instance on which it is being
     * called.
     *
     * Note that `headers` and `search` will override existing values completely if present in
     * the `options` object. If these values should be merged, it should be done prior to calling
     * `merge` on the `RequestOptions` instance.
     *
     * ```typescript
     * import {RequestOptions, Request, RequestMethod} from '\@angular/http';
     *
     * const options = new RequestOptions({
     *   method: RequestMethod.Post
     * });
     * const req = new Request(options.merge({
     *   url: 'https://google.com'
     * }));
     * console.log('req.method:', RequestMethod[req.method]); // Post
     * console.log('options.url:', options.url); // null
     * console.log('req.url:', req.url); // https://google.com
     * ```
     * @param {?=} options
     * @return {?}
     */
    RequestOptions.prototype.merge = function (options) {
        return new RequestOptions({
            method: options && options.method != null ? options.method : this.method,
            headers: options && options.headers != null ? options.headers : new Headers(this.headers),
            body: options && options.body != null ? options.body : this.body,
            url: options && options.url != null ? options.url : this.url,
            params: options && this._mergeSearchParams(options.params || options.search),
            withCredentials: options && options.withCredentials != null ? options.withCredentials :
                this.withCredentials,
            responseType: options && options.responseType != null ? options.responseType :
                this.responseType
        });
    };
    /**
     * @param {?=} params
     * @return {?}
     */
    RequestOptions.prototype._mergeSearchParams = function (params) {
        if (!params)
            return this.params;
        if (params instanceof URLSearchParams) {
            return params.clone();
        }
        if (typeof params === 'string') {
            return new URLSearchParams(params);
        }
        return this._parseParams(params);
    };
    /**
     * @param {?=} objParams
     * @return {?}
     */
    RequestOptions.prototype._parseParams = function (objParams) {
        var _this = this;
        if (objParams === void 0) { objParams = {}; }
        var /** @type {?} */ params = new URLSearchParams();
        Object.keys(objParams).forEach(function (key) {
            var /** @type {?} */ value = objParams[key];
            if (Array.isArray(value)) {
                value.forEach(function (item) { return _this._appendParam(key, item, params); });
            }
            else {
                _this._appendParam(key, value, params);
            }
        });
        return params;
    };
    /**
     * @param {?} key
     * @param {?} value
     * @param {?} params
     * @return {?}
     */
    RequestOptions.prototype._appendParam = function (key, value, params) {
        if (typeof value !== 'string') {
            value = JSON.stringify(value);
        }
        params.append(key, value);
    };
    return RequestOptions;
}());
/**
 * Subclass of {\@link RequestOptions}, with default values.
 *
 * Default values:
 *  * method: {\@link RequestMethod RequestMethod.Get}
 *  * headers: empty {\@link Headers} object
 *
 * This class could be extended and bound to the {\@link RequestOptions} class
 * when configuring an {\@link Injector}, in order to override the default options
 * used by {\@link Http} to create and send {\@link Request Requests}.
 *
 * ```typescript
 * import {BaseRequestOptions, RequestOptions} from '\@angular/http';
 *
 * class MyOptions extends BaseRequestOptions {
 *   search: string = 'coreTeam=true';
 * }
 *
 * {provide: RequestOptions, useClass: MyOptions};
 * ```
 *
 * The options could also be extended when manually creating a {\@link Request}
 * object.
 *
 * ```
 * import {BaseRequestOptions, Request, RequestMethod} from '\@angular/http';
 *
 * const options = new BaseRequestOptions();
 * const req = new Request(options.merge({
 *   method: RequestMethod.Post,
 *   url: 'https://google.com'
 * }));
 * console.log('req.method:', RequestMethod[req.method]); // Post
 * console.log('options.url:', options.url); // null
 * console.log('req.url:', req.url); // https://google.com
 * ```
 *
 * \@experimental
 */
var BaseRequestOptions = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](BaseRequestOptions, _super);
    function BaseRequestOptions() {
        return _super.call(this, { method: RequestMethod.Get, headers: new Headers() }) || this;
    }
    return BaseRequestOptions;
}(RequestOptions));
BaseRequestOptions.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"] },
];
/**
 * @nocollapse
 */
BaseRequestOptions.ctorParameters = function () { return []; };
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Creates `Request` instances from provided values.
 *
 * The Request's interface is inspired by the Request constructor defined in the [Fetch
 * Spec](https://fetch.spec.whatwg.org/#request-class),
 * but is considered a static value whose body can be accessed many times. There are other
 * differences in the implementation, but this is the most significant.
 *
 * `Request` instances are typically created by higher-level classes, like {\@link Http} and
 * {\@link Jsonp}, but it may occasionally be useful to explicitly create `Request` instances.
 * One such example is when creating services that wrap higher-level services, like {\@link Http},
 * where it may be useful to generate a `Request` with arbitrary headers and search params.
 *
 * ```typescript
 * import {Injectable, Injector} from '\@angular/core';
 * import {HTTP_PROVIDERS, Http, Request, RequestMethod} from '\@angular/http';
 *
 * \@Injectable()
 * class AutoAuthenticator {
 *   constructor(public http:Http) {}
 *   request(url:string) {
 *     return this.http.request(new Request({
 *       method: RequestMethod.Get,
 *       url: url,
 *       search: 'password=123'
 *     }));
 *   }
 * }
 *
 * var injector = Injector.resolveAndCreate([HTTP_PROVIDERS, AutoAuthenticator]);
 * var authenticator = injector.get(AutoAuthenticator);
 * authenticator.request('people.json').subscribe(res => {
 *   //URL should have included '?password=123'
 *   console.log('people', res.json());
 * });
 * ```
 *
 * \@experimental
 */
var Request = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](Request, _super);
    /**
     * @param {?} requestOptions
     */
    function Request(requestOptions) {
        var _this = _super.call(this) || this;
        // TODO: assert that url is present
        var url = requestOptions.url;
        _this.url = requestOptions.url;
        var paramsArg = requestOptions.params || requestOptions.search;
        if (paramsArg) {
            var params = void 0;
            if (typeof paramsArg === 'object' && !(paramsArg instanceof URLSearchParams)) {
                params = urlEncodeParams(paramsArg).toString();
            }
            else {
                params = paramsArg.toString();
            }
            if (params.length > 0) {
                var prefix = '?';
                if (_this.url.indexOf('?') != -1) {
                    prefix = (_this.url[_this.url.length - 1] == '&') ? '' : '&';
                }
                // TODO: just delete search-query-looking string in url?
                _this.url = url + prefix + params;
            }
        }
        _this._body = requestOptions.body;
        _this.method = normalizeMethodName(requestOptions.method);
        // TODO(jeffbcross): implement behavior
        // Defaults to 'omit', consistent with browser
        _this.headers = new Headers(requestOptions.headers);
        _this.contentType = _this.detectContentType();
        _this.withCredentials = requestOptions.withCredentials;
        _this.responseType = requestOptions.responseType;
        return _this;
    }
    /**
     * Returns the content type enum based on header options.
     * @return {?}
     */
    Request.prototype.detectContentType = function () {
        switch (this.headers.get('content-type')) {
            case 'application/json':
                return ContentType.JSON;
            case 'application/x-www-form-urlencoded':
                return ContentType.FORM;
            case 'multipart/form-data':
                return ContentType.FORM_DATA;
            case 'text/plain':
            case 'text/html':
                return ContentType.TEXT;
            case 'application/octet-stream':
                return this._body instanceof ArrayBuffer$1 ? ContentType.ARRAY_BUFFER : ContentType.BLOB;
            default:
                return this.detectContentTypeFromBody();
        }
    };
    /**
     * Returns the content type of request's body based on its type.
     * @return {?}
     */
    Request.prototype.detectContentTypeFromBody = function () {
        if (this._body == null) {
            return ContentType.NONE;
        }
        else if (this._body instanceof URLSearchParams) {
            return ContentType.FORM;
        }
        else if (this._body instanceof FormData) {
            return ContentType.FORM_DATA;
        }
        else if (this._body instanceof Blob$1) {
            return ContentType.BLOB;
        }
        else if (this._body instanceof ArrayBuffer$1) {
            return ContentType.ARRAY_BUFFER;
        }
        else if (this._body && typeof this._body === 'object') {
            return ContentType.JSON;
        }
        else {
            return ContentType.TEXT;
        }
    };
    /**
     * Returns the request's body according to its type. If body is undefined, return
     * null.
     * @return {?}
     */
    Request.prototype.getBody = function () {
        switch (this.contentType) {
            case ContentType.JSON:
                return this.text();
            case ContentType.FORM:
                return this.text();
            case ContentType.FORM_DATA:
                return this._body;
            case ContentType.TEXT:
                return this.text();
            case ContentType.BLOB:
                return this.blob();
            case ContentType.ARRAY_BUFFER:
                return this.arrayBuffer();
            default:
                return null;
        }
    };
    return Request;
}(Body));
/**
 * @param {?} params
 * @return {?}
 */
function urlEncodeParams(params) {
    var /** @type {?} */ searchParams = new URLSearchParams();
    Object.keys(params).forEach(function (key) {
        var /** @type {?} */ value = params[key];
        if (value && Array.isArray(value)) {
            value.forEach(function (element) { return searchParams.append(key, element.toString()); });
        }
        else {
            searchParams.append(key, value.toString());
        }
    });
    return searchParams;
}
var noop = function () { };
var w = typeof window == 'object' ? window : noop;
var FormData = ((w) /** TODO #9100 */)['FormData'] || noop;
var Blob$1 = ((w) /** TODO #9100 */)['Blob'] || noop;
var ArrayBuffer$1 = ((w) /** TODO #9100 */)['ArrayBuffer'] || noop;
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @param {?} backend
 * @param {?} request
 * @return {?}
 */
function httpRequest(backend, request) {
    return backend.createConnection(request).response;
}
/**
 * @param {?} defaultOpts
 * @param {?} providedOpts
 * @param {?} method
 * @param {?} url
 * @return {?}
 */
function mergeOptions(defaultOpts, providedOpts, method, url) {
    var /** @type {?} */ newOptions = defaultOpts;
    if (providedOpts) {
        // Hack so Dart can used named parameters
        return (newOptions.merge(new RequestOptions({
            method: providedOpts.method || method,
            url: providedOpts.url || url,
            search: providedOpts.search,
            params: providedOpts.params,
            headers: providedOpts.headers,
            body: providedOpts.body,
            withCredentials: providedOpts.withCredentials,
            responseType: providedOpts.responseType
        })));
    }
    return (newOptions.merge(new RequestOptions({ method: method, url: url })));
}
/**
 * Performs http requests using `XMLHttpRequest` as the default backend.
 *
 * `Http` is available as an injectable class, with methods to perform http requests. Calling
 * `request` returns an `Observable` which will emit a single {\@link Response} when a
 * response is received.
 *
 * ### Example
 *
 * ```typescript
 * import {Http, HTTP_PROVIDERS} from '\@angular/http';
 * import 'rxjs/add/operator/map'
 * \@Component({
 *   selector: 'http-app',
 *   viewProviders: [HTTP_PROVIDERS],
 *   templateUrl: 'people.html'
 * })
 * class PeopleComponent {
 *   constructor(http: Http) {
 *     http.get('people.json')
 *       // Call map on the response observable to get the parsed people object
 *       .map(res => res.json())
 *       // Subscribe to the observable to get the parsed people object and attach it to the
 *       // component
 *       .subscribe(people => this.people = people);
 *   }
 * }
 * ```
 *
 *
 * ### Example
 *
 * ```
 * http.get('people.json').subscribe((res:Response) => this.people = res.json());
 * ```
 *
 * The default construct used to perform requests, `XMLHttpRequest`, is abstracted as a "Backend" (
 * {\@link XHRBackend} in this case), which could be mocked with dependency injection by replacing
 * the {\@link XHRBackend} provider, as in the following example:
 *
 * ### Example
 *
 * ```typescript
 * import {BaseRequestOptions, Http} from '\@angular/http';
 * import {MockBackend} from '\@angular/http/testing';
 * var injector = Injector.resolveAndCreate([
 *   BaseRequestOptions,
 *   MockBackend,
 *   {provide: Http, useFactory:
 *       function(backend, defaultOptions) {
 *         return new Http(backend, defaultOptions);
 *       },
 *       deps: [MockBackend, BaseRequestOptions]}
 * ]);
 * var http = injector.get(Http);
 * http.get('request-from-mock-backend.json').subscribe((res:Response) => doSomething(res));
 * ```
 *
 * \@experimental
 */
var Http = (function () {
    /**
     * @param {?} _backend
     * @param {?} _defaultOptions
     */
    function Http(_backend, _defaultOptions) {
        this._backend = _backend;
        this._defaultOptions = _defaultOptions;
    }
    /**
     * Performs any type of http request. First argument is required, and can either be a url or
     * a {\@link Request} instance. If the first argument is a url, an optional {\@link RequestOptions}
     * object can be provided as the 2nd argument. The options object will be merged with the values
     * of {\@link BaseRequestOptions} before performing the request.
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    Http.prototype.request = function (url, options) {
        var /** @type {?} */ responseObservable;
        if (typeof url === 'string') {
            responseObservable = httpRequest(this._backend, new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Get, /** @type {?} */ (url))));
        }
        else if (url instanceof Request) {
            responseObservable = httpRequest(this._backend, url);
        }
        else {
            throw new Error('First argument must be a url string or Request instance.');
        }
        return responseObservable;
    };
    /**
     * Performs a request with `get` http method.
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    Http.prototype.get = function (url, options) {
        return this.request(new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Get, url)));
    };
    /**
     * Performs a request with `post` http method.
     * @param {?} url
     * @param {?} body
     * @param {?=} options
     * @return {?}
     */
    Http.prototype.post = function (url, body, options) {
        return this.request(new Request(mergeOptions(this._defaultOptions.merge(new RequestOptions({ body: body })), options, RequestMethod.Post, url)));
    };
    /**
     * Performs a request with `put` http method.
     * @param {?} url
     * @param {?} body
     * @param {?=} options
     * @return {?}
     */
    Http.prototype.put = function (url, body, options) {
        return this.request(new Request(mergeOptions(this._defaultOptions.merge(new RequestOptions({ body: body })), options, RequestMethod.Put, url)));
    };
    /**
     * Performs a request with `delete` http method.
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    Http.prototype.delete = function (url, options) {
        return this.request(new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Delete, url)));
    };
    /**
     * Performs a request with `patch` http method.
     * @param {?} url
     * @param {?} body
     * @param {?=} options
     * @return {?}
     */
    Http.prototype.patch = function (url, body, options) {
        return this.request(new Request(mergeOptions(this._defaultOptions.merge(new RequestOptions({ body: body })), options, RequestMethod.Patch, url)));
    };
    /**
     * Performs a request with `head` http method.
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    Http.prototype.head = function (url, options) {
        return this.request(new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Head, url)));
    };
    /**
     * Performs a request with `options` http method.
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    Http.prototype.options = function (url, options) {
        return this.request(new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Options, url)));
    };
    return Http;
}());
Http.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"] },
];
/**
 * @nocollapse
 */
Http.ctorParameters = function () { return [
    { type: ConnectionBackend, },
    { type: RequestOptions, },
]; };
/**
 * \@experimental
 */
var Jsonp = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](Jsonp, _super);
    /**
     * @param {?} backend
     * @param {?} defaultOptions
     */
    function Jsonp(backend, defaultOptions) {
        return _super.call(this, backend, defaultOptions) || this;
    }
    /**
     * Performs any type of http request. First argument is required, and can either be a url or
     * a {\@link Request} instance. If the first argument is a url, an optional {\@link RequestOptions}
     * object can be provided as the 2nd argument. The options object will be merged with the values
     * of {\@link BaseRequestOptions} before performing the request.
     *
     * \@security Regular XHR is the safest alternative to JSONP for most applications, and is
     * supported by all current browsers. Because JSONP creates a `<script>` element with
     * contents retrieved from a remote source, attacker-controlled data introduced by an untrusted
     * source could expose your application to XSS risks. Data exposed by JSONP may also be
     * readable by malicious third-party websites. In addition, JSONP introduces potential risk for
     * future security issues (e.g. content sniffing).  For more detail, see the
     * [Security Guide](http://g.co/ng/security).
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    Jsonp.prototype.request = function (url, options) {
        var /** @type {?} */ responseObservable;
        if (typeof url === 'string') {
            url =
                new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Get, /** @type {?} */ (url)));
        }
        if (url instanceof Request) {
            if (url.method !== RequestMethod.Get) {
                throw new Error('JSONP requests must use GET request method.');
            }
            responseObservable = httpRequest(this._backend, url);
        }
        else {
            throw new Error('First argument must be a url string or Request instance.');
        }
        return responseObservable;
    };
    return Jsonp;
}(Http));
Jsonp.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"] },
];
/**
 * @nocollapse
 */
Jsonp.ctorParameters = function () { return [
    { type: ConnectionBackend, },
    { type: RequestOptions, },
]; };
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @module
 * @description
 * The http module provides services to perform http requests. To get started, see the {@link Http}
 * class.
 */
/**
 * @return {?}
 */
function _createDefaultCookieXSRFStrategy() {
    return new CookieXSRFStrategy();
}
/**
 * @param {?} xhrBackend
 * @param {?} requestOptions
 * @return {?}
 */
function httpFactory(xhrBackend, requestOptions) {
    return new Http(xhrBackend, requestOptions);
}
/**
 * @param {?} jsonpBackend
 * @param {?} requestOptions
 * @return {?}
 */
function jsonpFactory(jsonpBackend, requestOptions) {
    return new Jsonp(jsonpBackend, requestOptions);
}
/**
 * The module that includes http's providers
 *
 * \@experimental
 */
var HttpModule = (function () {
    function HttpModule() {
    }
    return HttpModule;
}());
HttpModule.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["NgModule"], args: [{
                providers: [
                    // TODO(pascal): use factory type annotations once supported in DI
                    // issue: https://github.com/angular/angular/issues/3183
                    { provide: Http, useFactory: httpFactory, deps: [XHRBackend, RequestOptions] },
                    BrowserXhr,
                    { provide: RequestOptions, useClass: BaseRequestOptions },
                    { provide: ResponseOptions, useClass: BaseResponseOptions },
                    XHRBackend,
                    { provide: XSRFStrategy, useFactory: _createDefaultCookieXSRFStrategy },
                ],
            },] },
];
/**
 * @nocollapse
 */
HttpModule.ctorParameters = function () { return []; };
/**
 * The module that includes jsonp's providers
 *
 * \@experimental
 */
var JsonpModule = (function () {
    function JsonpModule() {
    }
    return JsonpModule;
}());
JsonpModule.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["NgModule"], args: [{
                providers: [
                    // TODO(pascal): use factory type annotations once supported in DI
                    // issue: https://github.com/angular/angular/issues/3183
                    { provide: Jsonp, useFactory: jsonpFactory, deps: [JSONPBackend, RequestOptions] },
                    BrowserJsonp,
                    { provide: RequestOptions, useClass: BaseRequestOptions },
                    { provide: ResponseOptions, useClass: BaseResponseOptions },
                    { provide: JSONPBackend, useClass: JSONPBackend_ },
                ],
            },] },
];
/**
 * @nocollapse
 */
JsonpModule.ctorParameters = function () { return []; };
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @module
 * @description
 * Entry point for all public APIs of the common package.
 */
/**
 * \@stable
 */
var VERSION = new __WEBPACK_IMPORTED_MODULE_1__angular_core__["Version"]('4.3.5');
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @module
 * @description
 * Entry point for all public APIs of the http package.
 */
// This file only reexports content of the `src` folder. Keep it that way.
/**
 * Generated bundle index. Do not edit.
 */

//# sourceMappingURL=http.es5.js.map


/***/ }),

/***/ "../../../platform-browser/@angular/platform-browser.es5.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BrowserModule", function() { return BrowserModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "platformBrowser", function() { return platformBrowser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Meta", function() { return Meta; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Title", function() { return Title; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "disableDebugTools", function() { return disableDebugTools; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enableDebugTools", function() { return enableDebugTools; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "By", function() { return By; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NgProbeToken", function() { return NgProbeToken$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DOCUMENT", function() { return DOCUMENT$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EVENT_MANAGER_PLUGINS", function() { return EVENT_MANAGER_PLUGINS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EventManager", function() { return EventManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HAMMER_GESTURE_CONFIG", function() { return HAMMER_GESTURE_CONFIG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HammerGestureConfig", function() { return HammerGestureConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DomSanitizer", function() { return DomSanitizer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return VERSION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵBROWSER_SANITIZATION_PROVIDERS", function() { return BROWSER_SANITIZATION_PROVIDERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵINTERNAL_BROWSER_PLATFORM_PROVIDERS", function() { return INTERNAL_BROWSER_PLATFORM_PROVIDERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵinitDomAdapter", function() { return initDomAdapter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵBrowserDomAdapter", function() { return BrowserDomAdapter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵBrowserPlatformLocation", function() { return BrowserPlatformLocation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵTRANSITION_ID", function() { return TRANSITION_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵBrowserGetTestability", function() { return BrowserGetTestability; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵELEMENT_PROBE_PROVIDERS", function() { return ELEMENT_PROBE_PROVIDERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵDomAdapter", function() { return DomAdapter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵgetDOM", function() { return getDOM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵsetRootDomAdapter", function() { return setRootDomAdapter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵDomRendererFactory2", function() { return DomRendererFactory2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵNAMESPACE_URIS", function() { return NAMESPACE_URIS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵflattenStyles", function() { return flattenStyles; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵshimContentAttribute", function() { return shimContentAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵshimHostAttribute", function() { return shimHostAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵDomEventsPlugin", function() { return DomEventsPlugin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵHammerGesturesPlugin", function() { return HammerGesturesPlugin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵKeyEventsPlugin", function() { return KeyEventsPlugin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵDomSharedStylesHost", function() { return DomSharedStylesHost; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵSharedStylesHost", function() { return SharedStylesHost; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵb", function() { return _document; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵa", function() { return errorHandler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵh", function() { return GenericBrowserDomAdapter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵg", function() { return SERVER_TRANSITION_PROVIDERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵf", function() { return appInitializerFactory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵc", function() { return _createNgProbe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵd", function() { return EventManagerPlugin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵe", function() { return DomSanitizerImpl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__("../../../../tslib/tslib.es6.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common__ = __webpack_require__("../../../common/@angular/common.es5.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__("../../../core/@angular/core.es5.js");

/**
 * @license Angular v4.3.5
 * (c) 2010-2017 Google, Inc. https://angular.io/
 * License: MIT
 */


/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var _DOM = ((null));
/**
 * @return {?}
 */
function getDOM() {
    return _DOM;
}
/**
 * @param {?} adapter
 * @return {?}
 */
/**
 * @param {?} adapter
 * @return {?}
 */
function setRootDomAdapter(adapter) {
    if (!_DOM) {
        _DOM = adapter;
    }
}
/**
 * Provides DOM operations in an environment-agnostic way.
 *
 * \@security Tread carefully! Interacting with the DOM directly is dangerous and
 * can introduce XSS risks.
 * @abstract
 */
var DomAdapter = (function () {
    function DomAdapter() {
        this.resourceLoaderType = ((null));
    }
    /**
     * @abstract
     * @param {?} element
     * @param {?} name
     * @return {?}
     */
    DomAdapter.prototype.hasProperty = function (element, name) { };
    /**
     * @abstract
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    DomAdapter.prototype.setProperty = function (el, name, value) { };
    /**
     * @abstract
     * @param {?} el
     * @param {?} name
     * @return {?}
     */
    DomAdapter.prototype.getProperty = function (el, name) { };
    /**
     * @abstract
     * @param {?} el
     * @param {?} methodName
     * @param {?} args
     * @return {?}
     */
    DomAdapter.prototype.invoke = function (el, methodName, args) { };
    /**
     * @abstract
     * @param {?} error
     * @return {?}
     */
    DomAdapter.prototype.logError = function (error) { };
    /**
     * @abstract
     * @param {?} error
     * @return {?}
     */
    DomAdapter.prototype.log = function (error) { };
    /**
     * @abstract
     * @param {?} error
     * @return {?}
     */
    DomAdapter.prototype.logGroup = function (error) { };
    /**
     * @abstract
     * @return {?}
     */
    DomAdapter.prototype.logGroupEnd = function () { };
    Object.defineProperty(DomAdapter.prototype, "attrToPropMap", {
        /**
         * Maps attribute names to their corresponding property names for cases
         * where attribute name doesn't match property name.
         * @return {?}
         */
        get: function () { return this._attrToPropMap; },
        /**
         * @param {?} value
         * @return {?}
         */
        set: function (value) { this._attrToPropMap = value; },
        enumerable: true,
        configurable: true
    });
    ;
    ;
    /**
     * @abstract
     * @param {?} nodeA
     * @param {?} nodeB
     * @return {?}
     */
    DomAdapter.prototype.contains = function (nodeA, nodeB) { };
    /**
     * @abstract
     * @param {?} templateHtml
     * @return {?}
     */
    DomAdapter.prototype.parse = function (templateHtml) { };
    /**
     * @abstract
     * @param {?} el
     * @param {?} selector
     * @return {?}
     */
    DomAdapter.prototype.querySelector = function (el, selector) { };
    /**
     * @abstract
     * @param {?} el
     * @param {?} selector
     * @return {?}
     */
    DomAdapter.prototype.querySelectorAll = function (el, selector) { };
    /**
     * @abstract
     * @param {?} el
     * @param {?} evt
     * @param {?} listener
     * @return {?}
     */
    DomAdapter.prototype.on = function (el, evt, listener) { };
    /**
     * @abstract
     * @param {?} el
     * @param {?} evt
     * @param {?} listener
     * @return {?}
     */
    DomAdapter.prototype.onAndCancel = function (el, evt, listener) { };
    /**
     * @abstract
     * @param {?} el
     * @param {?} evt
     * @return {?}
     */
    DomAdapter.prototype.dispatchEvent = function (el, evt) { };
    /**
     * @abstract
     * @param {?} eventType
     * @return {?}
     */
    DomAdapter.prototype.createMouseEvent = function (eventType) { };
    /**
     * @abstract
     * @param {?} eventType
     * @return {?}
     */
    DomAdapter.prototype.createEvent = function (eventType) { };
    /**
     * @abstract
     * @param {?} evt
     * @return {?}
     */
    DomAdapter.prototype.preventDefault = function (evt) { };
    /**
     * @abstract
     * @param {?} evt
     * @return {?}
     */
    DomAdapter.prototype.isPrevented = function (evt) { };
    /**
     * @abstract
     * @param {?} el
     * @return {?}
     */
    DomAdapter.prototype.getInnerHTML = function (el) { };
    /**
     * Returns content if el is a <template> element, null otherwise.
     * @abstract
     * @param {?} el
     * @return {?}
     */
    DomAdapter.prototype.getTemplateContent = function (el) { };
    /**
     * @abstract
     * @param {?} el
     * @return {?}
     */
    DomAdapter.prototype.getOuterHTML = function (el) { };
    /**
     * @abstract
     * @param {?} node
     * @return {?}
     */
    DomAdapter.prototype.nodeName = function (node) { };
    /**
     * @abstract
     * @param {?} node
     * @return {?}
     */
    DomAdapter.prototype.nodeValue = function (node) { };
    /**
     * @abstract
     * @param {?} node
     * @return {?}
     */
    DomAdapter.prototype.type = function (node) { };
    /**
     * @abstract
     * @param {?} node
     * @return {?}
     */
    DomAdapter.prototype.content = function (node) { };
    /**
     * @abstract
     * @param {?} el
     * @return {?}
     */
    DomAdapter.prototype.firstChild = function (el) { };
    /**
     * @abstract
     * @param {?} el
     * @return {?}
     */
    DomAdapter.prototype.nextSibling = function (el) { };
    /**
     * @abstract
     * @param {?} el
     * @return {?}
     */
    DomAdapter.prototype.parentElement = function (el) { };
    /**
     * @abstract
     * @param {?} el
     * @return {?}
     */
    DomAdapter.prototype.childNodes = function (el) { };
    /**
     * @abstract
     * @param {?} el
     * @return {?}
     */
    DomAdapter.prototype.childNodesAsList = function (el) { };
    /**
     * @abstract
     * @param {?} el
     * @return {?}
     */
    DomAdapter.prototype.clearNodes = function (el) { };
    /**
     * @abstract
     * @param {?} el
     * @param {?} node
     * @return {?}
     */
    DomAdapter.prototype.appendChild = function (el, node) { };
    /**
     * @abstract
     * @param {?} el
     * @param {?} node
     * @return {?}
     */
    DomAdapter.prototype.removeChild = function (el, node) { };
    /**
     * @abstract
     * @param {?} el
     * @param {?} newNode
     * @param {?} oldNode
     * @return {?}
     */
    DomAdapter.prototype.replaceChild = function (el, newNode, oldNode) { };
    /**
     * @abstract
     * @param {?} el
     * @return {?}
     */
    DomAdapter.prototype.remove = function (el) { };
    /**
     * @abstract
     * @param {?} parent
     * @param {?} ref
     * @param {?} node
     * @return {?}
     */
    DomAdapter.prototype.insertBefore = function (parent, ref, node) { };
    /**
     * @abstract
     * @param {?} parent
     * @param {?} ref
     * @param {?} nodes
     * @return {?}
     */
    DomAdapter.prototype.insertAllBefore = function (parent, ref, nodes) { };
    /**
     * @abstract
     * @param {?} parent
     * @param {?} el
     * @param {?} node
     * @return {?}
     */
    DomAdapter.prototype.insertAfter = function (parent, el, node) { };
    /**
     * @abstract
     * @param {?} el
     * @param {?} value
     * @return {?}
     */
    DomAdapter.prototype.setInnerHTML = function (el, value) { };
    /**
     * @abstract
     * @param {?} el
     * @return {?}
     */
    DomAdapter.prototype.getText = function (el) { };
    /**
     * @abstract
     * @param {?} el
     * @param {?} value
     * @return {?}
     */
    DomAdapter.prototype.setText = function (el, value) { };
    /**
     * @abstract
     * @param {?} el
     * @return {?}
     */
    DomAdapter.prototype.getValue = function (el) { };
    /**
     * @abstract
     * @param {?} el
     * @param {?} value
     * @return {?}
     */
    DomAdapter.prototype.setValue = function (el, value) { };
    /**
     * @abstract
     * @param {?} el
     * @return {?}
     */
    DomAdapter.prototype.getChecked = function (el) { };
    /**
     * @abstract
     * @param {?} el
     * @param {?} value
     * @return {?}
     */
    DomAdapter.prototype.setChecked = function (el, value) { };
    /**
     * @abstract
     * @param {?} text
     * @return {?}
     */
    DomAdapter.prototype.createComment = function (text) { };
    /**
     * @abstract
     * @param {?} html
     * @return {?}
     */
    DomAdapter.prototype.createTemplate = function (html) { };
    /**
     * @abstract
     * @param {?} tagName
     * @param {?=} doc
     * @return {?}
     */
    DomAdapter.prototype.createElement = function (tagName, doc) { };
    /**
     * @abstract
     * @param {?} ns
     * @param {?} tagName
     * @param {?=} doc
     * @return {?}
     */
    DomAdapter.prototype.createElementNS = function (ns, tagName, doc) { };
    /**
     * @abstract
     * @param {?} text
     * @param {?=} doc
     * @return {?}
     */
    DomAdapter.prototype.createTextNode = function (text, doc) { };
    /**
     * @abstract
     * @param {?} attrName
     * @param {?} attrValue
     * @param {?=} doc
     * @return {?}
     */
    DomAdapter.prototype.createScriptTag = function (attrName, attrValue, doc) { };
    /**
     * @abstract
     * @param {?} css
     * @param {?=} doc
     * @return {?}
     */
    DomAdapter.prototype.createStyleElement = function (css, doc) { };
    /**
     * @abstract
     * @param {?} el
     * @return {?}
     */
    DomAdapter.prototype.createShadowRoot = function (el) { };
    /**
     * @abstract
     * @param {?} el
     * @return {?}
     */
    DomAdapter.prototype.getShadowRoot = function (el) { };
    /**
     * @abstract
     * @param {?} el
     * @return {?}
     */
    DomAdapter.prototype.getHost = function (el) { };
    /**
     * @abstract
     * @param {?} el
     * @return {?}
     */
    DomAdapter.prototype.getDistributedNodes = function (el) { };
    /**
     * @abstract
     * @param {?} node
     * @return {?}
     */
    DomAdapter.prototype.clone /*<T extends Node>*/ = function (node) { };
    /**
     * @abstract
     * @param {?} element
     * @param {?} name
     * @return {?}
     */
    DomAdapter.prototype.getElementsByClassName = function (element, name) { };
    /**
     * @abstract
     * @param {?} element
     * @param {?} name
     * @return {?}
     */
    DomAdapter.prototype.getElementsByTagName = function (element, name) { };
    /**
     * @abstract
     * @param {?} element
     * @return {?}
     */
    DomAdapter.prototype.classList = function (element) { };
    /**
     * @abstract
     * @param {?} element
     * @param {?} className
     * @return {?}
     */
    DomAdapter.prototype.addClass = function (element, className) { };
    /**
     * @abstract
     * @param {?} element
     * @param {?} className
     * @return {?}
     */
    DomAdapter.prototype.removeClass = function (element, className) { };
    /**
     * @abstract
     * @param {?} element
     * @param {?} className
     * @return {?}
     */
    DomAdapter.prototype.hasClass = function (element, className) { };
    /**
     * @abstract
     * @param {?} element
     * @param {?} styleName
     * @param {?} styleValue
     * @return {?}
     */
    DomAdapter.prototype.setStyle = function (element, styleName, styleValue) { };
    /**
     * @abstract
     * @param {?} element
     * @param {?} styleName
     * @return {?}
     */
    DomAdapter.prototype.removeStyle = function (element, styleName) { };
    /**
     * @abstract
     * @param {?} element
     * @param {?} styleName
     * @return {?}
     */
    DomAdapter.prototype.getStyle = function (element, styleName) { };
    /**
     * @abstract
     * @param {?} element
     * @param {?} styleName
     * @param {?=} styleValue
     * @return {?}
     */
    DomAdapter.prototype.hasStyle = function (element, styleName, styleValue) { };
    /**
     * @abstract
     * @param {?} element
     * @return {?}
     */
    DomAdapter.prototype.tagName = function (element) { };
    /**
     * @abstract
     * @param {?} element
     * @return {?}
     */
    DomAdapter.prototype.attributeMap = function (element) { };
    /**
     * @abstract
     * @param {?} element
     * @param {?} attribute
     * @return {?}
     */
    DomAdapter.prototype.hasAttribute = function (element, attribute) { };
    /**
     * @abstract
     * @param {?} element
     * @param {?} ns
     * @param {?} attribute
     * @return {?}
     */
    DomAdapter.prototype.hasAttributeNS = function (element, ns, attribute) { };
    /**
     * @abstract
     * @param {?} element
     * @param {?} attribute
     * @return {?}
     */
    DomAdapter.prototype.getAttribute = function (element, attribute) { };
    /**
     * @abstract
     * @param {?} element
     * @param {?} ns
     * @param {?} attribute
     * @return {?}
     */
    DomAdapter.prototype.getAttributeNS = function (element, ns, attribute) { };
    /**
     * @abstract
     * @param {?} element
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    DomAdapter.prototype.setAttribute = function (element, name, value) { };
    /**
     * @abstract
     * @param {?} element
     * @param {?} ns
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    DomAdapter.prototype.setAttributeNS = function (element, ns, name, value) { };
    /**
     * @abstract
     * @param {?} element
     * @param {?} attribute
     * @return {?}
     */
    DomAdapter.prototype.removeAttribute = function (element, attribute) { };
    /**
     * @abstract
     * @param {?} element
     * @param {?} ns
     * @param {?} attribute
     * @return {?}
     */
    DomAdapter.prototype.removeAttributeNS = function (element, ns, attribute) { };
    /**
     * @abstract
     * @param {?} el
     * @return {?}
     */
    DomAdapter.prototype.templateAwareRoot = function (el) { };
    /**
     * @abstract
     * @return {?}
     */
    DomAdapter.prototype.createHtmlDocument = function () { };
    /**
     * @abstract
     * @param {?} el
     * @return {?}
     */
    DomAdapter.prototype.getBoundingClientRect = function (el) { };
    /**
     * @abstract
     * @param {?} doc
     * @return {?}
     */
    DomAdapter.prototype.getTitle = function (doc) { };
    /**
     * @abstract
     * @param {?} doc
     * @param {?} newTitle
     * @return {?}
     */
    DomAdapter.prototype.setTitle = function (doc, newTitle) { };
    /**
     * @abstract
     * @param {?} n
     * @param {?} selector
     * @return {?}
     */
    DomAdapter.prototype.elementMatches = function (n, selector) { };
    /**
     * @abstract
     * @param {?} el
     * @return {?}
     */
    DomAdapter.prototype.isTemplateElement = function (el) { };
    /**
     * @abstract
     * @param {?} node
     * @return {?}
     */
    DomAdapter.prototype.isTextNode = function (node) { };
    /**
     * @abstract
     * @param {?} node
     * @return {?}
     */
    DomAdapter.prototype.isCommentNode = function (node) { };
    /**
     * @abstract
     * @param {?} node
     * @return {?}
     */
    DomAdapter.prototype.isElementNode = function (node) { };
    /**
     * @abstract
     * @param {?} node
     * @return {?}
     */
    DomAdapter.prototype.hasShadowRoot = function (node) { };
    /**
     * @abstract
     * @param {?} node
     * @return {?}
     */
    DomAdapter.prototype.isShadowRoot = function (node) { };
    /**
     * @abstract
     * @param {?} node
     * @return {?}
     */
    DomAdapter.prototype.importIntoDoc /*<T extends Node>*/ = function (node) { };
    /**
     * @abstract
     * @param {?} node
     * @return {?}
     */
    DomAdapter.prototype.adoptNode /*<T extends Node>*/ = function (node) { };
    /**
     * @abstract
     * @param {?} element
     * @return {?}
     */
    DomAdapter.prototype.getHref = function (element) { };
    /**
     * @abstract
     * @param {?} event
     * @return {?}
     */
    DomAdapter.prototype.getEventKey = function (event) { };
    /**
     * @abstract
     * @param {?} element
     * @param {?} baseUrl
     * @param {?} href
     * @return {?}
     */
    DomAdapter.prototype.resolveAndSetHref = function (element, baseUrl, href) { };
    /**
     * @abstract
     * @return {?}
     */
    DomAdapter.prototype.supportsDOMEvents = function () { };
    /**
     * @abstract
     * @return {?}
     */
    DomAdapter.prototype.supportsNativeShadowDOM = function () { };
    /**
     * @abstract
     * @param {?} doc
     * @param {?} target
     * @return {?}
     */
    DomAdapter.prototype.getGlobalEventTarget = function (doc, target) { };
    /**
     * @abstract
     * @return {?}
     */
    DomAdapter.prototype.getHistory = function () { };
    /**
     * @abstract
     * @return {?}
     */
    DomAdapter.prototype.getLocation = function () { };
    /**
     * @abstract
     * @param {?} doc
     * @return {?}
     */
    DomAdapter.prototype.getBaseHref = function (doc) { };
    /**
     * @abstract
     * @return {?}
     */
    DomAdapter.prototype.resetBaseElement = function () { };
    /**
     * @abstract
     * @return {?}
     */
    DomAdapter.prototype.getUserAgent = function () { };
    /**
     * @abstract
     * @param {?} element
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    DomAdapter.prototype.setData = function (element, name, value) { };
    /**
     * @abstract
     * @param {?} element
     * @return {?}
     */
    DomAdapter.prototype.getComputedStyle = function (element) { };
    /**
     * @abstract
     * @param {?} element
     * @param {?} name
     * @return {?}
     */
    DomAdapter.prototype.getData = function (element, name) { };
    /**
     * @abstract
     * @return {?}
     */
    DomAdapter.prototype.supportsWebAnimation = function () { };
    /**
     * @abstract
     * @return {?}
     */
    DomAdapter.prototype.performanceNow = function () { };
    /**
     * @abstract
     * @return {?}
     */
    DomAdapter.prototype.getAnimationPrefix = function () { };
    /**
     * @abstract
     * @return {?}
     */
    DomAdapter.prototype.getTransitionEnd = function () { };
    /**
     * @abstract
     * @return {?}
     */
    DomAdapter.prototype.supportsAnimation = function () { };
    /**
     * @abstract
     * @return {?}
     */
    DomAdapter.prototype.supportsCookies = function () { };
    /**
     * @abstract
     * @param {?} name
     * @return {?}
     */
    DomAdapter.prototype.getCookie = function (name) { };
    /**
     * @abstract
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    DomAdapter.prototype.setCookie = function (name, value) { };
    return DomAdapter;
}());
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Provides DOM operations in any browser environment.
 *
 * \@security Tread carefully! Interacting with the DOM directly is dangerous and
 * can introduce XSS risks.
 * @abstract
 */
var GenericBrowserDomAdapter = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](GenericBrowserDomAdapter, _super);
    function GenericBrowserDomAdapter() {
        var _this = _super.call(this) || this;
        _this._animationPrefix = null;
        _this._transitionEnd = null;
        try {
            var element_1 = _this.createElement('div', document);
            if (_this.getStyle(element_1, 'animationName') != null) {
                _this._animationPrefix = '';
            }
            else {
                var domPrefixes = ['Webkit', 'Moz', 'O', 'ms'];
                for (var i = 0; i < domPrefixes.length; i++) {
                    if (_this.getStyle(element_1, domPrefixes[i] + 'AnimationName') != null) {
                        _this._animationPrefix = '-' + domPrefixes[i].toLowerCase() + '-';
                        break;
                    }
                }
            }
            var transEndEventNames_1 = {
                WebkitTransition: 'webkitTransitionEnd',
                MozTransition: 'transitionend',
                OTransition: 'oTransitionEnd otransitionend',
                transition: 'transitionend'
            };
            Object.keys(transEndEventNames_1).forEach(function (key) {
                if (_this.getStyle(element_1, key) != null) {
                    _this._transitionEnd = transEndEventNames_1[key];
                }
            });
        }
        catch (e) {
            _this._animationPrefix = null;
            _this._transitionEnd = null;
        }
        return _this;
    }
    /**
     * @param {?} el
     * @return {?}
     */
    GenericBrowserDomAdapter.prototype.getDistributedNodes = function (el) { return ((el)).getDistributedNodes(); };
    /**
     * @param {?} el
     * @param {?} baseUrl
     * @param {?} href
     * @return {?}
     */
    GenericBrowserDomAdapter.prototype.resolveAndSetHref = function (el, baseUrl, href) {
        el.href = href == null ? baseUrl : baseUrl + '/../' + href;
    };
    /**
     * @return {?}
     */
    GenericBrowserDomAdapter.prototype.supportsDOMEvents = function () { return true; };
    /**
     * @return {?}
     */
    GenericBrowserDomAdapter.prototype.supportsNativeShadowDOM = function () {
        return typeof ((document.body)).createShadowRoot === 'function';
    };
    /**
     * @return {?}
     */
    GenericBrowserDomAdapter.prototype.getAnimationPrefix = function () { return this._animationPrefix ? this._animationPrefix : ''; };
    /**
     * @return {?}
     */
    GenericBrowserDomAdapter.prototype.getTransitionEnd = function () { return this._transitionEnd ? this._transitionEnd : ''; };
    /**
     * @return {?}
     */
    GenericBrowserDomAdapter.prototype.supportsAnimation = function () {
        return this._animationPrefix != null && this._transitionEnd != null;
    };
    return GenericBrowserDomAdapter;
}(DomAdapter));
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var _attrToPropMap = {
    'class': 'className',
    'innerHtml': 'innerHTML',
    'readonly': 'readOnly',
    'tabindex': 'tabIndex',
};
var DOM_KEY_LOCATION_NUMPAD = 3;
// Map to convert some key or keyIdentifier values to what will be returned by getEventKey
var _keyMap = {
    // The following values are here for cross-browser compatibility and to match the W3C standard
    // cf http://www.w3.org/TR/DOM-Level-3-Events-key/
    '\b': 'Backspace',
    '\t': 'Tab',
    '\x7F': 'Delete',
    '\x1B': 'Escape',
    'Del': 'Delete',
    'Esc': 'Escape',
    'Left': 'ArrowLeft',
    'Right': 'ArrowRight',
    'Up': 'ArrowUp',
    'Down': 'ArrowDown',
    'Menu': 'ContextMenu',
    'Scroll': 'ScrollLock',
    'Win': 'OS'
};
// There is a bug in Chrome for numeric keypad keys:
// https://code.google.com/p/chromium/issues/detail?id=155654
// 1, 2, 3 ... are reported as A, B, C ...
var _chromeNumKeyPadMap = {
    'A': '1',
    'B': '2',
    'C': '3',
    'D': '4',
    'E': '5',
    'F': '6',
    'G': '7',
    'H': '8',
    'I': '9',
    'J': '*',
    'K': '+',
    'M': '-',
    'N': '.',
    'O': '/',
    '\x60': '0',
    '\x90': 'NumLock'
};
var nodeContains;
if (__WEBPACK_IMPORTED_MODULE_2__angular_core__["ɵglobal"]['Node']) {
    nodeContains = __WEBPACK_IMPORTED_MODULE_2__angular_core__["ɵglobal"]['Node'].prototype.contains || function (node) {
        return !!(this.compareDocumentPosition(node) & 16);
    };
}
var BrowserDomAdapter = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](BrowserDomAdapter, _super);
    function BrowserDomAdapter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @param {?} templateHtml
     * @return {?}
     */
    BrowserDomAdapter.prototype.parse = function (templateHtml) { throw new Error('parse not implemented'); };
    /**
     * @return {?}
     */
    BrowserDomAdapter.makeCurrent = function () { setRootDomAdapter(new BrowserDomAdapter()); };
    /**
     * @param {?} element
     * @param {?} name
     * @return {?}
     */
    BrowserDomAdapter.prototype.hasProperty = function (element, name) { return name in element; };
    /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    BrowserDomAdapter.prototype.setProperty = function (el, name, value) { ((el))[name] = value; };
    /**
     * @param {?} el
     * @param {?} name
     * @return {?}
     */
    BrowserDomAdapter.prototype.getProperty = function (el, name) { return ((el))[name]; };
    /**
     * @param {?} el
     * @param {?} methodName
     * @param {?} args
     * @return {?}
     */
    BrowserDomAdapter.prototype.invoke = function (el, methodName, args) { ((el))[methodName].apply(((el)), args); };
    /**
     * @param {?} error
     * @return {?}
     */
    BrowserDomAdapter.prototype.logError = function (error) {
        if (window.console) {
            if (console.error) {
                console.error(error);
            }
            else {
                console.log(error);
            }
        }
    };
    /**
     * @param {?} error
     * @return {?}
     */
    BrowserDomAdapter.prototype.log = function (error) {
        if (window.console) {
            window.console.log && window.console.log(error);
        }
    };
    /**
     * @param {?} error
     * @return {?}
     */
    BrowserDomAdapter.prototype.logGroup = function (error) {
        if (window.console) {
            window.console.group && window.console.group(error);
        }
    };
    /**
     * @return {?}
     */
    BrowserDomAdapter.prototype.logGroupEnd = function () {
        if (window.console) {
            window.console.groupEnd && window.console.groupEnd();
        }
    };
    Object.defineProperty(BrowserDomAdapter.prototype, "attrToPropMap", {
        /**
         * @return {?}
         */
        get: function () { return _attrToPropMap; },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} nodeA
     * @param {?} nodeB
     * @return {?}
     */
    BrowserDomAdapter.prototype.contains = function (nodeA, nodeB) { return nodeContains.call(nodeA, nodeB); };
    /**
     * @param {?} el
     * @param {?} selector
     * @return {?}
     */
    BrowserDomAdapter.prototype.querySelector = function (el, selector) { return el.querySelector(selector); };
    /**
     * @param {?} el
     * @param {?} selector
     * @return {?}
     */
    BrowserDomAdapter.prototype.querySelectorAll = function (el, selector) { return el.querySelectorAll(selector); };
    /**
     * @param {?} el
     * @param {?} evt
     * @param {?} listener
     * @return {?}
     */
    BrowserDomAdapter.prototype.on = function (el, evt, listener) { el.addEventListener(evt, listener, false); };
    /**
     * @param {?} el
     * @param {?} evt
     * @param {?} listener
     * @return {?}
     */
    BrowserDomAdapter.prototype.onAndCancel = function (el, evt, listener) {
        el.addEventListener(evt, listener, false);
        // Needed to follow Dart's subscription semantic, until fix of
        // https://code.google.com/p/dart/issues/detail?id=17406
        return function () { el.removeEventListener(evt, listener, false); };
    };
    /**
     * @param {?} el
     * @param {?} evt
     * @return {?}
     */
    BrowserDomAdapter.prototype.dispatchEvent = function (el, evt) { el.dispatchEvent(evt); };
    /**
     * @param {?} eventType
     * @return {?}
     */
    BrowserDomAdapter.prototype.createMouseEvent = function (eventType) {
        var /** @type {?} */ evt = document.createEvent('MouseEvent');
        evt.initEvent(eventType, true, true);
        return evt;
    };
    /**
     * @param {?} eventType
     * @return {?}
     */
    BrowserDomAdapter.prototype.createEvent = function (eventType) {
        var /** @type {?} */ evt = document.createEvent('Event');
        evt.initEvent(eventType, true, true);
        return evt;
    };
    /**
     * @param {?} evt
     * @return {?}
     */
    BrowserDomAdapter.prototype.preventDefault = function (evt) {
        evt.preventDefault();
        evt.returnValue = false;
    };
    /**
     * @param {?} evt
     * @return {?}
     */
    BrowserDomAdapter.prototype.isPrevented = function (evt) {
        return evt.defaultPrevented || evt.returnValue != null && !evt.returnValue;
    };
    /**
     * @param {?} el
     * @return {?}
     */
    BrowserDomAdapter.prototype.getInnerHTML = function (el) { return el.innerHTML; };
    /**
     * @param {?} el
     * @return {?}
     */
    BrowserDomAdapter.prototype.getTemplateContent = function (el) {
        return 'content' in el && el instanceof HTMLTemplateElement ? el.content : null;
    };
    /**
     * @param {?} el
     * @return {?}
     */
    BrowserDomAdapter.prototype.getOuterHTML = function (el) { return el.outerHTML; };
    /**
     * @param {?} node
     * @return {?}
     */
    BrowserDomAdapter.prototype.nodeName = function (node) { return node.nodeName; };
    /**
     * @param {?} node
     * @return {?}
     */
    BrowserDomAdapter.prototype.nodeValue = function (node) { return node.nodeValue; };
    /**
     * @param {?} node
     * @return {?}
     */
    BrowserDomAdapter.prototype.type = function (node) { return node.type; };
    /**
     * @param {?} node
     * @return {?}
     */
    BrowserDomAdapter.prototype.content = function (node) {
        if (this.hasProperty(node, 'content')) {
            return ((node)).content;
        }
        else {
            return node;
        }
    };
    /**
     * @param {?} el
     * @return {?}
     */
    BrowserDomAdapter.prototype.firstChild = function (el) { return el.firstChild; };
    /**
     * @param {?} el
     * @return {?}
     */
    BrowserDomAdapter.prototype.nextSibling = function (el) { return el.nextSibling; };
    /**
     * @param {?} el
     * @return {?}
     */
    BrowserDomAdapter.prototype.parentElement = function (el) { return el.parentNode; };
    /**
     * @param {?} el
     * @return {?}
     */
    BrowserDomAdapter.prototype.childNodes = function (el) { return el.childNodes; };
    /**
     * @param {?} el
     * @return {?}
     */
    BrowserDomAdapter.prototype.childNodesAsList = function (el) {
        var /** @type {?} */ childNodes = el.childNodes;
        var /** @type {?} */ res = new Array(childNodes.length);
        for (var /** @type {?} */ i = 0; i < childNodes.length; i++) {
            res[i] = childNodes[i];
        }
        return res;
    };
    /**
     * @param {?} el
     * @return {?}
     */
    BrowserDomAdapter.prototype.clearNodes = function (el) {
        while (el.firstChild) {
            el.removeChild(el.firstChild);
        }
    };
    /**
     * @param {?} el
     * @param {?} node
     * @return {?}
     */
    BrowserDomAdapter.prototype.appendChild = function (el, node) { el.appendChild(node); };
    /**
     * @param {?} el
     * @param {?} node
     * @return {?}
     */
    BrowserDomAdapter.prototype.removeChild = function (el, node) { el.removeChild(node); };
    /**
     * @param {?} el
     * @param {?} newChild
     * @param {?} oldChild
     * @return {?}
     */
    BrowserDomAdapter.prototype.replaceChild = function (el, newChild, oldChild) { el.replaceChild(newChild, oldChild); };
    /**
     * @param {?} node
     * @return {?}
     */
    BrowserDomAdapter.prototype.remove = function (node) {
        if (node.parentNode) {
            node.parentNode.removeChild(node);
        }
        return node;
    };
    /**
     * @param {?} parent
     * @param {?} ref
     * @param {?} node
     * @return {?}
     */
    BrowserDomAdapter.prototype.insertBefore = function (parent, ref, node) { parent.insertBefore(node, ref); };
    /**
     * @param {?} parent
     * @param {?} ref
     * @param {?} nodes
     * @return {?}
     */
    BrowserDomAdapter.prototype.insertAllBefore = function (parent, ref, nodes) {
        nodes.forEach(function (n) { return parent.insertBefore(n, ref); });
    };
    /**
     * @param {?} parent
     * @param {?} ref
     * @param {?} node
     * @return {?}
     */
    BrowserDomAdapter.prototype.insertAfter = function (parent, ref, node) { parent.insertBefore(node, ref.nextSibling); };
    /**
     * @param {?} el
     * @param {?} value
     * @return {?}
     */
    BrowserDomAdapter.prototype.setInnerHTML = function (el, value) { el.innerHTML = value; };
    /**
     * @param {?} el
     * @return {?}
     */
    BrowserDomAdapter.prototype.getText = function (el) { return el.textContent; };
    /**
     * @param {?} el
     * @param {?} value
     * @return {?}
     */
    BrowserDomAdapter.prototype.setText = function (el, value) { el.textContent = value; };
    /**
     * @param {?} el
     * @return {?}
     */
    BrowserDomAdapter.prototype.getValue = function (el) { return el.value; };
    /**
     * @param {?} el
     * @param {?} value
     * @return {?}
     */
    BrowserDomAdapter.prototype.setValue = function (el, value) { el.value = value; };
    /**
     * @param {?} el
     * @return {?}
     */
    BrowserDomAdapter.prototype.getChecked = function (el) { return el.checked; };
    /**
     * @param {?} el
     * @param {?} value
     * @return {?}
     */
    BrowserDomAdapter.prototype.setChecked = function (el, value) { el.checked = value; };
    /**
     * @param {?} text
     * @return {?}
     */
    BrowserDomAdapter.prototype.createComment = function (text) { return document.createComment(text); };
    /**
     * @param {?} html
     * @return {?}
     */
    BrowserDomAdapter.prototype.createTemplate = function (html) {
        var /** @type {?} */ t = document.createElement('template');
        t.innerHTML = html;
        return t;
    };
    /**
     * @param {?} tagName
     * @param {?=} doc
     * @return {?}
     */
    BrowserDomAdapter.prototype.createElement = function (tagName, doc) {
        if (doc === void 0) { doc = document; }
        return doc.createElement(tagName);
    };
    /**
     * @param {?} ns
     * @param {?} tagName
     * @param {?=} doc
     * @return {?}
     */
    BrowserDomAdapter.prototype.createElementNS = function (ns, tagName, doc) {
        if (doc === void 0) { doc = document; }
        return doc.createElementNS(ns, tagName);
    };
    /**
     * @param {?} text
     * @param {?=} doc
     * @return {?}
     */
    BrowserDomAdapter.prototype.createTextNode = function (text, doc) {
        if (doc === void 0) { doc = document; }
        return doc.createTextNode(text);
    };
    /**
     * @param {?} attrName
     * @param {?} attrValue
     * @param {?=} doc
     * @return {?}
     */
    BrowserDomAdapter.prototype.createScriptTag = function (attrName, attrValue, doc) {
        if (doc === void 0) { doc = document; }
        var /** @type {?} */ el = (doc.createElement('SCRIPT'));
        el.setAttribute(attrName, attrValue);
        return el;
    };
    /**
     * @param {?} css
     * @param {?=} doc
     * @return {?}
     */
    BrowserDomAdapter.prototype.createStyleElement = function (css, doc) {
        if (doc === void 0) { doc = document; }
        var /** @type {?} */ style = (doc.createElement('style'));
        this.appendChild(style, this.createTextNode(css));
        return style;
    };
    /**
     * @param {?} el
     * @return {?}
     */
    BrowserDomAdapter.prototype.createShadowRoot = function (el) { return ((el)).createShadowRoot(); };
    /**
     * @param {?} el
     * @return {?}
     */
    BrowserDomAdapter.prototype.getShadowRoot = function (el) { return ((el)).shadowRoot; };
    /**
     * @param {?} el
     * @return {?}
     */
    BrowserDomAdapter.prototype.getHost = function (el) { return ((el)).host; };
    /**
     * @param {?} node
     * @return {?}
     */
    BrowserDomAdapter.prototype.clone = function (node) { return node.cloneNode(true); };
    /**
     * @param {?} element
     * @param {?} name
     * @return {?}
     */
    BrowserDomAdapter.prototype.getElementsByClassName = function (element, name) {
        return element.getElementsByClassName(name);
    };
    /**
     * @param {?} element
     * @param {?} name
     * @return {?}
     */
    BrowserDomAdapter.prototype.getElementsByTagName = function (element, name) {
        return element.getElementsByTagName(name);
    };
    /**
     * @param {?} element
     * @return {?}
     */
    BrowserDomAdapter.prototype.classList = function (element) { return Array.prototype.slice.call(element.classList, 0); };
    /**
     * @param {?} element
     * @param {?} className
     * @return {?}
     */
    BrowserDomAdapter.prototype.addClass = function (element, className) { element.classList.add(className); };
    /**
     * @param {?} element
     * @param {?} className
     * @return {?}
     */
    BrowserDomAdapter.prototype.removeClass = function (element, className) { element.classList.remove(className); };
    /**
     * @param {?} element
     * @param {?} className
     * @return {?}
     */
    BrowserDomAdapter.prototype.hasClass = function (element, className) {
        return element.classList.contains(className);
    };
    /**
     * @param {?} element
     * @param {?} styleName
     * @param {?} styleValue
     * @return {?}
     */
    BrowserDomAdapter.prototype.setStyle = function (element, styleName, styleValue) {
        element.style[styleName] = styleValue;
    };
    /**
     * @param {?} element
     * @param {?} stylename
     * @return {?}
     */
    BrowserDomAdapter.prototype.removeStyle = function (element, stylename) {
        // IE requires '' instead of null
        // see https://github.com/angular/angular/issues/7916
        element.style[stylename] = '';
    };
    /**
     * @param {?} element
     * @param {?} stylename
     * @return {?}
     */
    BrowserDomAdapter.prototype.getStyle = function (element, stylename) { return element.style[stylename]; };
    /**
     * @param {?} element
     * @param {?} styleName
     * @param {?=} styleValue
     * @return {?}
     */
    BrowserDomAdapter.prototype.hasStyle = function (element, styleName, styleValue) {
        var /** @type {?} */ value = this.getStyle(element, styleName) || '';
        return styleValue ? value == styleValue : value.length > 0;
    };
    /**
     * @param {?} element
     * @return {?}
     */
    BrowserDomAdapter.prototype.tagName = function (element) { return element.tagName; };
    /**
     * @param {?} element
     * @return {?}
     */
    BrowserDomAdapter.prototype.attributeMap = function (element) {
        var /** @type {?} */ res = new Map();
        var /** @type {?} */ elAttrs = element.attributes;
        for (var /** @type {?} */ i = 0; i < elAttrs.length; i++) {
            var /** @type {?} */ attrib = elAttrs[i];
            res.set(attrib.name, attrib.value);
        }
        return res;
    };
    /**
     * @param {?} element
     * @param {?} attribute
     * @return {?}
     */
    BrowserDomAdapter.prototype.hasAttribute = function (element, attribute) {
        return element.hasAttribute(attribute);
    };
    /**
     * @param {?} element
     * @param {?} ns
     * @param {?} attribute
     * @return {?}
     */
    BrowserDomAdapter.prototype.hasAttributeNS = function (element, ns, attribute) {
        return element.hasAttributeNS(ns, attribute);
    };
    /**
     * @param {?} element
     * @param {?} attribute
     * @return {?}
     */
    BrowserDomAdapter.prototype.getAttribute = function (element, attribute) {
        return element.getAttribute(attribute);
    };
    /**
     * @param {?} element
     * @param {?} ns
     * @param {?} name
     * @return {?}
     */
    BrowserDomAdapter.prototype.getAttributeNS = function (element, ns, name) {
        return element.getAttributeNS(ns, name);
    };
    /**
     * @param {?} element
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    BrowserDomAdapter.prototype.setAttribute = function (element, name, value) { element.setAttribute(name, value); };
    /**
     * @param {?} element
     * @param {?} ns
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    BrowserDomAdapter.prototype.setAttributeNS = function (element, ns, name, value) {
        element.setAttributeNS(ns, name, value);
    };
    /**
     * @param {?} element
     * @param {?} attribute
     * @return {?}
     */
    BrowserDomAdapter.prototype.removeAttribute = function (element, attribute) { element.removeAttribute(attribute); };
    /**
     * @param {?} element
     * @param {?} ns
     * @param {?} name
     * @return {?}
     */
    BrowserDomAdapter.prototype.removeAttributeNS = function (element, ns, name) {
        element.removeAttributeNS(ns, name);
    };
    /**
     * @param {?} el
     * @return {?}
     */
    BrowserDomAdapter.prototype.templateAwareRoot = function (el) { return this.isTemplateElement(el) ? this.content(el) : el; };
    /**
     * @return {?}
     */
    BrowserDomAdapter.prototype.createHtmlDocument = function () {
        return document.implementation.createHTMLDocument('fakeTitle');
    };
    /**
     * @param {?} el
     * @return {?}
     */
    BrowserDomAdapter.prototype.getBoundingClientRect = function (el) {
        try {
            return el.getBoundingClientRect();
        }
        catch (e) {
            return { top: 0, bottom: 0, left: 0, right: 0, width: 0, height: 0 };
        }
    };
    /**
     * @param {?} doc
     * @return {?}
     */
    BrowserDomAdapter.prototype.getTitle = function (doc) { return document.title; };
    /**
     * @param {?} doc
     * @param {?} newTitle
     * @return {?}
     */
    BrowserDomAdapter.prototype.setTitle = function (doc, newTitle) { document.title = newTitle || ''; };
    /**
     * @param {?} n
     * @param {?} selector
     * @return {?}
     */
    BrowserDomAdapter.prototype.elementMatches = function (n, selector) {
        if (n instanceof HTMLElement) {
            return n.matches && n.matches(selector) ||
                n.msMatchesSelector && n.msMatchesSelector(selector) ||
                n.webkitMatchesSelector && n.webkitMatchesSelector(selector);
        }
        return false;
    };
    /**
     * @param {?} el
     * @return {?}
     */
    BrowserDomAdapter.prototype.isTemplateElement = function (el) {
        return el instanceof HTMLElement && el.nodeName == 'TEMPLATE';
    };
    /**
     * @param {?} node
     * @return {?}
     */
    BrowserDomAdapter.prototype.isTextNode = function (node) { return node.nodeType === Node.TEXT_NODE; };
    /**
     * @param {?} node
     * @return {?}
     */
    BrowserDomAdapter.prototype.isCommentNode = function (node) { return node.nodeType === Node.COMMENT_NODE; };
    /**
     * @param {?} node
     * @return {?}
     */
    BrowserDomAdapter.prototype.isElementNode = function (node) { return node.nodeType === Node.ELEMENT_NODE; };
    /**
     * @param {?} node
     * @return {?}
     */
    BrowserDomAdapter.prototype.hasShadowRoot = function (node) {
        return node.shadowRoot != null && node instanceof HTMLElement;
    };
    /**
     * @param {?} node
     * @return {?}
     */
    BrowserDomAdapter.prototype.isShadowRoot = function (node) { return node instanceof DocumentFragment; };
    /**
     * @param {?} node
     * @return {?}
     */
    BrowserDomAdapter.prototype.importIntoDoc = function (node) { return document.importNode(this.templateAwareRoot(node), true); };
    /**
     * @param {?} node
     * @return {?}
     */
    BrowserDomAdapter.prototype.adoptNode = function (node) { return document.adoptNode(node); };
    /**
     * @param {?} el
     * @return {?}
     */
    BrowserDomAdapter.prototype.getHref = function (el) { return ((el)).href; };
    /**
     * @param {?} event
     * @return {?}
     */
    BrowserDomAdapter.prototype.getEventKey = function (event) {
        var /** @type {?} */ key = event.key;
        if (key == null) {
            key = event.keyIdentifier;
            // keyIdentifier is defined in the old draft of DOM Level 3 Events implemented by Chrome and
            // Safari cf
            // http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/events.html#Events-KeyboardEvents-Interfaces
            if (key == null) {
                return 'Unidentified';
            }
            if (key.startsWith('U+')) {
                key = String.fromCharCode(parseInt(key.substring(2), 16));
                if (event.location === DOM_KEY_LOCATION_NUMPAD && _chromeNumKeyPadMap.hasOwnProperty(key)) {
                    // There is a bug in Chrome for numeric keypad keys:
                    // https://code.google.com/p/chromium/issues/detail?id=155654
                    // 1, 2, 3 ... are reported as A, B, C ...
                    key = ((_chromeNumKeyPadMap))[key];
                }
            }
        }
        return _keyMap[key] || key;
    };
    /**
     * @param {?} doc
     * @param {?} target
     * @return {?}
     */
    BrowserDomAdapter.prototype.getGlobalEventTarget = function (doc, target) {
        if (target === 'window') {
            return window;
        }
        if (target === 'document') {
            return document;
        }
        if (target === 'body') {
            return document.body;
        }
        return null;
    };
    /**
     * @return {?}
     */
    BrowserDomAdapter.prototype.getHistory = function () { return window.history; };
    /**
     * @return {?}
     */
    BrowserDomAdapter.prototype.getLocation = function () { return window.location; };
    /**
     * @param {?} doc
     * @return {?}
     */
    BrowserDomAdapter.prototype.getBaseHref = function (doc) {
        var /** @type {?} */ href = getBaseElementHref();
        return href == null ? null : relativePath(href);
    };
    /**
     * @return {?}
     */
    BrowserDomAdapter.prototype.resetBaseElement = function () { baseElement = null; };
    /**
     * @return {?}
     */
    BrowserDomAdapter.prototype.getUserAgent = function () { return window.navigator.userAgent; };
    /**
     * @param {?} element
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    BrowserDomAdapter.prototype.setData = function (element, name, value) {
        this.setAttribute(element, 'data-' + name, value);
    };
    /**
     * @param {?} element
     * @param {?} name
     * @return {?}
     */
    BrowserDomAdapter.prototype.getData = function (element, name) {
        return this.getAttribute(element, 'data-' + name);
    };
    /**
     * @param {?} element
     * @return {?}
     */
    BrowserDomAdapter.prototype.getComputedStyle = function (element) { return getComputedStyle(element); };
    /**
     * @return {?}
     */
    BrowserDomAdapter.prototype.supportsWebAnimation = function () {
        return typeof ((Element)).prototype['animate'] === 'function';
    };
    /**
     * @return {?}
     */
    BrowserDomAdapter.prototype.performanceNow = function () {
        // performance.now() is not available in all browsers, see
        // http://caniuse.com/#search=performance.now
        return window.performance && window.performance.now ? window.performance.now() :
            new Date().getTime();
    };
    /**
     * @return {?}
     */
    BrowserDomAdapter.prototype.supportsCookies = function () { return true; };
    /**
     * @param {?} name
     * @return {?}
     */
    BrowserDomAdapter.prototype.getCookie = function (name) { return Object(__WEBPACK_IMPORTED_MODULE_1__angular_common__["ɵparseCookieValue"])(document.cookie, name); };
    /**
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    BrowserDomAdapter.prototype.setCookie = function (name, value) {
        // document.cookie is magical, assigning into it assigns/overrides one cookie value, but does
        // not clear other cookies.
        document.cookie = encodeURIComponent(name) + '=' + encodeURIComponent(value);
    };
    return BrowserDomAdapter;
}(GenericBrowserDomAdapter));
var baseElement = null;
/**
 * @return {?}
 */
function getBaseElementHref() {
    if (!baseElement) {
        baseElement = ((document.querySelector('base')));
        if (!baseElement) {
            return null;
        }
    }
    return baseElement.getAttribute('href');
}
// based on urlUtils.js in AngularJS 1
var urlParsingNode;
/**
 * @param {?} url
 * @return {?}
 */
function relativePath(url) {
    if (!urlParsingNode) {
        urlParsingNode = document.createElement('a');
    }
    urlParsingNode.setAttribute('href', url);
    return (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname :
        '/' + urlParsingNode.pathname;
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * A DI Token representing the main rendering context. In a browser this is the DOM Document.
 *
 * Note: Document might not be available in the Application Context when Application and Rendering
 * Contexts are not the same (e.g. when running the application into a Web Worker).
 *
 * @deprecated import from `\@angular/common` instead.
 */
var DOCUMENT$1 = __WEBPACK_IMPORTED_MODULE_1__angular_common__["DOCUMENT"];
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 * @return {?}
 */
function supportsState() {
    return !!window.history.pushState;
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * `PlatformLocation` encapsulates all of the direct calls to platform APIs.
 * This class should not be used directly by an application developer. Instead, use
 * {\@link Location}.
 */
var BrowserPlatformLocation = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](BrowserPlatformLocation, _super);
    /**
     * @param {?} _doc
     */
    function BrowserPlatformLocation(_doc) {
        var _this = _super.call(this) || this;
        _this._doc = _doc;
        _this._init();
        return _this;
    }
    /**
     * \@internal
     * @return {?}
     */
    BrowserPlatformLocation.prototype._init = function () {
        this._location = getDOM().getLocation();
        this._history = getDOM().getHistory();
    };
    Object.defineProperty(BrowserPlatformLocation.prototype, "location", {
        /**
         * @return {?}
         */
        get: function () { return this._location; },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    BrowserPlatformLocation.prototype.getBaseHrefFromDOM = function () { return ((getDOM().getBaseHref(this._doc))); };
    /**
     * @param {?} fn
     * @return {?}
     */
    BrowserPlatformLocation.prototype.onPopState = function (fn) {
        getDOM().getGlobalEventTarget(this._doc, 'window').addEventListener('popstate', fn, false);
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    BrowserPlatformLocation.prototype.onHashChange = function (fn) {
        getDOM().getGlobalEventTarget(this._doc, 'window').addEventListener('hashchange', fn, false);
    };
    Object.defineProperty(BrowserPlatformLocation.prototype, "pathname", {
        /**
         * @return {?}
         */
        get: function () { return this._location.pathname; },
        /**
         * @param {?} newPath
         * @return {?}
         */
        set: function (newPath) { this._location.pathname = newPath; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BrowserPlatformLocation.prototype, "search", {
        /**
         * @return {?}
         */
        get: function () { return this._location.search; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BrowserPlatformLocation.prototype, "hash", {
        /**
         * @return {?}
         */
        get: function () { return this._location.hash; },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} state
     * @param {?} title
     * @param {?} url
     * @return {?}
     */
    BrowserPlatformLocation.prototype.pushState = function (state, title, url) {
        if (supportsState()) {
            this._history.pushState(state, title, url);
        }
        else {
            this._location.hash = url;
        }
    };
    /**
     * @param {?} state
     * @param {?} title
     * @param {?} url
     * @return {?}
     */
    BrowserPlatformLocation.prototype.replaceState = function (state, title, url) {
        if (supportsState()) {
            this._history.replaceState(state, title, url);
        }
        else {
            this._location.hash = url;
        }
    };
    /**
     * @return {?}
     */
    BrowserPlatformLocation.prototype.forward = function () { this._history.forward(); };
    /**
     * @return {?}
     */
    BrowserPlatformLocation.prototype.back = function () { this._history.back(); };
    return BrowserPlatformLocation;
}(__WEBPACK_IMPORTED_MODULE_1__angular_common__["PlatformLocation"]));
BrowserPlatformLocation.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"] },
];
/**
 * @nocollapse
 */
BrowserPlatformLocation.ctorParameters = function () { return [
    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Inject"], args: [DOCUMENT$1,] },] },
]; };
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * A service that can be used to get and add meta tags.
 *
 * \@experimental
 */
var Meta = (function () {
    /**
     * @param {?} _doc
     */
    function Meta(_doc) {
        this._doc = _doc;
        this._dom = getDOM();
    }
    /**
     * @param {?} tag
     * @param {?=} forceCreation
     * @return {?}
     */
    Meta.prototype.addTag = function (tag, forceCreation) {
        if (forceCreation === void 0) { forceCreation = false; }
        if (!tag)
            return null;
        return this._getOrCreateElement(tag, forceCreation);
    };
    /**
     * @param {?} tags
     * @param {?=} forceCreation
     * @return {?}
     */
    Meta.prototype.addTags = function (tags, forceCreation) {
        var _this = this;
        if (forceCreation === void 0) { forceCreation = false; }
        if (!tags)
            return [];
        return tags.reduce(function (result, tag) {
            if (tag) {
                result.push(_this._getOrCreateElement(tag, forceCreation));
            }
            return result;
        }, []);
    };
    /**
     * @param {?} attrSelector
     * @return {?}
     */
    Meta.prototype.getTag = function (attrSelector) {
        if (!attrSelector)
            return null;
        return this._dom.querySelector(this._doc, "meta[" + attrSelector + "]");
    };
    /**
     * @param {?} attrSelector
     * @return {?}
     */
    Meta.prototype.getTags = function (attrSelector) {
        if (!attrSelector)
            return [];
        var /** @type {?} */ list /*NodeList*/ = this._dom.querySelectorAll(this._doc, "meta[" + attrSelector + "]");
        return list ? [].slice.call(list) : [];
    };
    /**
     * @param {?} tag
     * @param {?=} selector
     * @return {?}
     */
    Meta.prototype.updateTag = function (tag, selector) {
        if (!tag)
            return null;
        selector = selector || this._parseSelector(tag);
        var /** @type {?} */ meta = ((this.getTag(selector)));
        if (meta) {
            return this._setMetaElementAttributes(tag, meta);
        }
        return this._getOrCreateElement(tag, true);
    };
    /**
     * @param {?} attrSelector
     * @return {?}
     */
    Meta.prototype.removeTag = function (attrSelector) { this.removeTagElement(/** @type {?} */ ((this.getTag(attrSelector)))); };
    /**
     * @param {?} meta
     * @return {?}
     */
    Meta.prototype.removeTagElement = function (meta) {
        if (meta) {
            this._dom.remove(meta);
        }
    };
    /**
     * @param {?} meta
     * @param {?=} forceCreation
     * @return {?}
     */
    Meta.prototype._getOrCreateElement = function (meta, forceCreation) {
        if (forceCreation === void 0) { forceCreation = false; }
        if (!forceCreation) {
            var /** @type {?} */ selector = this._parseSelector(meta);
            var /** @type {?} */ elem = ((this.getTag(selector)));
            // It's allowed to have multiple elements with the same name so it's not enough to
            // just check that element with the same name already present on the page. We also need to
            // check if element has tag attributes
            if (elem && this._containsAttributes(meta, elem))
                return elem;
        }
        var /** @type {?} */ element = (this._dom.createElement('meta'));
        this._setMetaElementAttributes(meta, element);
        var /** @type {?} */ head = this._dom.getElementsByTagName(this._doc, 'head')[0];
        this._dom.appendChild(head, element);
        return element;
    };
    /**
     * @param {?} tag
     * @param {?} el
     * @return {?}
     */
    Meta.prototype._setMetaElementAttributes = function (tag, el) {
        var _this = this;
        Object.keys(tag).forEach(function (prop) { return _this._dom.setAttribute(el, prop, tag[prop]); });
        return el;
    };
    /**
     * @param {?} tag
     * @return {?}
     */
    Meta.prototype._parseSelector = function (tag) {
        var /** @type {?} */ attr = tag.name ? 'name' : 'property';
        return attr + "=\"" + tag[attr] + "\"";
    };
    /**
     * @param {?} tag
     * @param {?} elem
     * @return {?}
     */
    Meta.prototype._containsAttributes = function (tag, elem) {
        var _this = this;
        return Object.keys(tag).every(function (key) { return _this._dom.getAttribute(elem, key) === tag[key]; });
    };
    return Meta;
}());
Meta.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"] },
];
/**
 * @nocollapse
 */
Meta.ctorParameters = function () { return [
    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Inject"], args: [DOCUMENT$1,] },] },
]; };
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * An id that identifies a particular application being bootstrapped, that should
 * match across the client/server boundary.
 */
var TRANSITION_ID = new __WEBPACK_IMPORTED_MODULE_2__angular_core__["InjectionToken"]('TRANSITION_ID');
/**
 * @param {?} transitionId
 * @param {?} document
 * @param {?} injector
 * @return {?}
 */
function appInitializerFactory(transitionId, document, injector) {
    return function () {
        // Wait for all application initializers to be completed before removing the styles set by
        // the server.
        injector.get(__WEBPACK_IMPORTED_MODULE_2__angular_core__["ApplicationInitStatus"]).donePromise.then(function () {
            var /** @type {?} */ dom = getDOM();
            var /** @type {?} */ styles = Array.prototype.slice.apply(dom.querySelectorAll(document, "style[ng-transition]"));
            styles.filter(function (el) { return dom.getAttribute(el, 'ng-transition') === transitionId; })
                .forEach(function (el) { return dom.remove(el); });
        });
    };
}
var SERVER_TRANSITION_PROVIDERS = [
    {
        provide: __WEBPACK_IMPORTED_MODULE_2__angular_core__["APP_INITIALIZER"],
        useFactory: appInitializerFactory,
        deps: [TRANSITION_ID, DOCUMENT$1, __WEBPACK_IMPORTED_MODULE_2__angular_core__["Injector"]],
        multi: true
    },
];
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var BrowserGetTestability = (function () {
    function BrowserGetTestability() {
    }
    /**
     * @return {?}
     */
    BrowserGetTestability.init = function () { Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["setTestabilityGetter"])(new BrowserGetTestability()); };
    /**
     * @param {?} registry
     * @return {?}
     */
    BrowserGetTestability.prototype.addToWindow = function (registry) {
        __WEBPACK_IMPORTED_MODULE_2__angular_core__["ɵglobal"]['getAngularTestability'] = function (elem, findInAncestors) {
            if (findInAncestors === void 0) { findInAncestors = true; }
            var /** @type {?} */ testability = registry.findTestabilityInTree(elem, findInAncestors);
            if (testability == null) {
                throw new Error('Could not find testability for element.');
            }
            return testability;
        };
        __WEBPACK_IMPORTED_MODULE_2__angular_core__["ɵglobal"]['getAllAngularTestabilities'] = function () { return registry.getAllTestabilities(); };
        __WEBPACK_IMPORTED_MODULE_2__angular_core__["ɵglobal"]['getAllAngularRootElements'] = function () { return registry.getAllRootElements(); };
        var /** @type {?} */ whenAllStable = function (callback /** TODO #9100 */) {
            var /** @type {?} */ testabilities = __WEBPACK_IMPORTED_MODULE_2__angular_core__["ɵglobal"]['getAllAngularTestabilities']();
            var /** @type {?} */ count = testabilities.length;
            var /** @type {?} */ didWork = false;
            var /** @type {?} */ decrement = function (didWork_ /** TODO #9100 */) {
                didWork = didWork || didWork_;
                count--;
                if (count == 0) {
                    callback(didWork);
                }
            };
            testabilities.forEach(function (testability /** TODO #9100 */) {
                testability.whenStable(decrement);
            });
        };
        if (!__WEBPACK_IMPORTED_MODULE_2__angular_core__["ɵglobal"]['frameworkStabilizers']) {
            __WEBPACK_IMPORTED_MODULE_2__angular_core__["ɵglobal"]['frameworkStabilizers'] = [];
        }
        __WEBPACK_IMPORTED_MODULE_2__angular_core__["ɵglobal"]['frameworkStabilizers'].push(whenAllStable);
    };
    /**
     * @param {?} registry
     * @param {?} elem
     * @param {?} findInAncestors
     * @return {?}
     */
    BrowserGetTestability.prototype.findTestabilityInTree = function (registry, elem, findInAncestors) {
        if (elem == null) {
            return null;
        }
        var /** @type {?} */ t = registry.getTestability(elem);
        if (t != null) {
            return t;
        }
        else if (!findInAncestors) {
            return null;
        }
        if (getDOM().isShadowRoot(elem)) {
            return this.findTestabilityInTree(registry, getDOM().getHost(elem), true);
        }
        return this.findTestabilityInTree(registry, getDOM().parentElement(elem), true);
    };
    return BrowserGetTestability;
}());
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * A service that can be used to get and set the title of a current HTML document.
 *
 * Since an Angular application can't be bootstrapped on the entire HTML document (`<html>` tag)
 * it is not possible to bind to the `text` property of the `HTMLTitleElement` elements
 * (representing the `<title>` tag). Instead, this service can be used to set and get the current
 * title value.
 *
 * \@experimental
 */
var Title = (function () {
    /**
     * @param {?} _doc
     */
    function Title(_doc) {
        this._doc = _doc;
    }
    /**
     * Get the title of the current HTML document.
     * @return {?}
     */
    Title.prototype.getTitle = function () { return getDOM().getTitle(this._doc); };
    /**
     * Set the title of the current HTML document.
     * @param {?} newTitle
     * @return {?}
     */
    Title.prototype.setTitle = function (newTitle) { getDOM().setTitle(this._doc, newTitle); };
    return Title;
}());
Title.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"] },
];
/**
 * @nocollapse
 */
Title.ctorParameters = function () { return [
    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Inject"], args: [DOCUMENT$1,] },] },
]; };
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @param {?} input
 * @return {?}
 */
/**
 * @param {?} input
 * @return {?}
 */
/**
 * Exports the value under a given `name` in the global property `ng`. For example `ng.probe` if
 * `name` is `'probe'`.
 * @param {?} name Name under which it will be exported. Keep in mind this will be a property of the
 * global `ng` object.
 * @param {?} value The value to export.
 * @return {?}
 */
function exportNgVar(name, value) {
    if (!ng) {
        __WEBPACK_IMPORTED_MODULE_2__angular_core__["ɵglobal"]['ng'] = ng = ((__WEBPACK_IMPORTED_MODULE_2__angular_core__["ɵglobal"]['ng'])) || {};
    }
    ng[name] = value;
}
var ng;
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var CORE_TOKENS = {
    'ApplicationRef': __WEBPACK_IMPORTED_MODULE_2__angular_core__["ApplicationRef"],
    'NgZone': __WEBPACK_IMPORTED_MODULE_2__angular_core__["NgZone"],
};
var INSPECT_GLOBAL_NAME = 'probe';
var CORE_TOKENS_GLOBAL_NAME = 'coreTokens';
/**
 * Returns a {\@link DebugElement} for the given native DOM element, or
 * null if the given native element does not have an Angular view associated
 * with it.
 * @param {?} element
 * @return {?}
 */
function inspectNativeElement(element) {
    return Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["getDebugNode"])(element);
}
/**
 * Deprecated. Use the one from '\@angular/core'.
 * @deprecated
 */
var NgProbeToken$1 = (function () {
    /**
     * @param {?} name
     * @param {?} token
     */
    function NgProbeToken$1(name, token) {
        this.name = name;
        this.token = token;
    }
    return NgProbeToken$1;
}());
/**
 * @param {?} extraTokens
 * @param {?} coreTokens
 * @return {?}
 */
function _createNgProbe(extraTokens, coreTokens) {
    var /** @type {?} */ tokens = (extraTokens || []).concat(coreTokens || []);
    exportNgVar(INSPECT_GLOBAL_NAME, inspectNativeElement);
    exportNgVar(CORE_TOKENS_GLOBAL_NAME, Object.assign({}, CORE_TOKENS, _ngProbeTokensToMap(tokens || [])));
    return function () { return inspectNativeElement; };
}
/**
 * @param {?} tokens
 * @return {?}
 */
function _ngProbeTokensToMap(tokens) {
    return tokens.reduce(function (prev, t) { return (prev[t.name] = t.token, prev); }, {});
}
/**
 * Providers which support debugging Angular applications (e.g. via `ng.probe`).
 */
var ELEMENT_PROBE_PROVIDERS = [
    {
        provide: __WEBPACK_IMPORTED_MODULE_2__angular_core__["APP_INITIALIZER"],
        useFactory: _createNgProbe,
        deps: [
            [NgProbeToken$1, new __WEBPACK_IMPORTED_MODULE_2__angular_core__["Optional"]()],
            [__WEBPACK_IMPORTED_MODULE_2__angular_core__["NgProbeToken"], new __WEBPACK_IMPORTED_MODULE_2__angular_core__["Optional"]()],
        ],
        multi: true,
    },
];
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * \@stable
 */
var EVENT_MANAGER_PLUGINS = new __WEBPACK_IMPORTED_MODULE_2__angular_core__["InjectionToken"]('EventManagerPlugins');
/**
 * \@stable
 */
var EventManager = (function () {
    /**
     * @param {?} plugins
     * @param {?} _zone
     */
    function EventManager(plugins, _zone) {
        var _this = this;
        this._zone = _zone;
        this._eventNameToPlugin = new Map();
        plugins.forEach(function (p) { return p.manager = _this; });
        this._plugins = plugins.slice().reverse();
    }
    /**
     * @param {?} element
     * @param {?} eventName
     * @param {?} handler
     * @return {?}
     */
    EventManager.prototype.addEventListener = function (element, eventName, handler) {
        var /** @type {?} */ plugin = this._findPluginFor(eventName);
        return plugin.addEventListener(element, eventName, handler);
    };
    /**
     * @param {?} target
     * @param {?} eventName
     * @param {?} handler
     * @return {?}
     */
    EventManager.prototype.addGlobalEventListener = function (target, eventName, handler) {
        var /** @type {?} */ plugin = this._findPluginFor(eventName);
        return plugin.addGlobalEventListener(target, eventName, handler);
    };
    /**
     * @return {?}
     */
    EventManager.prototype.getZone = function () { return this._zone; };
    /**
     * \@internal
     * @param {?} eventName
     * @return {?}
     */
    EventManager.prototype._findPluginFor = function (eventName) {
        var /** @type {?} */ plugin = this._eventNameToPlugin.get(eventName);
        if (plugin) {
            return plugin;
        }
        var /** @type {?} */ plugins = this._plugins;
        for (var /** @type {?} */ i = 0; i < plugins.length; i++) {
            var /** @type {?} */ plugin_1 = plugins[i];
            if (plugin_1.supports(eventName)) {
                this._eventNameToPlugin.set(eventName, plugin_1);
                return plugin_1;
            }
        }
        throw new Error("No event manager plugin found for event " + eventName);
    };
    return EventManager;
}());
EventManager.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"] },
];
/**
 * @nocollapse
 */
EventManager.ctorParameters = function () { return [
    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Inject"], args: [EVENT_MANAGER_PLUGINS,] },] },
    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["NgZone"], },
]; };
/**
 * @abstract
 */
var EventManagerPlugin = (function () {
    /**
     * @param {?} _doc
     */
    function EventManagerPlugin(_doc) {
        this._doc = _doc;
    }
    /**
     * @abstract
     * @param {?} eventName
     * @return {?}
     */
    EventManagerPlugin.prototype.supports = function (eventName) { };
    /**
     * @abstract
     * @param {?} element
     * @param {?} eventName
     * @param {?} handler
     * @return {?}
     */
    EventManagerPlugin.prototype.addEventListener = function (element, eventName, handler) { };
    /**
     * @param {?} element
     * @param {?} eventName
     * @param {?} handler
     * @return {?}
     */
    EventManagerPlugin.prototype.addGlobalEventListener = function (element, eventName, handler) {
        var /** @type {?} */ target = getDOM().getGlobalEventTarget(this._doc, element);
        if (!target) {
            throw new Error("Unsupported event target " + target + " for event " + eventName);
        }
        return this.addEventListener(target, eventName, handler);
    };
    ;
    return EventManagerPlugin;
}());
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var SharedStylesHost = (function () {
    function SharedStylesHost() {
        /**
         * \@internal
         */
        this._stylesSet = new Set();
    }
    /**
     * @param {?} styles
     * @return {?}
     */
    SharedStylesHost.prototype.addStyles = function (styles) {
        var _this = this;
        var /** @type {?} */ additions = new Set();
        styles.forEach(function (style) {
            if (!_this._stylesSet.has(style)) {
                _this._stylesSet.add(style);
                additions.add(style);
            }
        });
        this.onStylesAdded(additions);
    };
    /**
     * @param {?} additions
     * @return {?}
     */
    SharedStylesHost.prototype.onStylesAdded = function (additions) { };
    /**
     * @return {?}
     */
    SharedStylesHost.prototype.getAllStyles = function () { return Array.from(this._stylesSet); };
    return SharedStylesHost;
}());
SharedStylesHost.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"] },
];
/**
 * @nocollapse
 */
SharedStylesHost.ctorParameters = function () { return []; };
var DomSharedStylesHost = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](DomSharedStylesHost, _super);
    /**
     * @param {?} _doc
     */
    function DomSharedStylesHost(_doc) {
        var _this = _super.call(this) || this;
        _this._doc = _doc;
        _this._hostNodes = new Set();
        _this._styleNodes = new Set();
        _this._hostNodes.add(_doc.head);
        return _this;
    }
    /**
     * @param {?} styles
     * @param {?} host
     * @return {?}
     */
    DomSharedStylesHost.prototype._addStylesToHost = function (styles, host) {
        var _this = this;
        styles.forEach(function (style) {
            var /** @type {?} */ styleEl = _this._doc.createElement('style');
            styleEl.textContent = style;
            _this._styleNodes.add(host.appendChild(styleEl));
        });
    };
    /**
     * @param {?} hostNode
     * @return {?}
     */
    DomSharedStylesHost.prototype.addHost = function (hostNode) {
        this._addStylesToHost(this._stylesSet, hostNode);
        this._hostNodes.add(hostNode);
    };
    /**
     * @param {?} hostNode
     * @return {?}
     */
    DomSharedStylesHost.prototype.removeHost = function (hostNode) { this._hostNodes.delete(hostNode); };
    /**
     * @param {?} additions
     * @return {?}
     */
    DomSharedStylesHost.prototype.onStylesAdded = function (additions) {
        var _this = this;
        this._hostNodes.forEach(function (hostNode) { return _this._addStylesToHost(additions, hostNode); });
    };
    /**
     * @return {?}
     */
    DomSharedStylesHost.prototype.ngOnDestroy = function () { this._styleNodes.forEach(function (styleNode) { return getDOM().remove(styleNode); }); };
    return DomSharedStylesHost;
}(SharedStylesHost));
DomSharedStylesHost.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"] },
];
/**
 * @nocollapse
 */
DomSharedStylesHost.ctorParameters = function () { return [
    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Inject"], args: [DOCUMENT$1,] },] },
]; };
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var NAMESPACE_URIS = {
    'svg': 'http://www.w3.org/2000/svg',
    'xhtml': 'http://www.w3.org/1999/xhtml',
    'xlink': 'http://www.w3.org/1999/xlink',
    'xml': 'http://www.w3.org/XML/1998/namespace',
    'xmlns': 'http://www.w3.org/2000/xmlns/',
};
var COMPONENT_REGEX = /%COMP%/g;
var COMPONENT_VARIABLE = '%COMP%';
var HOST_ATTR = "_nghost-" + COMPONENT_VARIABLE;
var CONTENT_ATTR = "_ngcontent-" + COMPONENT_VARIABLE;
/**
 * @param {?} componentShortId
 * @return {?}
 */
function shimContentAttribute(componentShortId) {
    return CONTENT_ATTR.replace(COMPONENT_REGEX, componentShortId);
}
/**
 * @param {?} componentShortId
 * @return {?}
 */
function shimHostAttribute(componentShortId) {
    return HOST_ATTR.replace(COMPONENT_REGEX, componentShortId);
}
/**
 * @param {?} compId
 * @param {?} styles
 * @param {?} target
 * @return {?}
 */
function flattenStyles(compId, styles, target) {
    for (var /** @type {?} */ i = 0; i < styles.length; i++) {
        var /** @type {?} */ style = styles[i];
        if (Array.isArray(style)) {
            flattenStyles(compId, style, target);
        }
        else {
            style = style.replace(COMPONENT_REGEX, compId);
            target.push(style);
        }
    }
    return target;
}
/**
 * @param {?} eventHandler
 * @return {?}
 */
function decoratePreventDefault(eventHandler) {
    return function (event) {
        var /** @type {?} */ allowDefaultBehavior = eventHandler(event);
        if (allowDefaultBehavior === false) {
            // TODO(tbosch): move preventDefault into event plugins...
            event.preventDefault();
            event.returnValue = false;
        }
    };
}
var DomRendererFactory2 = (function () {
    /**
     * @param {?} eventManager
     * @param {?} sharedStylesHost
     */
    function DomRendererFactory2(eventManager, sharedStylesHost) {
        this.eventManager = eventManager;
        this.sharedStylesHost = sharedStylesHost;
        this.rendererByCompId = new Map();
        this.defaultRenderer = new DefaultDomRenderer2(eventManager);
    }
    ;
    /**
     * @param {?} element
     * @param {?} type
     * @return {?}
     */
    DomRendererFactory2.prototype.createRenderer = function (element, type) {
        if (!element || !type) {
            return this.defaultRenderer;
        }
        switch (type.encapsulation) {
            case __WEBPACK_IMPORTED_MODULE_2__angular_core__["ViewEncapsulation"].Emulated: {
                var /** @type {?} */ renderer = this.rendererByCompId.get(type.id);
                if (!renderer) {
                    renderer =
                        new EmulatedEncapsulationDomRenderer2(this.eventManager, this.sharedStylesHost, type);
                    this.rendererByCompId.set(type.id, renderer);
                }
                ((renderer)).applyToHost(element);
                return renderer;
            }
            case __WEBPACK_IMPORTED_MODULE_2__angular_core__["ViewEncapsulation"].Native:
                return new ShadowDomRenderer(this.eventManager, this.sharedStylesHost, element, type);
            default: {
                if (!this.rendererByCompId.has(type.id)) {
                    var /** @type {?} */ styles = flattenStyles(type.id, type.styles, []);
                    this.sharedStylesHost.addStyles(styles);
                    this.rendererByCompId.set(type.id, this.defaultRenderer);
                }
                return this.defaultRenderer;
            }
        }
    };
    /**
     * @return {?}
     */
    DomRendererFactory2.prototype.begin = function () { };
    /**
     * @return {?}
     */
    DomRendererFactory2.prototype.end = function () { };
    return DomRendererFactory2;
}());
DomRendererFactory2.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"] },
];
/**
 * @nocollapse
 */
DomRendererFactory2.ctorParameters = function () { return [
    { type: EventManager, },
    { type: DomSharedStylesHost, },
]; };
var DefaultDomRenderer2 = (function () {
    /**
     * @param {?} eventManager
     */
    function DefaultDomRenderer2(eventManager) {
        this.eventManager = eventManager;
        this.data = Object.create(null);
    }
    /**
     * @return {?}
     */
    DefaultDomRenderer2.prototype.destroy = function () { };
    /**
     * @param {?} name
     * @param {?=} namespace
     * @return {?}
     */
    DefaultDomRenderer2.prototype.createElement = function (name, namespace) {
        if (namespace) {
            return document.createElementNS(NAMESPACE_URIS[namespace], name);
        }
        return document.createElement(name);
    };
    /**
     * @param {?} value
     * @return {?}
     */
    DefaultDomRenderer2.prototype.createComment = function (value) { return document.createComment(value); };
    /**
     * @param {?} value
     * @return {?}
     */
    DefaultDomRenderer2.prototype.createText = function (value) { return document.createTextNode(value); };
    /**
     * @param {?} parent
     * @param {?} newChild
     * @return {?}
     */
    DefaultDomRenderer2.prototype.appendChild = function (parent, newChild) { parent.appendChild(newChild); };
    /**
     * @param {?} parent
     * @param {?} newChild
     * @param {?} refChild
     * @return {?}
     */
    DefaultDomRenderer2.prototype.insertBefore = function (parent, newChild, refChild) {
        if (parent) {
            parent.insertBefore(newChild, refChild);
        }
    };
    /**
     * @param {?} parent
     * @param {?} oldChild
     * @return {?}
     */
    DefaultDomRenderer2.prototype.removeChild = function (parent, oldChild) {
        if (parent) {
            parent.removeChild(oldChild);
        }
    };
    /**
     * @param {?} selectorOrNode
     * @return {?}
     */
    DefaultDomRenderer2.prototype.selectRootElement = function (selectorOrNode) {
        var /** @type {?} */ el = typeof selectorOrNode === 'string' ? document.querySelector(selectorOrNode) :
            selectorOrNode;
        if (!el) {
            throw new Error("The selector \"" + selectorOrNode + "\" did not match any elements");
        }
        el.textContent = '';
        return el;
    };
    /**
     * @param {?} node
     * @return {?}
     */
    DefaultDomRenderer2.prototype.parentNode = function (node) { return node.parentNode; };
    /**
     * @param {?} node
     * @return {?}
     */
    DefaultDomRenderer2.prototype.nextSibling = function (node) { return node.nextSibling; };
    /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @param {?=} namespace
     * @return {?}
     */
    DefaultDomRenderer2.prototype.setAttribute = function (el, name, value, namespace) {
        if (namespace) {
            name = namespace + ":" + name;
            var /** @type {?} */ namespaceUri = NAMESPACE_URIS[namespace];
            if (namespaceUri) {
                el.setAttributeNS(namespaceUri, name, value);
            }
            else {
                el.setAttribute(name, value);
            }
        }
        else {
            el.setAttribute(name, value);
        }
    };
    /**
     * @param {?} el
     * @param {?} name
     * @param {?=} namespace
     * @return {?}
     */
    DefaultDomRenderer2.prototype.removeAttribute = function (el, name, namespace) {
        if (namespace) {
            var /** @type {?} */ namespaceUri = NAMESPACE_URIS[namespace];
            if (namespaceUri) {
                el.removeAttributeNS(namespaceUri, name);
            }
            else {
                el.removeAttribute(namespace + ":" + name);
            }
        }
        else {
            el.removeAttribute(name);
        }
    };
    /**
     * @param {?} el
     * @param {?} name
     * @return {?}
     */
    DefaultDomRenderer2.prototype.addClass = function (el, name) { el.classList.add(name); };
    /**
     * @param {?} el
     * @param {?} name
     * @return {?}
     */
    DefaultDomRenderer2.prototype.removeClass = function (el, name) { el.classList.remove(name); };
    /**
     * @param {?} el
     * @param {?} style
     * @param {?} value
     * @param {?} flags
     * @return {?}
     */
    DefaultDomRenderer2.prototype.setStyle = function (el, style, value, flags) {
        if (flags & __WEBPACK_IMPORTED_MODULE_2__angular_core__["RendererStyleFlags2"].DashCase) {
            el.style.setProperty(style, value, !!(flags & __WEBPACK_IMPORTED_MODULE_2__angular_core__["RendererStyleFlags2"].Important) ? 'important' : '');
        }
        else {
            el.style[style] = value;
        }
    };
    /**
     * @param {?} el
     * @param {?} style
     * @param {?} flags
     * @return {?}
     */
    DefaultDomRenderer2.prototype.removeStyle = function (el, style, flags) {
        if (flags & __WEBPACK_IMPORTED_MODULE_2__angular_core__["RendererStyleFlags2"].DashCase) {
            el.style.removeProperty(style);
        }
        else {
            // IE requires '' instead of null
            // see https://github.com/angular/angular/issues/7916
            el.style[style] = '';
        }
    };
    /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    DefaultDomRenderer2.prototype.setProperty = function (el, name, value) {
        checkNoSyntheticProp(name, 'property');
        el[name] = value;
    };
    /**
     * @param {?} node
     * @param {?} value
     * @return {?}
     */
    DefaultDomRenderer2.prototype.setValue = function (node, value) { node.nodeValue = value; };
    /**
     * @param {?} target
     * @param {?} event
     * @param {?} callback
     * @return {?}
     */
    DefaultDomRenderer2.prototype.listen = function (target, event, callback) {
        checkNoSyntheticProp(event, 'listener');
        if (typeof target === 'string') {
            return (this.eventManager.addGlobalEventListener(target, event, decoratePreventDefault(callback)));
        }
        return ((this.eventManager.addEventListener(target, event, decoratePreventDefault(callback))));
    };
    return DefaultDomRenderer2;
}());
var AT_CHARCODE = '@'.charCodeAt(0);
/**
 * @param {?} name
 * @param {?} nameKind
 * @return {?}
 */
function checkNoSyntheticProp(name, nameKind) {
    if (name.charCodeAt(0) === AT_CHARCODE) {
        throw new Error("Found the synthetic " + nameKind + " " + name + ". Please include either \"BrowserAnimationsModule\" or \"NoopAnimationsModule\" in your application.");
    }
}
var EmulatedEncapsulationDomRenderer2 = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](EmulatedEncapsulationDomRenderer2, _super);
    /**
     * @param {?} eventManager
     * @param {?} sharedStylesHost
     * @param {?} component
     */
    function EmulatedEncapsulationDomRenderer2(eventManager, sharedStylesHost, component) {
        var _this = _super.call(this, eventManager) || this;
        _this.component = component;
        var styles = flattenStyles(component.id, component.styles, []);
        sharedStylesHost.addStyles(styles);
        _this.contentAttr = shimContentAttribute(component.id);
        _this.hostAttr = shimHostAttribute(component.id);
        return _this;
    }
    /**
     * @param {?} element
     * @return {?}
     */
    EmulatedEncapsulationDomRenderer2.prototype.applyToHost = function (element) { _super.prototype.setAttribute.call(this, element, this.hostAttr, ''); };
    /**
     * @param {?} parent
     * @param {?} name
     * @return {?}
     */
    EmulatedEncapsulationDomRenderer2.prototype.createElement = function (parent, name) {
        var /** @type {?} */ el = _super.prototype.createElement.call(this, parent, name);
        _super.prototype.setAttribute.call(this, el, this.contentAttr, '');
        return el;
    };
    return EmulatedEncapsulationDomRenderer2;
}(DefaultDomRenderer2));
var ShadowDomRenderer = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](ShadowDomRenderer, _super);
    /**
     * @param {?} eventManager
     * @param {?} sharedStylesHost
     * @param {?} hostEl
     * @param {?} component
     */
    function ShadowDomRenderer(eventManager, sharedStylesHost, hostEl, component) {
        var _this = _super.call(this, eventManager) || this;
        _this.sharedStylesHost = sharedStylesHost;
        _this.hostEl = hostEl;
        _this.component = component;
        _this.shadowRoot = hostEl.createShadowRoot();
        _this.sharedStylesHost.addHost(_this.shadowRoot);
        var styles = flattenStyles(component.id, component.styles, []);
        for (var i = 0; i < styles.length; i++) {
            var styleEl = document.createElement('style');
            styleEl.textContent = styles[i];
            _this.shadowRoot.appendChild(styleEl);
        }
        return _this;
    }
    /**
     * @param {?} node
     * @return {?}
     */
    ShadowDomRenderer.prototype.nodeOrShadowRoot = function (node) { return node === this.hostEl ? this.shadowRoot : node; };
    /**
     * @return {?}
     */
    ShadowDomRenderer.prototype.destroy = function () { this.sharedStylesHost.removeHost(this.shadowRoot); };
    /**
     * @param {?} parent
     * @param {?} newChild
     * @return {?}
     */
    ShadowDomRenderer.prototype.appendChild = function (parent, newChild) {
        return _super.prototype.appendChild.call(this, this.nodeOrShadowRoot(parent), newChild);
    };
    /**
     * @param {?} parent
     * @param {?} newChild
     * @param {?} refChild
     * @return {?}
     */
    ShadowDomRenderer.prototype.insertBefore = function (parent, newChild, refChild) {
        return _super.prototype.insertBefore.call(this, this.nodeOrShadowRoot(parent), newChild, refChild);
    };
    /**
     * @param {?} parent
     * @param {?} oldChild
     * @return {?}
     */
    ShadowDomRenderer.prototype.removeChild = function (parent, oldChild) {
        return _super.prototype.removeChild.call(this, this.nodeOrShadowRoot(parent), oldChild);
    };
    /**
     * @param {?} node
     * @return {?}
     */
    ShadowDomRenderer.prototype.parentNode = function (node) {
        return this.nodeOrShadowRoot(_super.prototype.parentNode.call(this, this.nodeOrShadowRoot(node)));
    };
    return ShadowDomRenderer;
}(DefaultDomRenderer2));
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var DomEventsPlugin = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](DomEventsPlugin, _super);
    /**
     * @param {?} doc
     */
    function DomEventsPlugin(doc) {
        return _super.call(this, doc) || this;
    }
    /**
     * @param {?} eventName
     * @return {?}
     */
    DomEventsPlugin.prototype.supports = function (eventName) { return true; };
    /**
     * @param {?} element
     * @param {?} eventName
     * @param {?} handler
     * @return {?}
     */
    DomEventsPlugin.prototype.addEventListener = function (element, eventName, handler) {
        element.addEventListener(eventName, /** @type {?} */ (handler), false);
        return function () { return element.removeEventListener(eventName, /** @type {?} */ (handler), false); };
    };
    return DomEventsPlugin;
}(EventManagerPlugin));
DomEventsPlugin.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"] },
];
/**
 * @nocollapse
 */
DomEventsPlugin.ctorParameters = function () { return [
    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Inject"], args: [DOCUMENT$1,] },] },
]; };
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var EVENT_NAMES = {
    // pan
    'pan': true,
    'panstart': true,
    'panmove': true,
    'panend': true,
    'pancancel': true,
    'panleft': true,
    'panright': true,
    'panup': true,
    'pandown': true,
    // pinch
    'pinch': true,
    'pinchstart': true,
    'pinchmove': true,
    'pinchend': true,
    'pinchcancel': true,
    'pinchin': true,
    'pinchout': true,
    // press
    'press': true,
    'pressup': true,
    // rotate
    'rotate': true,
    'rotatestart': true,
    'rotatemove': true,
    'rotateend': true,
    'rotatecancel': true,
    // swipe
    'swipe': true,
    'swipeleft': true,
    'swiperight': true,
    'swipeup': true,
    'swipedown': true,
    // tap
    'tap': true,
};
/**
 * A DI token that you can use to provide{\@link HammerGestureConfig} to Angular. Use it to configure
 * Hammer gestures.
 *
 * \@experimental
 */
var HAMMER_GESTURE_CONFIG = new __WEBPACK_IMPORTED_MODULE_2__angular_core__["InjectionToken"]('HammerGestureConfig');
/**
 * \@experimental
 */
var HammerGestureConfig = (function () {
    function HammerGestureConfig() {
        this.events = [];
        this.overrides = {};
    }
    /**
     * @param {?} element
     * @return {?}
     */
    HammerGestureConfig.prototype.buildHammer = function (element) {
        var /** @type {?} */ mc = new Hammer(element);
        mc.get('pinch').set({ enable: true });
        mc.get('rotate').set({ enable: true });
        for (var /** @type {?} */ eventName in this.overrides) {
            mc.get(eventName).set(this.overrides[eventName]);
        }
        return mc;
    };
    return HammerGestureConfig;
}());
HammerGestureConfig.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"] },
];
/**
 * @nocollapse
 */
HammerGestureConfig.ctorParameters = function () { return []; };
var HammerGesturesPlugin = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](HammerGesturesPlugin, _super);
    /**
     * @param {?} doc
     * @param {?} _config
     */
    function HammerGesturesPlugin(doc, _config) {
        var _this = _super.call(this, doc) || this;
        _this._config = _config;
        return _this;
    }
    /**
     * @param {?} eventName
     * @return {?}
     */
    HammerGesturesPlugin.prototype.supports = function (eventName) {
        if (!EVENT_NAMES.hasOwnProperty(eventName.toLowerCase()) && !this.isCustomEvent(eventName)) {
            return false;
        }
        if (!((window)).Hammer) {
            throw new Error("Hammer.js is not loaded, can not bind " + eventName + " event");
        }
        return true;
    };
    /**
     * @param {?} element
     * @param {?} eventName
     * @param {?} handler
     * @return {?}
     */
    HammerGesturesPlugin.prototype.addEventListener = function (element, eventName, handler) {
        var _this = this;
        var /** @type {?} */ zone = this.manager.getZone();
        eventName = eventName.toLowerCase();
        return zone.runOutsideAngular(function () {
            // Creating the manager bind events, must be done outside of angular
            var /** @type {?} */ mc = _this._config.buildHammer(element);
            var /** @type {?} */ callback = function (eventObj) {
                zone.runGuarded(function () { handler(eventObj); });
            };
            mc.on(eventName, callback);
            return function () { return mc.off(eventName, callback); };
        });
    };
    /**
     * @param {?} eventName
     * @return {?}
     */
    HammerGesturesPlugin.prototype.isCustomEvent = function (eventName) { return this._config.events.indexOf(eventName) > -1; };
    return HammerGesturesPlugin;
}(EventManagerPlugin));
HammerGesturesPlugin.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"] },
];
/**
 * @nocollapse
 */
HammerGesturesPlugin.ctorParameters = function () { return [
    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Inject"], args: [DOCUMENT$1,] },] },
    { type: HammerGestureConfig, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Inject"], args: [HAMMER_GESTURE_CONFIG,] },] },
]; };
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var MODIFIER_KEYS = ['alt', 'control', 'meta', 'shift'];
var MODIFIER_KEY_GETTERS = {
    'alt': function (event) { return event.altKey; },
    'control': function (event) { return event.ctrlKey; },
    'meta': function (event) { return event.metaKey; },
    'shift': function (event) { return event.shiftKey; }
};
/**
 * \@experimental
 */
var KeyEventsPlugin = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](KeyEventsPlugin, _super);
    /**
     * @param {?} doc
     */
    function KeyEventsPlugin(doc) {
        return _super.call(this, doc) || this;
    }
    /**
     * @param {?} eventName
     * @return {?}
     */
    KeyEventsPlugin.prototype.supports = function (eventName) { return KeyEventsPlugin.parseEventName(eventName) != null; };
    /**
     * @param {?} element
     * @param {?} eventName
     * @param {?} handler
     * @return {?}
     */
    KeyEventsPlugin.prototype.addEventListener = function (element, eventName, handler) {
        var /** @type {?} */ parsedEvent = ((KeyEventsPlugin.parseEventName(eventName)));
        var /** @type {?} */ outsideHandler = KeyEventsPlugin.eventCallback(parsedEvent['fullKey'], handler, this.manager.getZone());
        return this.manager.getZone().runOutsideAngular(function () {
            return getDOM().onAndCancel(element, parsedEvent['domEventName'], outsideHandler);
        });
    };
    /**
     * @param {?} eventName
     * @return {?}
     */
    KeyEventsPlugin.parseEventName = function (eventName) {
        var /** @type {?} */ parts = eventName.toLowerCase().split('.');
        var /** @type {?} */ domEventName = parts.shift();
        if ((parts.length === 0) || !(domEventName === 'keydown' || domEventName === 'keyup')) {
            return null;
        }
        var /** @type {?} */ key = KeyEventsPlugin._normalizeKey(/** @type {?} */ ((parts.pop())));
        var /** @type {?} */ fullKey = '';
        MODIFIER_KEYS.forEach(function (modifierName) {
            var /** @type {?} */ index = parts.indexOf(modifierName);
            if (index > -1) {
                parts.splice(index, 1);
                fullKey += modifierName + '.';
            }
        });
        fullKey += key;
        if (parts.length != 0 || key.length === 0) {
            // returning null instead of throwing to let another plugin process the event
            return null;
        }
        var /** @type {?} */ result = {};
        result['domEventName'] = domEventName;
        result['fullKey'] = fullKey;
        return result;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    KeyEventsPlugin.getEventFullKey = function (event) {
        var /** @type {?} */ fullKey = '';
        var /** @type {?} */ key = getDOM().getEventKey(event);
        key = key.toLowerCase();
        if (key === ' ') {
            key = 'space'; // for readability
        }
        else if (key === '.') {
            key = 'dot'; // because '.' is used as a separator in event names
        }
        MODIFIER_KEYS.forEach(function (modifierName) {
            if (modifierName != key) {
                var /** @type {?} */ modifierGetter = MODIFIER_KEY_GETTERS[modifierName];
                if (modifierGetter(event)) {
                    fullKey += modifierName + '.';
                }
            }
        });
        fullKey += key;
        return fullKey;
    };
    /**
     * @param {?} fullKey
     * @param {?} handler
     * @param {?} zone
     * @return {?}
     */
    KeyEventsPlugin.eventCallback = function (fullKey, handler, zone) {
        return function (event /** TODO #9100 */) {
            if (KeyEventsPlugin.getEventFullKey(event) === fullKey) {
                zone.runGuarded(function () { return handler(event); });
            }
        };
    };
    /**
     * \@internal
     * @param {?} keyName
     * @return {?}
     */
    KeyEventsPlugin._normalizeKey = function (keyName) {
        // TODO: switch to a Map if the mapping grows too much
        switch (keyName) {
            case 'esc':
                return 'escape';
            default:
                return keyName;
        }
    };
    return KeyEventsPlugin;
}(EventManagerPlugin));
KeyEventsPlugin.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"] },
];
/**
 * @nocollapse
 */
KeyEventsPlugin.ctorParameters = function () { return [
    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Inject"], args: [DOCUMENT$1,] },] },
]; };
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * A pattern that recognizes a commonly useful subset of URLs that are safe.
 *
 * This regular expression matches a subset of URLs that will not cause script
 * execution if used in URL context within a HTML document. Specifically, this
 * regular expression matches if (comment from here on and regex copied from
 * Soy's EscapingConventions):
 * (1) Either a protocol in a whitelist (http, https, mailto or ftp).
 * (2) or no protocol.  A protocol must be followed by a colon. The below
 *     allows that by allowing colons only after one of the characters [/?#].
 *     A colon after a hash (#) must be in the fragment.
 *     Otherwise, a colon after a (?) must be in a query.
 *     Otherwise, a colon after a single solidus (/) must be in a path.
 *     Otherwise, a colon after a double solidus (//) must be in the authority
 *     (before port).
 *
 * The pattern disallows &, used in HTML entity declarations before
 * one of the characters in [/?#]. This disallows HTML entities used in the
 * protocol name, which should never happen, e.g. "h&#116;tp" for "http".
 * It also disallows HTML entities in the first path part of a relative path,
 * e.g. "foo&lt;bar/baz".  Our existing escaping functions should not produce
 * that. More importantly, it disallows masking of a colon,
 * e.g. "javascript&#58;...".
 *
 * This regular expression was taken from the Closure sanitization library.
 */
var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi;
/**
 * A pattern that matches safe data URLs. Only matches image, video and audio types.
 */
var DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i;
/**
 * @param {?} url
 * @return {?}
 */
function sanitizeUrl(url) {
    url = String(url);
    if (url.match(SAFE_URL_PATTERN) || url.match(DATA_URL_PATTERN))
        return url;
    if (Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["isDevMode"])()) {
        getDOM().log("WARNING: sanitizing unsafe URL value " + url + " (see http://g.co/ng/security#xss)");
    }
    return 'unsafe:' + url;
}
/**
 * @param {?} srcset
 * @return {?}
 */
function sanitizeSrcset(srcset) {
    srcset = String(srcset);
    return srcset.split(',').map(function (srcset) { return sanitizeUrl(srcset.trim()); }).join(', ');
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * A <body> element that can be safely used to parse untrusted HTML. Lazily initialized below.
 */
var inertElement = null;
/**
 * Lazily initialized to make sure the DOM adapter gets set before use.
 */
var DOM = null;
/**
 * Returns an HTML element that is guaranteed to not execute code when creating elements in it.
 * @return {?}
 */
function getInertElement() {
    if (inertElement)
        return inertElement;
    DOM = getDOM();
    // Prefer using <template> element if supported.
    var /** @type {?} */ templateEl = DOM.createElement('template');
    if ('content' in templateEl)
        return templateEl;
    var /** @type {?} */ doc = DOM.createHtmlDocument();
    inertElement = DOM.querySelector(doc, 'body');
    if (inertElement == null) {
        // usually there should be only one body element in the document, but IE doesn't have any, so we
        // need to create one.
        var /** @type {?} */ html = DOM.createElement('html', doc);
        inertElement = DOM.createElement('body', doc);
        DOM.appendChild(html, inertElement);
        DOM.appendChild(doc, html);
    }
    return inertElement;
}
/**
 * @param {?} tags
 * @return {?}
 */
function tagSet(tags) {
    var /** @type {?} */ res = {};
    for (var _i = 0, _a = tags.split(','); _i < _a.length; _i++) {
        var t = _a[_i];
        res[t] = true;
    }
    return res;
}
/**
 * @param {...?} sets
 * @return {?}
 */
function merge() {
    var sets = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sets[_i] = arguments[_i];
    }
    var /** @type {?} */ res = {};
    for (var _a = 0, sets_1 = sets; _a < sets_1.length; _a++) {
        var s = sets_1[_a];
        for (var /** @type {?} */ v in s) {
            if (s.hasOwnProperty(v))
                res[v] = true;
        }
    }
    return res;
}
// Good source of info about elements and attributes
// http://dev.w3.org/html5/spec/Overview.html#semantics
// http://simon.html5.org/html-elements
// Safe Void Elements - HTML5
// http://dev.w3.org/html5/spec/Overview.html#void-elements
var VOID_ELEMENTS = tagSet('area,br,col,hr,img,wbr');
// Elements that you can, intentionally, leave open (and which close themselves)
// http://dev.w3.org/html5/spec/Overview.html#optional-tags
var OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr');
var OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet('rp,rt');
var OPTIONAL_END_TAG_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS);
// Safe Block Elements - HTML5
var BLOCK_ELEMENTS = merge(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet('address,article,' +
    'aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,' +
    'h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul'));
// Inline Elements - HTML5
var INLINE_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet('a,abbr,acronym,audio,b,' +
    'bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,' +
    'samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video'));
var VALID_ELEMENTS = merge(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS);
// Attributes that have href and hence need to be sanitized
var URI_ATTRS = tagSet('background,cite,href,itemtype,longdesc,poster,src,xlink:href');
// Attributes that have special href set hence need to be sanitized
var SRCSET_ATTRS = tagSet('srcset');
var HTML_ATTRS = tagSet('abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,' +
    'compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,' +
    'ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,' +
    'scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,' +
    'valign,value,vspace,width');
// NB: This currently consciously doesn't support SVG. SVG sanitization has had several security
// issues in the past, so it seems safer to leave it out if possible. If support for binding SVG via
// innerHTML is required, SVG attributes should be added here.
// NB: Sanitization does not allow <form> elements or other active elements (<button> etc). Those
// can be sanitized, but they increase security surface area without a legitimate use case, so they
// are left out here.
var VALID_ATTRS = merge(URI_ATTRS, SRCSET_ATTRS, HTML_ATTRS);
/**
 * SanitizingHtmlSerializer serializes a DOM fragment, stripping out any unsafe elements and unsafe
 * attributes.
 */
var SanitizingHtmlSerializer = (function () {
    function SanitizingHtmlSerializer() {
        this.sanitizedSomething = false;
        this.buf = [];
    }
    /**
     * @param {?} el
     * @return {?}
     */
    SanitizingHtmlSerializer.prototype.sanitizeChildren = function (el) {
        // This cannot use a TreeWalker, as it has to run on Angular's various DOM adapters.
        // However this code never accesses properties off of `document` before deleting its contents
        // again, so it shouldn't be vulnerable to DOM clobbering.
        var /** @type {?} */ current = ((el.firstChild));
        while (current) {
            if (DOM.isElementNode(current)) {
                this.startElement(/** @type {?} */ (current));
            }
            else if (DOM.isTextNode(current)) {
                this.chars(/** @type {?} */ ((DOM.nodeValue(current))));
            }
            else {
                // Strip non-element, non-text nodes.
                this.sanitizedSomething = true;
            }
            if (DOM.firstChild(current)) {
                current = ((DOM.firstChild(current)));
                continue;
            }
            while (current) {
                // Leaving the element. Walk up and to the right, closing tags as we go.
                if (DOM.isElementNode(current)) {
                    this.endElement(/** @type {?} */ (current));
                }
                var /** @type {?} */ next = checkClobberedElement(current, /** @type {?} */ ((DOM.nextSibling(current))));
                if (next) {
                    current = next;
                    break;
                }
                current = checkClobberedElement(current, /** @type {?} */ ((DOM.parentElement(current))));
            }
        }
        return this.buf.join('');
    };
    /**
     * @param {?} element
     * @return {?}
     */
    SanitizingHtmlSerializer.prototype.startElement = function (element) {
        var _this = this;
        var /** @type {?} */ tagName = DOM.nodeName(element).toLowerCase();
        if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {
            this.sanitizedSomething = true;
            return;
        }
        this.buf.push('<');
        this.buf.push(tagName);
        DOM.attributeMap(element).forEach(function (value, attrName) {
            var /** @type {?} */ lower = attrName.toLowerCase();
            if (!VALID_ATTRS.hasOwnProperty(lower)) {
                _this.sanitizedSomething = true;
                return;
            }
            // TODO(martinprobst): Special case image URIs for data:image/...
            if (URI_ATTRS[lower])
                value = sanitizeUrl(value);
            if (SRCSET_ATTRS[lower])
                value = sanitizeSrcset(value);
            _this.buf.push(' ');
            _this.buf.push(attrName);
            _this.buf.push('="');
            _this.buf.push(encodeEntities(value));
            _this.buf.push('"');
        });
        this.buf.push('>');
    };
    /**
     * @param {?} current
     * @return {?}
     */
    SanitizingHtmlSerializer.prototype.endElement = function (current) {
        var /** @type {?} */ tagName = DOM.nodeName(current).toLowerCase();
        if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {
            this.buf.push('</');
            this.buf.push(tagName);
            this.buf.push('>');
        }
    };
    /**
     * @param {?} chars
     * @return {?}
     */
    SanitizingHtmlSerializer.prototype.chars = function (chars) { this.buf.push(encodeEntities(chars)); };
    return SanitizingHtmlSerializer;
}());
/**
 * @param {?} node
 * @param {?} nextNode
 * @return {?}
 */
function checkClobberedElement(node, nextNode) {
    if (nextNode && DOM.contains(node, nextNode)) {
        throw new Error("Failed to sanitize html because the element is clobbered: " + DOM.getOuterHTML(node));
    }
    return nextNode;
}
// Regular Expressions for parsing tags and attributes
var SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
// ! to ~ is the ASCII range.
var NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;
/**
 * Escapes all potentially dangerous characters, so that the
 * resulting string can be safely inserted into attribute or
 * element text.
 * @param {?} value
 * @return {?}
 */
function encodeEntities(value) {
    return value.replace(/&/g, '&amp;')
        .replace(SURROGATE_PAIR_REGEXP, function (match) {
        var /** @type {?} */ hi = match.charCodeAt(0);
        var /** @type {?} */ low = match.charCodeAt(1);
        return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';
    })
        .replace(NON_ALPHANUMERIC_REGEXP, function (match) { return '&#' + match.charCodeAt(0) + ';'; })
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
}
/**
 * When IE9-11 comes across an unknown namespaced attribute e.g. 'xlink:foo' it adds 'xmlns:ns1'
 * attribute to declare ns1 namespace and prefixes the attribute with 'ns1' (e.g. 'ns1:xlink:foo').
 *
 * This is undesirable since we don't want to allow any of these custom attributes. This method
 * strips them all.
 * @param {?} el
 * @return {?}
 */
function stripCustomNsAttrs(el) {
    DOM.attributeMap(el).forEach(function (_, attrName) {
        if (attrName === 'xmlns:ns1' || attrName.indexOf('ns1:') === 0) {
            DOM.removeAttribute(el, attrName);
        }
    });
    for (var _i = 0, _a = DOM.childNodesAsList(el); _i < _a.length; _i++) {
        var n = _a[_i];
        if (DOM.isElementNode(n))
            stripCustomNsAttrs(/** @type {?} */ (n));
    }
}
/**
 * Sanitizes the given unsafe, untrusted HTML fragment, and returns HTML text that is safe to add to
 * the DOM in a browser environment.
 * @param {?} defaultDoc
 * @param {?} unsafeHtmlInput
 * @return {?}
 */
function sanitizeHtml(defaultDoc, unsafeHtmlInput) {
    try {
        var /** @type {?} */ containerEl = getInertElement();
        // Make sure unsafeHtml is actually a string (TypeScript types are not enforced at runtime).
        var /** @type {?} */ unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : '';
        // mXSS protection. Repeatedly parse the document to make sure it stabilizes, so that a browser
        // trying to auto-correct incorrect HTML cannot cause formerly inert HTML to become dangerous.
        var /** @type {?} */ mXSSAttempts = 5;
        var /** @type {?} */ parsedHtml = unsafeHtml;
        do {
            if (mXSSAttempts === 0) {
                throw new Error('Failed to sanitize html because the input is unstable');
            }
            mXSSAttempts--;
            unsafeHtml = parsedHtml;
            DOM.setInnerHTML(containerEl, unsafeHtml);
            if (defaultDoc.documentMode) {
                // strip custom-namespaced attributes on IE<=11
                stripCustomNsAttrs(containerEl);
            }
            parsedHtml = DOM.getInnerHTML(containerEl);
        } while (unsafeHtml !== parsedHtml);
        var /** @type {?} */ sanitizer = new SanitizingHtmlSerializer();
        var /** @type {?} */ safeHtml = sanitizer.sanitizeChildren(DOM.getTemplateContent(containerEl) || containerEl);
        // Clear out the body element.
        var /** @type {?} */ parent = DOM.getTemplateContent(containerEl) || containerEl;
        for (var _i = 0, _a = DOM.childNodesAsList(parent); _i < _a.length; _i++) {
            var child = _a[_i];
            DOM.removeChild(parent, child);
        }
        if (Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["isDevMode"])() && sanitizer.sanitizedSomething) {
            DOM.log('WARNING: sanitizing HTML stripped some content (see http://g.co/ng/security#xss).');
        }
        return safeHtml;
    }
    catch (e) {
        // In case anything goes wrong, clear out inertElement to reset the entire DOM structure.
        inertElement = null;
        throw e;
    }
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Regular expression for safe style values.
 *
 * Quotes (" and ') are allowed, but a check must be done elsewhere to ensure they're balanced.
 *
 * ',' allows multiple values to be assigned to the same property (e.g. background-attachment or
 * font-family) and hence could allow multiple values to get injected, but that should pose no risk
 * of XSS.
 *
 * The function expression checks only for XSS safety, not for CSS validity.
 *
 * This regular expression was taken from the Closure sanitization library, and augmented for
 * transformation values.
 */
var VALUES = '[-,."\'%_!# a-zA-Z0-9]+';
var TRANSFORMATION_FNS = '(?:matrix|translate|scale|rotate|skew|perspective)(?:X|Y|3d)?';
var COLOR_FNS = '(?:rgb|hsl)a?';
var GRADIENTS = '(?:repeating-)?(?:linear|radial)-gradient';
var CSS3_FNS = '(?:calc|attr)';
var FN_ARGS = '\\([-0-9.%, #a-zA-Z]+\\)';
var SAFE_STYLE_VALUE = new RegExp("^(" + VALUES + "|" +
    ("(?:" + TRANSFORMATION_FNS + "|" + COLOR_FNS + "|" + GRADIENTS + "|" + CSS3_FNS + ")") +
    (FN_ARGS + ")$"), 'g');
/**
 * Matches a `url(...)` value with an arbitrary argument as long as it does
 * not contain parentheses.
 *
 * The URL value still needs to be sanitized separately.
 *
 * `url(...)` values are a very common use case, e.g. for `background-image`. With carefully crafted
 * CSS style rules, it is possible to construct an information leak with `url` values in CSS, e.g.
 * by observing whether scroll bars are displayed, or character ranges used by a font face
 * definition.
 *
 * Angular only allows binding CSS values (as opposed to entire CSS rules), so it is unlikely that
 * binding a URL value without further cooperation from the page will cause an information leak, and
 * if so, it is just a leak, not a full blown XSS vulnerability.
 *
 * Given the common use case, low likelihood of attack vector, and low impact of an attack, this
 * code is permissive and allows URLs that sanitize otherwise.
 */
var URL_RE = /^url\(([^)]+)\)$/;
/**
 * Checks that quotes (" and ') are properly balanced inside a string. Assumes
 * that neither escape (\) nor any other character that could result in
 * breaking out of a string parsing context are allowed;
 * see http://www.w3.org/TR/css3-syntax/#string-token-diagram.
 *
 * This code was taken from the Closure sanitization library.
 * @param {?} value
 * @return {?}
 */
function hasBalancedQuotes(value) {
    var /** @type {?} */ outsideSingle = true;
    var /** @type {?} */ outsideDouble = true;
    for (var /** @type {?} */ i = 0; i < value.length; i++) {
        var /** @type {?} */ c = value.charAt(i);
        if (c === '\'' && outsideDouble) {
            outsideSingle = !outsideSingle;
        }
        else if (c === '"' && outsideSingle) {
            outsideDouble = !outsideDouble;
        }
    }
    return outsideSingle && outsideDouble;
}
/**
 * Sanitizes the given untrusted CSS style property value (i.e. not an entire object, just a single
 * value) and returns a value that is safe to use in a browser environment.
 * @param {?} value
 * @return {?}
 */
function sanitizeStyle(value) {
    value = String(value).trim(); // Make sure it's actually a string.
    if (!value)
        return '';
    // Single url(...) values are supported, but only for URLs that sanitize cleanly. See above for
    // reasoning behind this.
    var /** @type {?} */ urlMatch = value.match(URL_RE);
    if ((urlMatch && sanitizeUrl(urlMatch[1]) === urlMatch[1]) ||
        value.match(SAFE_STYLE_VALUE) && hasBalancedQuotes(value)) {
        return value; // Safe style values.
    }
    if (Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["isDevMode"])()) {
        getDOM().log("WARNING: sanitizing unsafe style value " + value + " (see http://g.co/ng/security#xss).");
    }
    return 'unsafe';
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * DomSanitizer helps preventing Cross Site Scripting Security bugs (XSS) by sanitizing
 * values to be safe to use in the different DOM contexts.
 *
 * For example, when binding a URL in an `<a [href]="someValue">` hyperlink, `someValue` will be
 * sanitized so that an attacker cannot inject e.g. a `javascript:` URL that would execute code on
 * the website.
 *
 * In specific situations, it might be necessary to disable sanitization, for example if the
 * application genuinely needs to produce a `javascript:` style link with a dynamic value in it.
 * Users can bypass security by constructing a value with one of the `bypassSecurityTrust...`
 * methods, and then binding to that value from the template.
 *
 * These situations should be very rare, and extraordinary care must be taken to avoid creating a
 * Cross Site Scripting (XSS) security bug!
 *
 * When using `bypassSecurityTrust...`, make sure to call the method as early as possible and as
 * close as possible to the source of the value, to make it easy to verify no security bug is
 * created by its use.
 *
 * It is not required (and not recommended) to bypass security if the value is safe, e.g. a URL that
 * does not start with a suspicious protocol, or an HTML snippet that does not contain dangerous
 * code. The sanitizer leaves safe values intact.
 *
 * \@security Calling any of the `bypassSecurityTrust...` APIs disables Angular's built-in
 * sanitization for the value passed in. Carefully check and audit all values and code paths going
 * into this call. Make sure any user data is appropriately escaped for this security context.
 * For more detail, see the [Security Guide](http://g.co/ng/security).
 *
 * \@stable
 * @abstract
 */
var DomSanitizer = (function () {
    function DomSanitizer() {
    }
    /**
     * Sanitizes a value for use in the given SecurityContext.
     *
     * If value is trusted for the context, this method will unwrap the contained safe value and use
     * it directly. Otherwise, value will be sanitized to be safe in the given context, for example
     * by replacing URLs that have an unsafe protocol part (such as `javascript:`). The implementation
     * is responsible to make sure that the value can definitely be safely used in the given context.
     * @abstract
     * @param {?} context
     * @param {?} value
     * @return {?}
     */
    DomSanitizer.prototype.sanitize = function (context, value) { };
    /**
     * Bypass security and trust the given value to be safe HTML. Only use this when the bound HTML
     * is unsafe (e.g. contains `<script>` tags) and the code should be executed. The sanitizer will
     * leave safe HTML intact, so in most situations this method should not be used.
     *
     * **WARNING:** calling this method with untrusted user data exposes your application to XSS
     * security risks!
     * @abstract
     * @param {?} value
     * @return {?}
     */
    DomSanitizer.prototype.bypassSecurityTrustHtml = function (value) { };
    /**
     * Bypass security and trust the given value to be safe style value (CSS).
     *
     * **WARNING:** calling this method with untrusted user data exposes your application to XSS
     * security risks!
     * @abstract
     * @param {?} value
     * @return {?}
     */
    DomSanitizer.prototype.bypassSecurityTrustStyle = function (value) { };
    /**
     * Bypass security and trust the given value to be safe JavaScript.
     *
     * **WARNING:** calling this method with untrusted user data exposes your application to XSS
     * security risks!
     * @abstract
     * @param {?} value
     * @return {?}
     */
    DomSanitizer.prototype.bypassSecurityTrustScript = function (value) { };
    /**
     * Bypass security and trust the given value to be a safe style URL, i.e. a value that can be used
     * in hyperlinks or `<img src>`.
     *
     * **WARNING:** calling this method with untrusted user data exposes your application to XSS
     * security risks!
     * @abstract
     * @param {?} value
     * @return {?}
     */
    DomSanitizer.prototype.bypassSecurityTrustUrl = function (value) { };
    /**
     * Bypass security and trust the given value to be a safe resource URL, i.e. a location that may
     * be used to load executable code from, like `<script src>`, or `<iframe src>`.
     *
     * **WARNING:** calling this method with untrusted user data exposes your application to XSS
     * security risks!
     * @abstract
     * @param {?} value
     * @return {?}
     */
    DomSanitizer.prototype.bypassSecurityTrustResourceUrl = function (value) { };
    return DomSanitizer;
}());
var DomSanitizerImpl = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](DomSanitizerImpl, _super);
    /**
     * @param {?} _doc
     */
    function DomSanitizerImpl(_doc) {
        var _this = _super.call(this) || this;
        _this._doc = _doc;
        return _this;
    }
    /**
     * @param {?} ctx
     * @param {?} value
     * @return {?}
     */
    DomSanitizerImpl.prototype.sanitize = function (ctx, value) {
        if (value == null)
            return null;
        switch (ctx) {
            case __WEBPACK_IMPORTED_MODULE_2__angular_core__["SecurityContext"].NONE:
                return (value);
            case __WEBPACK_IMPORTED_MODULE_2__angular_core__["SecurityContext"].HTML:
                if (value instanceof SafeHtmlImpl)
                    return value.changingThisBreaksApplicationSecurity;
                this.checkNotSafeValue(value, 'HTML');
                return sanitizeHtml(this._doc, String(value));
            case __WEBPACK_IMPORTED_MODULE_2__angular_core__["SecurityContext"].STYLE:
                if (value instanceof SafeStyleImpl)
                    return value.changingThisBreaksApplicationSecurity;
                this.checkNotSafeValue(value, 'Style');
                return sanitizeStyle(/** @type {?} */ (value));
            case __WEBPACK_IMPORTED_MODULE_2__angular_core__["SecurityContext"].SCRIPT:
                if (value instanceof SafeScriptImpl)
                    return value.changingThisBreaksApplicationSecurity;
                this.checkNotSafeValue(value, 'Script');
                throw new Error('unsafe value used in a script context');
            case __WEBPACK_IMPORTED_MODULE_2__angular_core__["SecurityContext"].URL:
                if (value instanceof SafeResourceUrlImpl || value instanceof SafeUrlImpl) {
                    // Allow resource URLs in URL contexts, they are strictly more trusted.
                    return value.changingThisBreaksApplicationSecurity;
                }
                this.checkNotSafeValue(value, 'URL');
                return sanitizeUrl(String(value));
            case __WEBPACK_IMPORTED_MODULE_2__angular_core__["SecurityContext"].RESOURCE_URL:
                if (value instanceof SafeResourceUrlImpl) {
                    return value.changingThisBreaksApplicationSecurity;
                }
                this.checkNotSafeValue(value, 'ResourceURL');
                throw new Error('unsafe value used in a resource URL context (see http://g.co/ng/security#xss)');
            default:
                throw new Error("Unexpected SecurityContext " + ctx + " (see http://g.co/ng/security#xss)");
        }
    };
    /**
     * @param {?} value
     * @param {?} expectedType
     * @return {?}
     */
    DomSanitizerImpl.prototype.checkNotSafeValue = function (value, expectedType) {
        if (value instanceof SafeValueImpl) {
            throw new Error("Required a safe " + expectedType + ", got a " + value.getTypeName() + " " +
                "(see http://g.co/ng/security#xss)");
        }
    };
    /**
     * @param {?} value
     * @return {?}
     */
    DomSanitizerImpl.prototype.bypassSecurityTrustHtml = function (value) { return new SafeHtmlImpl(value); };
    /**
     * @param {?} value
     * @return {?}
     */
    DomSanitizerImpl.prototype.bypassSecurityTrustStyle = function (value) { return new SafeStyleImpl(value); };
    /**
     * @param {?} value
     * @return {?}
     */
    DomSanitizerImpl.prototype.bypassSecurityTrustScript = function (value) { return new SafeScriptImpl(value); };
    /**
     * @param {?} value
     * @return {?}
     */
    DomSanitizerImpl.prototype.bypassSecurityTrustUrl = function (value) { return new SafeUrlImpl(value); };
    /**
     * @param {?} value
     * @return {?}
     */
    DomSanitizerImpl.prototype.bypassSecurityTrustResourceUrl = function (value) {
        return new SafeResourceUrlImpl(value);
    };
    return DomSanitizerImpl;
}(DomSanitizer));
DomSanitizerImpl.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"] },
];
/**
 * @nocollapse
 */
DomSanitizerImpl.ctorParameters = function () { return [
    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Inject"], args: [DOCUMENT$1,] },] },
]; };
/**
 * @abstract
 */
var SafeValueImpl = (function () {
    /**
     * @param {?} changingThisBreaksApplicationSecurity
     */
    function SafeValueImpl(changingThisBreaksApplicationSecurity) {
        this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;
        // empty
    }
    /**
     * @abstract
     * @return {?}
     */
    SafeValueImpl.prototype.getTypeName = function () { };
    /**
     * @return {?}
     */
    SafeValueImpl.prototype.toString = function () {
        return "SafeValue must use [property]=binding: " + this.changingThisBreaksApplicationSecurity +
            " (see http://g.co/ng/security#xss)";
    };
    return SafeValueImpl;
}());
var SafeHtmlImpl = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](SafeHtmlImpl, _super);
    function SafeHtmlImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @return {?}
     */
    SafeHtmlImpl.prototype.getTypeName = function () { return 'HTML'; };
    return SafeHtmlImpl;
}(SafeValueImpl));
var SafeStyleImpl = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](SafeStyleImpl, _super);
    function SafeStyleImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @return {?}
     */
    SafeStyleImpl.prototype.getTypeName = function () { return 'Style'; };
    return SafeStyleImpl;
}(SafeValueImpl));
var SafeScriptImpl = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](SafeScriptImpl, _super);
    function SafeScriptImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @return {?}
     */
    SafeScriptImpl.prototype.getTypeName = function () { return 'Script'; };
    return SafeScriptImpl;
}(SafeValueImpl));
var SafeUrlImpl = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](SafeUrlImpl, _super);
    function SafeUrlImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @return {?}
     */
    SafeUrlImpl.prototype.getTypeName = function () { return 'URL'; };
    return SafeUrlImpl;
}(SafeValueImpl));
var SafeResourceUrlImpl = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](SafeResourceUrlImpl, _super);
    function SafeResourceUrlImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @return {?}
     */
    SafeResourceUrlImpl.prototype.getTypeName = function () { return 'ResourceURL'; };
    return SafeResourceUrlImpl;
}(SafeValueImpl));
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var INTERNAL_BROWSER_PLATFORM_PROVIDERS = [
    { provide: __WEBPACK_IMPORTED_MODULE_2__angular_core__["PLATFORM_ID"], useValue: __WEBPACK_IMPORTED_MODULE_1__angular_common__["ɵPLATFORM_BROWSER_ID"] },
    { provide: __WEBPACK_IMPORTED_MODULE_2__angular_core__["PLATFORM_INITIALIZER"], useValue: initDomAdapter, multi: true },
    { provide: __WEBPACK_IMPORTED_MODULE_1__angular_common__["PlatformLocation"], useClass: BrowserPlatformLocation },
    { provide: DOCUMENT$1, useFactory: _document, deps: [] },
];
/**
 * \@security Replacing built-in sanitization providers exposes the application to XSS risks.
 * Attacker-controlled data introduced by an unsanitized provider could expose your
 * application to XSS risks. For more detail, see the [Security Guide](http://g.co/ng/security).
 * \@experimental
 */
var BROWSER_SANITIZATION_PROVIDERS = [
    { provide: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Sanitizer"], useExisting: DomSanitizer },
    { provide: DomSanitizer, useClass: DomSanitizerImpl },
];
/**
 * \@stable
 */
var platformBrowser = Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["createPlatformFactory"])(__WEBPACK_IMPORTED_MODULE_2__angular_core__["platformCore"], 'browser', INTERNAL_BROWSER_PLATFORM_PROVIDERS);
/**
 * @return {?}
 */
function initDomAdapter() {
    BrowserDomAdapter.makeCurrent();
    BrowserGetTestability.init();
}
/**
 * @return {?}
 */
function errorHandler() {
    return new __WEBPACK_IMPORTED_MODULE_2__angular_core__["ErrorHandler"]();
}
/**
 * @return {?}
 */
function _document() {
    return document;
}
/**
 * The ng module for the browser.
 *
 * \@stable
 */
var BrowserModule = (function () {
    /**
     * @param {?} parentModule
     */
    function BrowserModule(parentModule) {
        if (parentModule) {
            throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.");
        }
    }
    /**
     * Configures a browser-based application to transition from a server-rendered app, if
     * one is present on the page. The specified parameters must include an application id,
     * which must match between the client and server applications.
     *
     * \@experimental
     * @param {?} params
     * @return {?}
     */
    BrowserModule.withServerTransition = function (params) {
        return {
            ngModule: BrowserModule,
            providers: [
                { provide: __WEBPACK_IMPORTED_MODULE_2__angular_core__["APP_ID"], useValue: params.appId },
                { provide: TRANSITION_ID, useExisting: __WEBPACK_IMPORTED_MODULE_2__angular_core__["APP_ID"] },
                SERVER_TRANSITION_PROVIDERS,
            ],
        };
    };
    return BrowserModule;
}());
BrowserModule.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["NgModule"], args: [{
                providers: [
                    BROWSER_SANITIZATION_PROVIDERS,
                    { provide: __WEBPACK_IMPORTED_MODULE_2__angular_core__["ErrorHandler"], useFactory: errorHandler, deps: [] },
                    { provide: EVENT_MANAGER_PLUGINS, useClass: DomEventsPlugin, multi: true },
                    { provide: EVENT_MANAGER_PLUGINS, useClass: KeyEventsPlugin, multi: true },
                    { provide: EVENT_MANAGER_PLUGINS, useClass: HammerGesturesPlugin, multi: true },
                    { provide: HAMMER_GESTURE_CONFIG, useClass: HammerGestureConfig },
                    DomRendererFactory2,
                    { provide: __WEBPACK_IMPORTED_MODULE_2__angular_core__["RendererFactory2"], useExisting: DomRendererFactory2 },
                    { provide: SharedStylesHost, useExisting: DomSharedStylesHost },
                    DomSharedStylesHost,
                    __WEBPACK_IMPORTED_MODULE_2__angular_core__["Testability"],
                    EventManager,
                    ELEMENT_PROBE_PROVIDERS,
                    Meta,
                    Title,
                ],
                exports: [__WEBPACK_IMPORTED_MODULE_1__angular_common__["CommonModule"], __WEBPACK_IMPORTED_MODULE_2__angular_core__["ApplicationModule"]]
            },] },
];
/**
 * @nocollapse
 */
BrowserModule.ctorParameters = function () { return [
    { type: BrowserModule, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["SkipSelf"] },] },
]; };
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var win = typeof window !== 'undefined' && window || {};
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var ChangeDetectionPerfRecord = (function () {
    /**
     * @param {?} msPerTick
     * @param {?} numTicks
     */
    function ChangeDetectionPerfRecord(msPerTick, numTicks) {
        this.msPerTick = msPerTick;
        this.numTicks = numTicks;
    }
    return ChangeDetectionPerfRecord;
}());
/**
 * Entry point for all Angular profiling-related debug tools. This object
 * corresponds to the `ng.profiler` in the dev console.
 */
var AngularProfiler = (function () {
    /**
     * @param {?} ref
     */
    function AngularProfiler(ref) {
        this.appRef = ref.injector.get(__WEBPACK_IMPORTED_MODULE_2__angular_core__["ApplicationRef"]);
    }
    /**
     * Exercises change detection in a loop and then prints the average amount of
     * time in milliseconds how long a single round of change detection takes for
     * the current state of the UI. It runs a minimum of 5 rounds for a minimum
     * of 500 milliseconds.
     *
     * Optionally, a user may pass a `config` parameter containing a map of
     * options. Supported options are:
     *
     * `record` (boolean) - causes the profiler to record a CPU profile while
     * it exercises the change detector. Example:
     *
     * ```
     * ng.profiler.timeChangeDetection({record: true})
     * ```
     * @param {?} config
     * @return {?}
     */
    AngularProfiler.prototype.timeChangeDetection = function (config) {
        var /** @type {?} */ record = config && config['record'];
        var /** @type {?} */ profileName = 'Change Detection';
        // Profiler is not available in Android browsers, nor in IE 9 without dev tools opened
        var /** @type {?} */ isProfilerAvailable = win.console.profile != null;
        if (record && isProfilerAvailable) {
            win.console.profile(profileName);
        }
        var /** @type {?} */ start = getDOM().performanceNow();
        var /** @type {?} */ numTicks = 0;
        while (numTicks < 5 || (getDOM().performanceNow() - start) < 500) {
            this.appRef.tick();
            numTicks++;
        }
        var /** @type {?} */ end = getDOM().performanceNow();
        if (record && isProfilerAvailable) {
            // need to cast to <any> because type checker thinks there's no argument
            // while in fact there is:
            //
            // https://developer.mozilla.org/en-US/docs/Web/API/Console/profileEnd
            ((win.console.profileEnd))(profileName);
        }
        var /** @type {?} */ msPerTick = (end - start) / numTicks;
        win.console.log("ran " + numTicks + " change detection cycles");
        win.console.log(msPerTick.toFixed(2) + " ms per check");
        return new ChangeDetectionPerfRecord(msPerTick, numTicks);
    };
    return AngularProfiler;
}());
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var PROFILER_GLOBAL_NAME = 'profiler';
/**
 * Enabled Angular debug tools that are accessible via your browser's
 * developer console.
 *
 * Usage:
 *
 * 1. Open developer console (e.g. in Chrome Ctrl + Shift + j)
 * 1. Type `ng.` (usually the console will show auto-complete suggestion)
 * 1. Try the change detection profiler `ng.profiler.timeChangeDetection()`
 *    then hit Enter.
 *
 * \@experimental All debugging apis are currently experimental.
 * @template T
 * @param {?} ref
 * @return {?}
 */
function enableDebugTools(ref) {
    exportNgVar(PROFILER_GLOBAL_NAME, new AngularProfiler(ref));
    return ref;
}
/**
 * Disables Angular tools.
 *
 * \@experimental All debugging apis are currently experimental.
 * @return {?}
 */
function disableDebugTools() {
    exportNgVar(PROFILER_GLOBAL_NAME, null);
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Predicates for use with {\@link DebugElement}'s query functions.
 *
 * \@experimental All debugging apis are currently experimental.
 */
var By = (function () {
    function By() {
    }
    /**
     * Match all elements.
     *
     * ## Example
     *
     * {\@example platform-browser/dom/debug/ts/by/by.ts region='by_all'}
     * @return {?}
     */
    By.all = function () { return function (debugElement) { return true; }; };
    /**
     * Match elements by the given CSS selector.
     *
     * ## Example
     *
     * {\@example platform-browser/dom/debug/ts/by/by.ts region='by_css'}
     * @param {?} selector
     * @return {?}
     */
    By.css = function (selector) {
        return function (debugElement) {
            return debugElement.nativeElement != null ?
                getDOM().elementMatches(debugElement.nativeElement, selector) :
                false;
        };
    };
    /**
     * Match elements that have the given directive present.
     *
     * ## Example
     *
     * {\@example platform-browser/dom/debug/ts/by/by.ts region='by_directive'}
     * @param {?} type
     * @return {?}
     */
    By.directive = function (type) {
        return function (debugElement) { return ((debugElement.providerTokens)).indexOf(type) !== -1; };
    };
    return By;
}());
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @module
 * @description
 * Entry point for all public APIs of the common package.
 */
/**
 * \@stable
 */
var VERSION = new __WEBPACK_IMPORTED_MODULE_2__angular_core__["Version"]('4.3.5');
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @module
 * @description
 * Entry point for all public APIs of the platform-browser package.
 */
// This file only reexports content of the `src` folder. Keep it that way.
/**
 * Generated bundle index. Do not edit.
 */

//# sourceMappingURL=platform-browser.es5.js.map


/***/ }),

/***/ "../../../platform-browser/@angular/platform-browser/animations.es5.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BrowserAnimationsModule; });
/* unused harmony export NoopAnimationsModule */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return BrowserAnimationBuilder; });
/* unused harmony export ɵBrowserAnimationFactory */
/* unused harmony export ɵAnimationRenderer */
/* unused harmony export ɵAnimationRendererFactory */
/* unused harmony export ɵa */
/* unused harmony export ɵf */
/* unused harmony export ɵg */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return InjectableAnimationEngine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return instantiateDefaultStyleNormalizer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return instantiateRendererFactory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return instantiateSupportedAnimationDriver; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__("../../../../tslib/tslib.es6.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__("../../../core/@angular/core.es5.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_platform_browser__ = __webpack_require__("../../../platform-browser/@angular/platform-browser.es5.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__angular_animations__ = __webpack_require__("../../../animations/@angular/animations.es5.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__ = __webpack_require__("../../../animations/@angular/animations/browser.es5.js");

/**
 * @license Angular v4.3.5
 * (c) 2010-2017 Google, Inc. https://angular.io/
 * License: MIT
 */




/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var BrowserAnimationBuilder = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](BrowserAnimationBuilder, _super);
    /**
     * @param {?} rootRenderer
     */
    function BrowserAnimationBuilder(rootRenderer) {
        var _this = _super.call(this) || this;
        _this._nextAnimationId = 0;
        var typeData = {
            id: '0',
            encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewEncapsulation"].None,
            styles: [],
            data: { animation: [] }
        };
        _this._renderer = rootRenderer.createRenderer(document.body, typeData);
        return _this;
    }
    /**
     * @param {?} animation
     * @return {?}
     */
    BrowserAnimationBuilder.prototype.build = function (animation) {
        var /** @type {?} */ id = this._nextAnimationId.toString();
        this._nextAnimationId++;
        var /** @type {?} */ entry = Array.isArray(animation) ? Object(__WEBPACK_IMPORTED_MODULE_3__angular_animations__["sequence"])(animation) : animation;
        issueAnimationCommand(this._renderer, null, id, 'register', [entry]);
        return new BrowserAnimationFactory(id, this._renderer);
    };
    return BrowserAnimationBuilder;
}(__WEBPACK_IMPORTED_MODULE_3__angular_animations__["AnimationBuilder"]));
BrowserAnimationBuilder.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"] },
];
/**
 * @nocollapse
 */
BrowserAnimationBuilder.ctorParameters = function () { return [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["RendererFactory2"], },
]; };
var BrowserAnimationFactory = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](BrowserAnimationFactory, _super);
    /**
     * @param {?} _id
     * @param {?} _renderer
     */
    function BrowserAnimationFactory(_id, _renderer) {
        var _this = _super.call(this) || this;
        _this._id = _id;
        _this._renderer = _renderer;
        return _this;
    }
    /**
     * @param {?} element
     * @param {?=} options
     * @return {?}
     */
    BrowserAnimationFactory.prototype.create = function (element, options) {
        return new RendererAnimationPlayer(this._id, element, options || {}, this._renderer);
    };
    return BrowserAnimationFactory;
}(__WEBPACK_IMPORTED_MODULE_3__angular_animations__["AnimationFactory"]));
var RendererAnimationPlayer = (function () {
    /**
     * @param {?} id
     * @param {?} element
     * @param {?} options
     * @param {?} _renderer
     */
    function RendererAnimationPlayer(id, element, options, _renderer) {
        this.id = id;
        this.element = element;
        this._renderer = _renderer;
        this.parentPlayer = null;
        this._started = false;
        this.totalTime = 0;
        this._command('create', options);
    }
    /**
     * @param {?} eventName
     * @param {?} callback
     * @return {?}
     */
    RendererAnimationPlayer.prototype._listen = function (eventName, callback) {
        return this._renderer.listen(this.element, "@@" + this.id + ":" + eventName, callback);
    };
    /**
     * @param {?} command
     * @param {...?} args
     * @return {?}
     */
    RendererAnimationPlayer.prototype._command = function (command) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return issueAnimationCommand(this._renderer, this.element, this.id, command, args);
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    RendererAnimationPlayer.prototype.onDone = function (fn) { this._listen('done', fn); };
    /**
     * @param {?} fn
     * @return {?}
     */
    RendererAnimationPlayer.prototype.onStart = function (fn) { this._listen('start', fn); };
    /**
     * @param {?} fn
     * @return {?}
     */
    RendererAnimationPlayer.prototype.onDestroy = function (fn) { this._listen('destroy', fn); };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.init = function () { this._command('init'); };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.hasStarted = function () { return this._started; };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.play = function () {
        this._command('play');
        this._started = true;
    };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.pause = function () { this._command('pause'); };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.restart = function () { this._command('restart'); };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.finish = function () { this._command('finish'); };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.destroy = function () { this._command('destroy'); };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.reset = function () { this._command('reset'); };
    /**
     * @param {?} p
     * @return {?}
     */
    RendererAnimationPlayer.prototype.setPosition = function (p) { this._command('setPosition', p); };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.getPosition = function () { return 0; };
    return RendererAnimationPlayer;
}());
/**
 * @param {?} renderer
 * @param {?} element
 * @param {?} id
 * @param {?} command
 * @param {?} args
 * @return {?}
 */
function issueAnimationCommand(renderer, element, id, command, args) {
    return renderer.setProperty(element, "@@" + id + ":" + command, args);
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var ANIMATION_PREFIX = '@';
var DISABLE_ANIMATIONS_FLAG = '@.disabled';
var AnimationRendererFactory = (function () {
    /**
     * @param {?} delegate
     * @param {?} engine
     * @param {?} _zone
     */
    function AnimationRendererFactory(delegate, engine, _zone) {
        this.delegate = delegate;
        this.engine = engine;
        this._zone = _zone;
        this._currentId = 0;
        this._microtaskId = 1;
        this._animationCallbacksBuffer = [];
        this._rendererCache = new Map();
        this._cdRecurDepth = 0;
        engine.onRemovalComplete = function (element, delegate) {
            // Note: if an component element has a leave animation, and the component
            // a host leave animation, the view engine will call `removeChild` for the parent
            // component renderer as well as for the child component renderer.
            // Therefore, we need to check if we already removed the element.
            if (delegate && delegate.parentNode(element)) {
                delegate.removeChild(element.parentNode, element);
            }
        };
    }
    /**
     * @param {?} hostElement
     * @param {?} type
     * @return {?}
     */
    AnimationRendererFactory.prototype.createRenderer = function (hostElement, type) {
        var _this = this;
        var /** @type {?} */ EMPTY_NAMESPACE_ID = '';
        // cache the delegates to find out which cached delegate can
        // be used by which cached renderer
        var /** @type {?} */ delegate = this.delegate.createRenderer(hostElement, type);
        if (!hostElement || !type || !type.data || !type.data['animation']) {
            var /** @type {?} */ renderer = this._rendererCache.get(delegate);
            if (!renderer) {
                renderer = new BaseAnimationRenderer(EMPTY_NAMESPACE_ID, delegate, this.engine);
                // only cache this result when the base renderer is used
                this._rendererCache.set(delegate, renderer);
            }
            return renderer;
        }
        var /** @type {?} */ componentId = type.id;
        var /** @type {?} */ namespaceId = type.id + '-' + this._currentId;
        this._currentId++;
        this.engine.register(namespaceId, hostElement);
        var /** @type {?} */ animationTriggers = (type.data['animation']);
        animationTriggers.forEach(function (trigger) { return _this.engine.registerTrigger(componentId, namespaceId, hostElement, trigger.name, trigger); });
        return new AnimationRenderer(this, namespaceId, delegate, this.engine);
    };
    /**
     * @return {?}
     */
    AnimationRendererFactory.prototype.begin = function () {
        this._cdRecurDepth++;
        if (this.delegate.begin) {
            this.delegate.begin();
        }
    };
    /**
     * @return {?}
     */
    AnimationRendererFactory.prototype._scheduleCountTask = function () {
        var _this = this;
        Zone.current.scheduleMicroTask('incremenet the animation microtask', function () { return _this._microtaskId++; });
    };
    /**
     * @param {?} count
     * @param {?} fn
     * @param {?} data
     * @return {?}
     */
    AnimationRendererFactory.prototype.scheduleListenerCallback = function (count, fn, data) {
        var _this = this;
        if (count >= 0 && count < this._microtaskId) {
            this._zone.run(function () { return fn(data); });
            return;
        }
        if (this._animationCallbacksBuffer.length == 0) {
            Promise.resolve(null).then(function () {
                _this._zone.run(function () {
                    _this._animationCallbacksBuffer.forEach(function (tuple) {
                        var fn = tuple[0], data = tuple[1];
                        fn(data);
                    });
                    _this._animationCallbacksBuffer = [];
                });
            });
        }
        this._animationCallbacksBuffer.push([fn, data]);
    };
    /**
     * @return {?}
     */
    AnimationRendererFactory.prototype.end = function () {
        var _this = this;
        this._cdRecurDepth--;
        // this is to prevent animations from running twice when an inner
        // component does CD when a parent component insted has inserted it
        if (this._cdRecurDepth == 0) {
            this._zone.runOutsideAngular(function () {
                _this._scheduleCountTask();
                _this.engine.flush(_this._microtaskId);
            });
        }
        if (this.delegate.end) {
            this.delegate.end();
        }
    };
    /**
     * @return {?}
     */
    AnimationRendererFactory.prototype.whenRenderingDone = function () { return this.engine.whenRenderingDone(); };
    return AnimationRendererFactory;
}());
AnimationRendererFactory.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"] },
];
/**
 * @nocollapse
 */
AnimationRendererFactory.ctorParameters = function () { return [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["RendererFactory2"], },
    { type: __WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__["b" /* ɵAnimationEngine */], },
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["NgZone"], },
]; };
var BaseAnimationRenderer = (function () {
    /**
     * @param {?} namespaceId
     * @param {?} delegate
     * @param {?} engine
     */
    function BaseAnimationRenderer(namespaceId, delegate, engine) {
        this.namespaceId = namespaceId;
        this.delegate = delegate;
        this.engine = engine;
        this.destroyNode = this.delegate.destroyNode ? function (n) { return delegate.destroyNode(n); } : null;
    }
    Object.defineProperty(BaseAnimationRenderer.prototype, "data", {
        /**
         * @return {?}
         */
        get: function () { return this.delegate.data; },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    BaseAnimationRenderer.prototype.destroy = function () {
        this.engine.destroy(this.namespaceId, this.delegate);
        this.delegate.destroy();
    };
    /**
     * @param {?} name
     * @param {?=} namespace
     * @return {?}
     */
    BaseAnimationRenderer.prototype.createElement = function (name, namespace) {
        return this.delegate.createElement(name, namespace);
    };
    /**
     * @param {?} value
     * @return {?}
     */
    BaseAnimationRenderer.prototype.createComment = function (value) { return this.delegate.createComment(value); };
    /**
     * @param {?} value
     * @return {?}
     */
    BaseAnimationRenderer.prototype.createText = function (value) { return this.delegate.createText(value); };
    /**
     * @param {?} parent
     * @param {?} newChild
     * @return {?}
     */
    BaseAnimationRenderer.prototype.appendChild = function (parent, newChild) {
        this.delegate.appendChild(parent, newChild);
        this.engine.onInsert(this.namespaceId, newChild, parent, false);
    };
    /**
     * @param {?} parent
     * @param {?} newChild
     * @param {?} refChild
     * @return {?}
     */
    BaseAnimationRenderer.prototype.insertBefore = function (parent, newChild, refChild) {
        this.delegate.insertBefore(parent, newChild, refChild);
        this.engine.onInsert(this.namespaceId, newChild, parent, true);
    };
    /**
     * @param {?} parent
     * @param {?} oldChild
     * @return {?}
     */
    BaseAnimationRenderer.prototype.removeChild = function (parent, oldChild) {
        this.engine.onRemove(this.namespaceId, oldChild, this.delegate);
    };
    /**
     * @param {?} selectorOrNode
     * @return {?}
     */
    BaseAnimationRenderer.prototype.selectRootElement = function (selectorOrNode) { return this.delegate.selectRootElement(selectorOrNode); };
    /**
     * @param {?} node
     * @return {?}
     */
    BaseAnimationRenderer.prototype.parentNode = function (node) { return this.delegate.parentNode(node); };
    /**
     * @param {?} node
     * @return {?}
     */
    BaseAnimationRenderer.prototype.nextSibling = function (node) { return this.delegate.nextSibling(node); };
    /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @param {?=} namespace
     * @return {?}
     */
    BaseAnimationRenderer.prototype.setAttribute = function (el, name, value, namespace) {
        this.delegate.setAttribute(el, name, value, namespace);
    };
    /**
     * @param {?} el
     * @param {?} name
     * @param {?=} namespace
     * @return {?}
     */
    BaseAnimationRenderer.prototype.removeAttribute = function (el, name, namespace) {
        this.delegate.removeAttribute(el, name, namespace);
    };
    /**
     * @param {?} el
     * @param {?} name
     * @return {?}
     */
    BaseAnimationRenderer.prototype.addClass = function (el, name) { this.delegate.addClass(el, name); };
    /**
     * @param {?} el
     * @param {?} name
     * @return {?}
     */
    BaseAnimationRenderer.prototype.removeClass = function (el, name) { this.delegate.removeClass(el, name); };
    /**
     * @param {?} el
     * @param {?} style
     * @param {?} value
     * @param {?=} flags
     * @return {?}
     */
    BaseAnimationRenderer.prototype.setStyle = function (el, style, value, flags) {
        this.delegate.setStyle(el, style, value, flags);
    };
    /**
     * @param {?} el
     * @param {?} style
     * @param {?=} flags
     * @return {?}
     */
    BaseAnimationRenderer.prototype.removeStyle = function (el, style, flags) {
        this.delegate.removeStyle(el, style, flags);
    };
    /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    BaseAnimationRenderer.prototype.setProperty = function (el, name, value) {
        if (name.charAt(0) == ANIMATION_PREFIX && name == DISABLE_ANIMATIONS_FLAG) {
            this.disableAnimations(el, !!value);
        }
        else {
            this.delegate.setProperty(el, name, value);
        }
    };
    /**
     * @param {?} node
     * @param {?} value
     * @return {?}
     */
    BaseAnimationRenderer.prototype.setValue = function (node, value) { this.delegate.setValue(node, value); };
    /**
     * @param {?} target
     * @param {?} eventName
     * @param {?} callback
     * @return {?}
     */
    BaseAnimationRenderer.prototype.listen = function (target, eventName, callback) {
        return this.delegate.listen(target, eventName, callback);
    };
    /**
     * @param {?} element
     * @param {?} value
     * @return {?}
     */
    BaseAnimationRenderer.prototype.disableAnimations = function (element, value) {
        this.engine.disableAnimations(element, value);
    };
    return BaseAnimationRenderer;
}());
var AnimationRenderer = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](AnimationRenderer, _super);
    /**
     * @param {?} factory
     * @param {?} namespaceId
     * @param {?} delegate
     * @param {?} engine
     */
    function AnimationRenderer(factory, namespaceId, delegate, engine) {
        var _this = _super.call(this, namespaceId, delegate, engine) || this;
        _this.factory = factory;
        _this.namespaceId = namespaceId;
        return _this;
    }
    /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    AnimationRenderer.prototype.setProperty = function (el, name, value) {
        if (name.charAt(0) == ANIMATION_PREFIX) {
            if (name.charAt(1) == '.' && name == DISABLE_ANIMATIONS_FLAG) {
                this.disableAnimations(el, !!value);
            }
            else {
                this.engine.process(this.namespaceId, el, name.substr(1), value);
            }
        }
        else {
            this.delegate.setProperty(el, name, value);
        }
    };
    /**
     * @param {?} target
     * @param {?} eventName
     * @param {?} callback
     * @return {?}
     */
    AnimationRenderer.prototype.listen = function (target, eventName, callback) {
        var _this = this;
        if (eventName.charAt(0) == ANIMATION_PREFIX) {
            var /** @type {?} */ element = resolveElementFromTarget(target);
            var /** @type {?} */ name = eventName.substr(1);
            var /** @type {?} */ phase = '';
            // @listener.phase is for trigger animation callbacks
            // @@listener is for animation builder callbacks
            if (name.charAt(0) != ANIMATION_PREFIX) {
                _a = parseTriggerCallbackName(name), name = _a[0], phase = _a[1];
            }
            return this.engine.listen(this.namespaceId, element, name, phase, function (event) {
                var /** @type {?} */ countId = ((event))['_data'] || -1;
                _this.factory.scheduleListenerCallback(countId, callback, event);
            });
        }
        return this.delegate.listen(target, eventName, callback);
        var _a;
    };
    return AnimationRenderer;
}(BaseAnimationRenderer));
/**
 * @param {?} target
 * @return {?}
 */
function resolveElementFromTarget(target) {
    switch (target) {
        case 'body':
            return document.body;
        case 'document':
            return document;
        case 'window':
            return window;
        default:
            return target;
    }
}
/**
 * @param {?} triggerName
 * @return {?}
 */
function parseTriggerCallbackName(triggerName) {
    var /** @type {?} */ dotIndex = triggerName.indexOf('.');
    var /** @type {?} */ trigger = triggerName.substring(0, dotIndex);
    var /** @type {?} */ phase = triggerName.substr(dotIndex + 1);
    return [trigger, phase];
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var InjectableAnimationEngine = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](InjectableAnimationEngine, _super);
    /**
     * @param {?} driver
     * @param {?} normalizer
     */
    function InjectableAnimationEngine(driver, normalizer) {
        return _super.call(this, driver, normalizer) || this;
    }
    return InjectableAnimationEngine;
}(__WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__["b" /* ɵAnimationEngine */]));
InjectableAnimationEngine.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"] },
];
/**
 * @nocollapse
 */
InjectableAnimationEngine.ctorParameters = function () { return [
    { type: __WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__["a" /* AnimationDriver */], },
    { type: __WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__["c" /* ɵAnimationStyleNormalizer */], },
]; };
/**
 * @return {?}
 */
function instantiateSupportedAnimationDriver() {
    if (Object(__WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__["g" /* ɵsupportsWebAnimations */])()) {
        return new __WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__["e" /* ɵWebAnimationsDriver */]();
    }
    return new __WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__["d" /* ɵNoopAnimationDriver */]();
}
/**
 * @return {?}
 */
function instantiateDefaultStyleNormalizer() {
    return new __WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__["f" /* ɵWebAnimationsStyleNormalizer */]();
}
/**
 * @param {?} renderer
 * @param {?} engine
 * @param {?} zone
 * @return {?}
 */
function instantiateRendererFactory(renderer, engine, zone) {
    return new AnimationRendererFactory(renderer, engine, zone);
}
var SHARED_ANIMATION_PROVIDERS = [
    { provide: __WEBPACK_IMPORTED_MODULE_3__angular_animations__["AnimationBuilder"], useClass: BrowserAnimationBuilder },
    { provide: __WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__["c" /* ɵAnimationStyleNormalizer */], useFactory: instantiateDefaultStyleNormalizer },
    { provide: __WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__["b" /* ɵAnimationEngine */], useClass: InjectableAnimationEngine }, {
        provide: __WEBPACK_IMPORTED_MODULE_1__angular_core__["RendererFactory2"],
        useFactory: instantiateRendererFactory,
        deps: [__WEBPACK_IMPORTED_MODULE_2__angular_platform_browser__["ɵDomRendererFactory2"], __WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__["b" /* ɵAnimationEngine */], __WEBPACK_IMPORTED_MODULE_1__angular_core__["NgZone"]]
    }
];
/**
 * Separate providers from the actual module so that we can do a local modification in Google3 to
 * include them in the BrowserModule.
 */
var BROWSER_ANIMATIONS_PROVIDERS = [
    { provide: __WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__["a" /* AnimationDriver */], useFactory: instantiateSupportedAnimationDriver }
].concat(SHARED_ANIMATION_PROVIDERS);
/**
 * Separate providers from the actual module so that we can do a local modification in Google3 to
 * include them in the BrowserTestingModule.
 */
var BROWSER_NOOP_ANIMATIONS_PROVIDERS = [{ provide: __WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__["a" /* AnimationDriver */], useClass: __WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__["d" /* ɵNoopAnimationDriver */] }].concat(SHARED_ANIMATION_PROVIDERS);
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * \@experimental Animation support is experimental.
 */
var BrowserAnimationsModule = (function () {
    function BrowserAnimationsModule() {
    }
    return BrowserAnimationsModule;
}());
BrowserAnimationsModule.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["NgModule"], args: [{
                exports: [__WEBPACK_IMPORTED_MODULE_2__angular_platform_browser__["BrowserModule"]],
                providers: BROWSER_ANIMATIONS_PROVIDERS,
            },] },
];
/**
 * @nocollapse
 */
BrowserAnimationsModule.ctorParameters = function () { return []; };
/**
 * \@experimental Animation support is experimental.
 */
var NoopAnimationsModule = (function () {
    function NoopAnimationsModule() {
    }
    return NoopAnimationsModule;
}());
NoopAnimationsModule.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["NgModule"], args: [{
                exports: [__WEBPACK_IMPORTED_MODULE_2__angular_platform_browser__["BrowserModule"]],
                providers: BROWSER_NOOP_ANIMATIONS_PROVIDERS,
            },] },
];
/**
 * @nocollapse
 */
NoopAnimationsModule.ctorParameters = function () { return []; };
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @module
 * @description
 * Entry point for all animation APIs of the animation browser package.
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @module
 * @description
 * Entry point for all public APIs of the animation package.
 */
/**
 * Generated bundle index. Do not edit.
 */

//# sourceMappingURL=animations.es5.js.map


/***/ }),

/***/ "../../../router/@angular/router.es5.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RouterLink", function() { return RouterLink; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RouterLinkWithHref", function() { return RouterLinkWithHref; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RouterLinkActive", function() { return RouterLinkActive; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RouterOutlet", function() { return RouterOutlet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GuardsCheckEnd", function() { return GuardsCheckEnd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GuardsCheckStart", function() { return GuardsCheckStart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NavigationCancel", function() { return NavigationCancel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NavigationEnd", function() { return NavigationEnd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NavigationError", function() { return NavigationError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NavigationStart", function() { return NavigationStart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ResolveEnd", function() { return ResolveEnd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ResolveStart", function() { return ResolveStart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RouteConfigLoadEnd", function() { return RouteConfigLoadEnd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RouteConfigLoadStart", function() { return RouteConfigLoadStart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RoutesRecognized", function() { return RoutesRecognized; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RouteReuseStrategy", function() { return RouteReuseStrategy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Router", function() { return Router; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ROUTES", function() { return ROUTES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ROUTER_CONFIGURATION", function() { return ROUTER_CONFIGURATION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ROUTER_INITIALIZER", function() { return ROUTER_INITIALIZER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RouterModule", function() { return RouterModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "provideRoutes", function() { return provideRoutes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ChildrenOutletContexts", function() { return ChildrenOutletContexts; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OutletContext", function() { return OutletContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoPreloading", function() { return NoPreloading; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PreloadAllModules", function() { return PreloadAllModules; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PreloadingStrategy", function() { return PreloadingStrategy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RouterPreloader", function() { return RouterPreloader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ActivatedRoute", function() { return ActivatedRoute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ActivatedRouteSnapshot", function() { return ActivatedRouteSnapshot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RouterState", function() { return RouterState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RouterStateSnapshot", function() { return RouterStateSnapshot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PRIMARY_OUTLET", function() { return PRIMARY_OUTLET; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "convertToParamMap", function() { return convertToParamMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UrlHandlingStrategy", function() { return UrlHandlingStrategy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultUrlSerializer", function() { return DefaultUrlSerializer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UrlSegment", function() { return UrlSegment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UrlSegmentGroup", function() { return UrlSegmentGroup; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UrlSerializer", function() { return UrlSerializer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UrlTree", function() { return UrlTree; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return VERSION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵROUTER_PROVIDERS", function() { return ROUTER_PROVIDERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵflatten", function() { return flatten; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵa", function() { return ROUTER_FORROOT_GUARD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵg", function() { return RouterInitializer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵh", function() { return getAppInitializer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵi", function() { return getBootstrapListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵd", function() { return provideForRootGuard; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵc", function() { return provideLocationStrategy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵj", function() { return provideRouterInitializer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵf", function() { return rootRoute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵb", function() { return routerNgProbeToken; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵe", function() { return setupRouter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵk", function() { return Tree; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵl", function() { return TreeNode; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__("../../../../tslib/tslib.es6.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common__ = __webpack_require__("../../../common/@angular/common.es5.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__("../../../core/@angular/core.es5.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject__ = __webpack_require__("../../../../rxjs/BehaviorSubject.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_rxjs_Subject__ = __webpack_require__("../../../../rxjs/Subject.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_rxjs_Subject___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_rxjs_Subject__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs_observable_from__ = __webpack_require__("../../../../rxjs/observable/from.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs_observable_from___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_from__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__ = __webpack_require__("../../../../rxjs/observable/of.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_concatMap__ = __webpack_require__("../../../../rxjs/operator/concatMap.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_concatMap___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_rxjs_operator_concatMap__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_rxjs_operator_every__ = __webpack_require__("../../../../rxjs/operator/every.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_rxjs_operator_every___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_rxjs_operator_every__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_rxjs_operator_first__ = __webpack_require__("../../../../rxjs/operator/first.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_rxjs_operator_first___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_rxjs_operator_first__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_rxjs_operator_last__ = __webpack_require__("../../../../rxjs/operator/last.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_rxjs_operator_last___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10_rxjs_operator_last__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__ = __webpack_require__("../../../../rxjs/operator/map.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_rxjs_operator_mergeMap__ = __webpack_require__("../../../../rxjs/operator/mergeMap.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_rxjs_operator_mergeMap___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_12_rxjs_operator_mergeMap__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_rxjs_operator_reduce__ = __webpack_require__("../../../../rxjs/operator/reduce.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_rxjs_operator_reduce___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_13_rxjs_operator_reduce__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_rxjs_Observable__ = __webpack_require__("../../../../rxjs/Observable.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_14_rxjs_Observable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_rxjs_operator_catch__ = __webpack_require__("../../../../rxjs/operator/catch.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_rxjs_operator_catch___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_15_rxjs_operator_catch__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_rxjs_operator_concatAll__ = __webpack_require__("../../../../rxjs/operator/concatAll.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_rxjs_operator_concatAll___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_16_rxjs_operator_concatAll__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_rxjs_util_EmptyError__ = __webpack_require__("../../../../rxjs/util/EmptyError.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_rxjs_util_EmptyError___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_17_rxjs_util_EmptyError__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18_rxjs_observable_fromPromise__ = __webpack_require__("../../../../rxjs/observable/fromPromise.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18_rxjs_observable_fromPromise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_18_rxjs_observable_fromPromise__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19_rxjs_operator_mergeAll__ = __webpack_require__("../../../../rxjs/operator/mergeAll.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19_rxjs_operator_mergeAll___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_19_rxjs_operator_mergeAll__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__angular_platform_browser__ = __webpack_require__("../../../platform-browser/@angular/platform-browser.es5.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21_rxjs_operator_filter__ = __webpack_require__("../../../../rxjs/operator/filter.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21_rxjs_operator_filter___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_21_rxjs_operator_filter__);

/**
 * @license Angular v4.3.5
 * (c) 2010-2017 Google, Inc. https://angular.io/
 * License: MIT
 */





















/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * \@whatItDoes Represents an event triggered when a navigation starts.
 *
 * \@stable
 */
var NavigationStart = (function () {
    /**
     * @param {?} id
     * @param {?} url
     */
    function NavigationStart(id, url) {
        this.id = id;
        this.url = url;
    }
    /**
     * \@docsNotRequired
     * @return {?}
     */
    NavigationStart.prototype.toString = function () { return "NavigationStart(id: " + this.id + ", url: '" + this.url + "')"; };
    return NavigationStart;
}());
/**
 * \@whatItDoes Represents an event triggered when a navigation ends successfully.
 *
 * \@stable
 */
var NavigationEnd = (function () {
    /**
     * @param {?} id
     * @param {?} url
     * @param {?} urlAfterRedirects
     */
    function NavigationEnd(id, url, urlAfterRedirects) {
        this.id = id;
        this.url = url;
        this.urlAfterRedirects = urlAfterRedirects;
    }
    /**
     * \@docsNotRequired
     * @return {?}
     */
    NavigationEnd.prototype.toString = function () {
        return "NavigationEnd(id: " + this.id + ", url: '" + this.url + "', urlAfterRedirects: '" + this.urlAfterRedirects + "')";
    };
    return NavigationEnd;
}());
/**
 * \@whatItDoes Represents an event triggered when a navigation is canceled.
 *
 * \@stable
 */
var NavigationCancel = (function () {
    /**
     * @param {?} id
     * @param {?} url
     * @param {?} reason
     */
    function NavigationCancel(id, url, reason) {
        this.id = id;
        this.url = url;
        this.reason = reason;
    }
    /**
     * \@docsNotRequired
     * @return {?}
     */
    NavigationCancel.prototype.toString = function () { return "NavigationCancel(id: " + this.id + ", url: '" + this.url + "')"; };
    return NavigationCancel;
}());
/**
 * \@whatItDoes Represents an event triggered when a navigation fails due to an unexpected error.
 *
 * \@stable
 */
var NavigationError = (function () {
    /**
     * @param {?} id
     * @param {?} url
     * @param {?} error
     */
    function NavigationError(id, url, error) {
        this.id = id;
        this.url = url;
        this.error = error;
    }
    /**
     * \@docsNotRequired
     * @return {?}
     */
    NavigationError.prototype.toString = function () {
        return "NavigationError(id: " + this.id + ", url: '" + this.url + "', error: " + this.error + ")";
    };
    return NavigationError;
}());
/**
 * \@whatItDoes Represents an event triggered when routes are recognized.
 *
 * \@stable
 */
var RoutesRecognized = (function () {
    /**
     * @param {?} id
     * @param {?} url
     * @param {?} urlAfterRedirects
     * @param {?} state
     */
    function RoutesRecognized(id, url, urlAfterRedirects, state) {
        this.id = id;
        this.url = url;
        this.urlAfterRedirects = urlAfterRedirects;
        this.state = state;
    }
    /**
     * \@docsNotRequired
     * @return {?}
     */
    RoutesRecognized.prototype.toString = function () {
        return "RoutesRecognized(id: " + this.id + ", url: '" + this.url + "', urlAfterRedirects: '" + this.urlAfterRedirects + "', state: " + this.state + ")";
    };
    return RoutesRecognized;
}());
/**
 * \@whatItDoes Represents an event triggered before lazy loading a route config.
 *
 * \@experimental
 */
var RouteConfigLoadStart = (function () {
    /**
     * @param {?} route
     */
    function RouteConfigLoadStart(route) {
        this.route = route;
    }
    /**
     * @return {?}
     */
    RouteConfigLoadStart.prototype.toString = function () { return "RouteConfigLoadStart(path: " + this.route.path + ")"; };
    return RouteConfigLoadStart;
}());
/**
 * \@whatItDoes Represents an event triggered when a route has been lazy loaded.
 *
 * \@experimental
 */
var RouteConfigLoadEnd = (function () {
    /**
     * @param {?} route
     */
    function RouteConfigLoadEnd(route) {
        this.route = route;
    }
    /**
     * @return {?}
     */
    RouteConfigLoadEnd.prototype.toString = function () { return "RouteConfigLoadEnd(path: " + this.route.path + ")"; };
    return RouteConfigLoadEnd;
}());
/**
 * \@whatItDoes Represents the start of the Guard phase of routing.
 *
 * \@experimental
 */
var GuardsCheckStart = (function () {
    /**
     * @param {?} id
     * @param {?} url
     * @param {?} urlAfterRedirects
     * @param {?} state
     */
    function GuardsCheckStart(id, url, urlAfterRedirects, state) {
        this.id = id;
        this.url = url;
        this.urlAfterRedirects = urlAfterRedirects;
        this.state = state;
    }
    /**
     * @return {?}
     */
    GuardsCheckStart.prototype.toString = function () {
        return "GuardsCheckStart(id: " + this.id + ", url: '" + this.url + "', urlAfterRedirects: '" + this.urlAfterRedirects + "', state: " + this.state + ")";
    };
    return GuardsCheckStart;
}());
/**
 * \@whatItDoes Represents the end of the Guard phase of routing.
 *
 * \@experimental
 */
var GuardsCheckEnd = (function () {
    /**
     * @param {?} id
     * @param {?} url
     * @param {?} urlAfterRedirects
     * @param {?} state
     * @param {?} shouldActivate
     */
    function GuardsCheckEnd(id, url, urlAfterRedirects, state, shouldActivate) {
        this.id = id;
        this.url = url;
        this.urlAfterRedirects = urlAfterRedirects;
        this.state = state;
        this.shouldActivate = shouldActivate;
    }
    /**
     * @return {?}
     */
    GuardsCheckEnd.prototype.toString = function () {
        return "GuardsCheckEnd(id: " + this.id + ", url: '" + this.url + "', urlAfterRedirects: '" + this.urlAfterRedirects + "', state: " + this.state + ", shouldActivate: " + this.shouldActivate + ")";
    };
    return GuardsCheckEnd;
}());
/**
 * \@whatItDoes Represents the start of the Resolve phase of routing. The timing of this
 * event may change, thus it's experimental. In the current iteration it will run
 * in the "resolve" phase whether there's things to resolve or not. In the future this
 * behavior may change to only run when there are things to be resolved.
 *
 * \@experimental
 */
var ResolveStart = (function () {
    /**
     * @param {?} id
     * @param {?} url
     * @param {?} urlAfterRedirects
     * @param {?} state
     */
    function ResolveStart(id, url, urlAfterRedirects, state) {
        this.id = id;
        this.url = url;
        this.urlAfterRedirects = urlAfterRedirects;
        this.state = state;
    }
    /**
     * @return {?}
     */
    ResolveStart.prototype.toString = function () {
        return "ResolveStart(id: " + this.id + ", url: '" + this.url + "', urlAfterRedirects: '" + this.urlAfterRedirects + "', state: " + this.state + ")";
    };
    return ResolveStart;
}());
/**
 * \@whatItDoes Represents the end of the Resolve phase of routing. See note on
 * {\@link ResolveStart} for use of this experimental API.
 *
 * \@experimental
 */
var ResolveEnd = (function () {
    /**
     * @param {?} id
     * @param {?} url
     * @param {?} urlAfterRedirects
     * @param {?} state
     */
    function ResolveEnd(id, url, urlAfterRedirects, state) {
        this.id = id;
        this.url = url;
        this.urlAfterRedirects = urlAfterRedirects;
        this.state = state;
    }
    /**
     * @return {?}
     */
    ResolveEnd.prototype.toString = function () {
        return "ResolveEnd(id: " + this.id + ", url: '" + this.url + "', urlAfterRedirects: '" + this.urlAfterRedirects + "', state: " + this.state + ")";
    };
    return ResolveEnd;
}());
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * \@whatItDoes Name of the primary outlet.
 *
 * \@stable
 */
var PRIMARY_OUTLET = 'primary';
var ParamsAsMap = (function () {
    /**
     * @param {?} params
     */
    function ParamsAsMap(params) {
        this.params = params || {};
    }
    /**
     * @param {?} name
     * @return {?}
     */
    ParamsAsMap.prototype.has = function (name) { return this.params.hasOwnProperty(name); };
    /**
     * @param {?} name
     * @return {?}
     */
    ParamsAsMap.prototype.get = function (name) {
        if (this.has(name)) {
            var /** @type {?} */ v = this.params[name];
            return Array.isArray(v) ? v[0] : v;
        }
        return null;
    };
    /**
     * @param {?} name
     * @return {?}
     */
    ParamsAsMap.prototype.getAll = function (name) {
        if (this.has(name)) {
            var /** @type {?} */ v = this.params[name];
            return Array.isArray(v) ? v : [v];
        }
        return [];
    };
    Object.defineProperty(ParamsAsMap.prototype, "keys", {
        /**
         * @return {?}
         */
        get: function () { return Object.keys(this.params); },
        enumerable: true,
        configurable: true
    });
    return ParamsAsMap;
}());
/**
 * Convert a {\@link Params} instance to a {\@link ParamMap}.
 *
 * \@stable
 * @param {?} params
 * @return {?}
 */
function convertToParamMap(params) {
    return new ParamsAsMap(params);
}
var NAVIGATION_CANCELING_ERROR = 'ngNavigationCancelingError';
/**
 * @param {?} message
 * @return {?}
 */
function navigationCancelingError(message) {
    var /** @type {?} */ error = Error('NavigationCancelingError: ' + message);
    ((error))[NAVIGATION_CANCELING_ERROR] = true;
    return error;
}
/**
 * @param {?} error
 * @return {?}
 */
function isNavigationCancelingError(error) {
    return ((error))[NAVIGATION_CANCELING_ERROR];
}
/**
 * @param {?} segments
 * @param {?} segmentGroup
 * @param {?} route
 * @return {?}
 */
function defaultUrlMatcher(segments, segmentGroup, route) {
    var /** @type {?} */ parts = ((route.path)).split('/');
    if (parts.length > segments.length) {
        // The actual URL is shorter than the config, no match
        return null;
    }
    if (route.pathMatch === 'full' &&
        (segmentGroup.hasChildren() || parts.length < segments.length)) {
        // The config is longer than the actual URL but we are looking for a full match, return null
        return null;
    }
    var /** @type {?} */ posParams = {};
    // Check each config part against the actual URL
    for (var /** @type {?} */ index = 0; index < parts.length; index++) {
        var /** @type {?} */ part = parts[index];
        var /** @type {?} */ segment = segments[index];
        var /** @type {?} */ isParameter = part.startsWith(':');
        if (isParameter) {
            posParams[part.substring(1)] = segment;
        }
        else if (part !== segment.path) {
            // The actual URL part does not match the config, no match
            return null;
        }
    }
    return { consumed: segments.slice(0, parts.length), posParams: posParams };
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var LoadedRouterConfig = (function () {
    /**
     * @param {?} routes
     * @param {?} module
     */
    function LoadedRouterConfig(routes, module) {
        this.routes = routes;
        this.module = module;
    }
    return LoadedRouterConfig;
}());
/**
 * @param {?} config
 * @param {?=} parentPath
 * @return {?}
 */
function validateConfig(config, parentPath) {
    if (parentPath === void 0) { parentPath = ''; }
    // forEach doesn't iterate undefined values
    for (var /** @type {?} */ i = 0; i < config.length; i++) {
        var /** @type {?} */ route = config[i];
        var /** @type {?} */ fullPath = getFullPath(parentPath, route);
        validateNode(route, fullPath);
    }
}
/**
 * @param {?} route
 * @param {?} fullPath
 * @return {?}
 */
function validateNode(route, fullPath) {
    if (!route) {
        throw new Error("\n      Invalid configuration of route '" + fullPath + "': Encountered undefined route.\n      The reason might be an extra comma.\n\n      Example:\n      const routes: Routes = [\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\n        { path: 'detail/:id', component: HeroDetailComponent }\n      ];\n    ");
    }
    if (Array.isArray(route)) {
        throw new Error("Invalid configuration of route '" + fullPath + "': Array cannot be specified");
    }
    if (!route.component && (route.outlet && route.outlet !== PRIMARY_OUTLET)) {
        throw new Error("Invalid configuration of route '" + fullPath + "': a componentless route cannot have a named outlet set");
    }
    if (route.redirectTo && route.children) {
        throw new Error("Invalid configuration of route '" + fullPath + "': redirectTo and children cannot be used together");
    }
    if (route.redirectTo && route.loadChildren) {
        throw new Error("Invalid configuration of route '" + fullPath + "': redirectTo and loadChildren cannot be used together");
    }
    if (route.children && route.loadChildren) {
        throw new Error("Invalid configuration of route '" + fullPath + "': children and loadChildren cannot be used together");
    }
    if (route.redirectTo && route.component) {
        throw new Error("Invalid configuration of route '" + fullPath + "': redirectTo and component cannot be used together");
    }
    if (route.path && route.matcher) {
        throw new Error("Invalid configuration of route '" + fullPath + "': path and matcher cannot be used together");
    }
    if (route.redirectTo === void 0 && !route.component && !route.children && !route.loadChildren) {
        throw new Error("Invalid configuration of route '" + fullPath + "'. One of the following must be provided: component, redirectTo, children or loadChildren");
    }
    if (route.path === void 0 && route.matcher === void 0) {
        throw new Error("Invalid configuration of route '" + fullPath + "': routes must have either a path or a matcher specified");
    }
    if (typeof route.path === 'string' && route.path.charAt(0) === '/') {
        throw new Error("Invalid configuration of route '" + fullPath + "': path cannot start with a slash");
    }
    if (route.path === '' && route.redirectTo !== void 0 && route.pathMatch === void 0) {
        var /** @type {?} */ exp = "The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.";
        throw new Error("Invalid configuration of route '{path: \"" + fullPath + "\", redirectTo: \"" + route.redirectTo + "\"}': please provide 'pathMatch'. " + exp);
    }
    if (route.pathMatch !== void 0 && route.pathMatch !== 'full' && route.pathMatch !== 'prefix') {
        throw new Error("Invalid configuration of route '" + fullPath + "': pathMatch can only be set to 'prefix' or 'full'");
    }
    if (route.children) {
        validateConfig(route.children, fullPath);
    }
}
/**
 * @param {?} parentPath
 * @param {?} currentRoute
 * @return {?}
 */
function getFullPath(parentPath, currentRoute) {
    if (!currentRoute) {
        return parentPath;
    }
    if (!parentPath && !currentRoute.path) {
        return '';
    }
    else if (parentPath && !currentRoute.path) {
        return parentPath + "/";
    }
    else if (!parentPath && currentRoute.path) {
        return currentRoute.path;
    }
    else {
        return parentPath + "/" + currentRoute.path;
    }
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @param {?} a
 * @param {?} b
 * @return {?}
 */
function shallowEqualArrays(a, b) {
    if (a.length !== b.length)
        return false;
    for (var /** @type {?} */ i = 0; i < a.length; ++i) {
        if (!shallowEqual(a[i], b[i]))
            return false;
    }
    return true;
}
/**
 * @param {?} a
 * @param {?} b
 * @return {?}
 */
function shallowEqual(a, b) {
    var /** @type {?} */ k1 = Object.keys(a);
    var /** @type {?} */ k2 = Object.keys(b);
    if (k1.length != k2.length) {
        return false;
    }
    var /** @type {?} */ key;
    for (var /** @type {?} */ i = 0; i < k1.length; i++) {
        key = k1[i];
        if (a[key] !== b[key]) {
            return false;
        }
    }
    return true;
}
/**
 * @template T
 * @param {?} arr
 * @return {?}
 */
function flatten(arr) {
    return Array.prototype.concat.apply([], arr);
}
/**
 * @template T
 * @param {?} a
 * @return {?}
 */
function last$1(a) {
    return a.length > 0 ? a[a.length - 1] : null;
}
/**
 * @param {?} bools
 * @return {?}
 */
/**
 * @template K, V
 * @param {?} map
 * @param {?} callback
 * @return {?}
 */
function forEach(map$$1, callback) {
    for (var /** @type {?} */ prop in map$$1) {
        if (map$$1.hasOwnProperty(prop)) {
            callback(map$$1[prop], prop);
        }
    }
}
/**
 * @template A, B
 * @param {?} obj
 * @param {?} fn
 * @return {?}
 */
function waitForMap(obj, fn) {
    if (Object.keys(obj).length === 0) {
        return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])({});
    }
    var /** @type {?} */ waitHead = [];
    var /** @type {?} */ waitTail = [];
    var /** @type {?} */ res = {};
    forEach(obj, function (a, k) {
        var /** @type {?} */ mapped = __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(fn(k, a), function (r) { return res[k] = r; });
        if (k === PRIMARY_OUTLET) {
            waitHead.push(mapped);
        }
        else {
            waitTail.push(mapped);
        }
    });
    var /** @type {?} */ concat$ = __WEBPACK_IMPORTED_MODULE_16_rxjs_operator_concatAll__["concatAll"].call(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"].apply(void 0, waitHead.concat(waitTail)));
    var /** @type {?} */ last$ = __WEBPACK_IMPORTED_MODULE_10_rxjs_operator_last__["last"].call(concat$);
    return __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(last$, function () { return res; });
}
/**
 * @param {?} observables
 * @return {?}
 */
function andObservables(observables) {
    var /** @type {?} */ merged$ = __WEBPACK_IMPORTED_MODULE_19_rxjs_operator_mergeAll__["mergeAll"].call(observables);
    return __WEBPACK_IMPORTED_MODULE_8_rxjs_operator_every__["every"].call(merged$, function (result) { return result === true; });
}
/**
 * @template T
 * @param {?} value
 * @return {?}
 */
function wrapIntoObservable(value) {
    if (Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["ɵisObservable"])(value)) {
        return value;
    }
    if (Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["ɵisPromise"])(value)) {
        // Use `Promise.resolve()` to wrap promise-like instances.
        // Required ie when a Resolver returns a AngularJS `$q` promise to correctly trigger the
        // change detection.
        return Object(__WEBPACK_IMPORTED_MODULE_18_rxjs_observable_fromPromise__["fromPromise"])(Promise.resolve(value));
    }
    return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(/** @type {?} */ (value));
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @return {?}
 */
function createEmptyUrlTree() {
    return new UrlTree(new UrlSegmentGroup([], {}), {}, null);
}
/**
 * @param {?} container
 * @param {?} containee
 * @param {?} exact
 * @return {?}
 */
function containsTree(container, containee, exact) {
    if (exact) {
        return equalQueryParams(container.queryParams, containee.queryParams) &&
            equalSegmentGroups(container.root, containee.root);
    }
    return containsQueryParams(container.queryParams, containee.queryParams) &&
        containsSegmentGroup(container.root, containee.root);
}
/**
 * @param {?} container
 * @param {?} containee
 * @return {?}
 */
function equalQueryParams(container, containee) {
    return shallowEqual(container, containee);
}
/**
 * @param {?} container
 * @param {?} containee
 * @return {?}
 */
function equalSegmentGroups(container, containee) {
    if (!equalPath(container.segments, containee.segments))
        return false;
    if (container.numberOfChildren !== containee.numberOfChildren)
        return false;
    for (var /** @type {?} */ c in containee.children) {
        if (!container.children[c])
            return false;
        if (!equalSegmentGroups(container.children[c], containee.children[c]))
            return false;
    }
    return true;
}
/**
 * @param {?} container
 * @param {?} containee
 * @return {?}
 */
function containsQueryParams(container, containee) {
    return Object.keys(containee).length <= Object.keys(container).length &&
        Object.keys(containee).every(function (key) { return containee[key] === container[key]; });
}
/**
 * @param {?} container
 * @param {?} containee
 * @return {?}
 */
function containsSegmentGroup(container, containee) {
    return containsSegmentGroupHelper(container, containee, containee.segments);
}
/**
 * @param {?} container
 * @param {?} containee
 * @param {?} containeePaths
 * @return {?}
 */
function containsSegmentGroupHelper(container, containee, containeePaths) {
    if (container.segments.length > containeePaths.length) {
        var /** @type {?} */ current = container.segments.slice(0, containeePaths.length);
        if (!equalPath(current, containeePaths))
            return false;
        if (containee.hasChildren())
            return false;
        return true;
    }
    else if (container.segments.length === containeePaths.length) {
        if (!equalPath(container.segments, containeePaths))
            return false;
        for (var /** @type {?} */ c in containee.children) {
            if (!container.children[c])
                return false;
            if (!containsSegmentGroup(container.children[c], containee.children[c]))
                return false;
        }
        return true;
    }
    else {
        var /** @type {?} */ current = containeePaths.slice(0, container.segments.length);
        var /** @type {?} */ next = containeePaths.slice(container.segments.length);
        if (!equalPath(container.segments, current))
            return false;
        if (!container.children[PRIMARY_OUTLET])
            return false;
        return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next);
    }
}
/**
 * \@whatItDoes Represents the parsed URL.
 *
 * \@howToUse
 *
 * ```
 * \@Component({templateUrl:'template.html'})
 * class MyComponent {
 *   constructor(router: Router) {
 *     const tree: UrlTree =
 *       router.parseUrl('/team/33/(user/victor//support:help)?debug=true#fragment');
 *     const f = tree.fragment; // return 'fragment'
 *     const q = tree.queryParams; // returns {debug: 'true'}
 *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];
 *     const s: UrlSegment[] = g.segments; // returns 2 segments 'team' and '33'
 *     g.children[PRIMARY_OUTLET].segments; // returns 2 segments 'user' and 'victor'
 *     g.children['support'].segments; // return 1 segment 'help'
 *   }
 * }
 * ```
 *
 * \@description
 *
 * Since a router state is a tree, and the URL is nothing but a serialized state, the URL is a
 * serialized tree.
 * UrlTree is a data structure that provides a lot of affordances in dealing with URLs
 *
 * \@stable
 */
var UrlTree = (function () {
    /**
     * \@internal
     * @param {?} root
     * @param {?} queryParams
     * @param {?} fragment
     */
    function UrlTree(root, queryParams, fragment) {
        this.root = root;
        this.queryParams = queryParams;
        this.fragment = fragment;
    }
    Object.defineProperty(UrlTree.prototype, "queryParamMap", {
        /**
         * @return {?}
         */
        get: function () {
            if (!this._queryParamMap) {
                this._queryParamMap = convertToParamMap(this.queryParams);
            }
            return this._queryParamMap;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * \@docsNotRequired
     * @return {?}
     */
    UrlTree.prototype.toString = function () { return DEFAULT_SERIALIZER.serialize(this); };
    return UrlTree;
}());
/**
 * \@whatItDoes Represents the parsed URL segment group.
 *
 * See {\@link UrlTree} for more information.
 *
 * \@stable
 */
var UrlSegmentGroup = (function () {
    /**
     * @param {?} segments
     * @param {?} children
     */
    function UrlSegmentGroup(segments, children) {
        var _this = this;
        this.segments = segments;
        this.children = children;
        /**
         * The parent node in the url tree
         */
        this.parent = null;
        forEach(children, function (v, k) { return v.parent = _this; });
    }
    /**
     * Whether the segment has child segments
     * @return {?}
     */
    UrlSegmentGroup.prototype.hasChildren = function () { return this.numberOfChildren > 0; };
    Object.defineProperty(UrlSegmentGroup.prototype, "numberOfChildren", {
        /**
         * Number of child segments
         * @return {?}
         */
        get: function () { return Object.keys(this.children).length; },
        enumerable: true,
        configurable: true
    });
    /**
     * \@docsNotRequired
     * @return {?}
     */
    UrlSegmentGroup.prototype.toString = function () { return serializePaths(this); };
    return UrlSegmentGroup;
}());
/**
 * \@whatItDoes Represents a single URL segment.
 *
 * \@howToUse
 *
 * ```
 * \@Component({templateUrl:'template.html'})
 * class MyComponent {
 *   constructor(router: Router) {
 *     const tree: UrlTree = router.parseUrl('/team;id=33');
 *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];
 *     const s: UrlSegment[] = g.segments;
 *     s[0].path; // returns 'team'
 *     s[0].parameters; // returns {id: 33}
 *   }
 * }
 * ```
 *
 * \@description
 *
 * A UrlSegment is a part of a URL between the two slashes. It contains a path and the matrix
 * parameters associated with the segment.
 *
 * \@stable
 */
var UrlSegment = (function () {
    /**
     * @param {?} path
     * @param {?} parameters
     */
    function UrlSegment(path, parameters) {
        this.path = path;
        this.parameters = parameters;
    }
    Object.defineProperty(UrlSegment.prototype, "parameterMap", {
        /**
         * @return {?}
         */
        get: function () {
            if (!this._parameterMap) {
                this._parameterMap = convertToParamMap(this.parameters);
            }
            return this._parameterMap;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * \@docsNotRequired
     * @return {?}
     */
    UrlSegment.prototype.toString = function () { return serializePath(this); };
    return UrlSegment;
}());
/**
 * @param {?} as
 * @param {?} bs
 * @return {?}
 */
function equalSegments(as, bs) {
    return equalPath(as, bs) && as.every(function (a, i) { return shallowEqual(a.parameters, bs[i].parameters); });
}
/**
 * @param {?} as
 * @param {?} bs
 * @return {?}
 */
function equalPath(as, bs) {
    if (as.length !== bs.length)
        return false;
    return as.every(function (a, i) { return a.path === bs[i].path; });
}
/**
 * @template T
 * @param {?} segment
 * @param {?} fn
 * @return {?}
 */
function mapChildrenIntoArray(segment, fn) {
    var /** @type {?} */ res = [];
    forEach(segment.children, function (child, childOutlet) {
        if (childOutlet === PRIMARY_OUTLET) {
            res = res.concat(fn(child, childOutlet));
        }
    });
    forEach(segment.children, function (child, childOutlet) {
        if (childOutlet !== PRIMARY_OUTLET) {
            res = res.concat(fn(child, childOutlet));
        }
    });
    return res;
}
/**
 * \@whatItDoes Serializes and deserializes a URL string into a URL tree.
 *
 * \@description The url serialization strategy is customizable. You can
 * make all URLs case insensitive by providing a custom UrlSerializer.
 *
 * See {\@link DefaultUrlSerializer} for an example of a URL serializer.
 *
 * \@stable
 * @abstract
 */
var UrlSerializer = (function () {
    function UrlSerializer() {
    }
    /**
     * Parse a url into a {\@link UrlTree}
     * @abstract
     * @param {?} url
     * @return {?}
     */
    UrlSerializer.prototype.parse = function (url) { };
    /**
     * Converts a {\@link UrlTree} into a url
     * @abstract
     * @param {?} tree
     * @return {?}
     */
    UrlSerializer.prototype.serialize = function (tree) { };
    return UrlSerializer;
}());
/**
 * \@whatItDoes A default implementation of the {\@link UrlSerializer}.
 *
 * \@description
 *
 * Example URLs:
 *
 * ```
 * /inbox/33(popup:compose)
 * /inbox/33;open=true/messages/44
 * ```
 *
 * DefaultUrlSerializer uses parentheses to serialize secondary segments (e.g., popup:compose), the
 * colon syntax to specify the outlet, and the ';parameter=value' syntax (e.g., open=true) to
 * specify route specific parameters.
 *
 * \@stable
 */
var DefaultUrlSerializer = (function () {
    function DefaultUrlSerializer() {
    }
    /**
     * Parses a url into a {\@link UrlTree}
     * @param {?} url
     * @return {?}
     */
    DefaultUrlSerializer.prototype.parse = function (url) {
        var /** @type {?} */ p = new UrlParser(url);
        return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());
    };
    /**
     * Converts a {\@link UrlTree} into a url
     * @param {?} tree
     * @return {?}
     */
    DefaultUrlSerializer.prototype.serialize = function (tree) {
        var /** @type {?} */ segment = "/" + serializeSegment(tree.root, true);
        var /** @type {?} */ query = serializeQueryParams(tree.queryParams);
        var /** @type {?} */ fragment = typeof tree.fragment === "string" ? "#" + encodeURI(/** @type {?} */ ((tree.fragment))) : '';
        return "" + segment + query + fragment;
    };
    return DefaultUrlSerializer;
}());
var DEFAULT_SERIALIZER = new DefaultUrlSerializer();
/**
 * @param {?} segment
 * @return {?}
 */
function serializePaths(segment) {
    return segment.segments.map(function (p) { return serializePath(p); }).join('/');
}
/**
 * @param {?} segment
 * @param {?} root
 * @return {?}
 */
function serializeSegment(segment, root) {
    if (!segment.hasChildren()) {
        return serializePaths(segment);
    }
    if (root) {
        var /** @type {?} */ primary = segment.children[PRIMARY_OUTLET] ?
            serializeSegment(segment.children[PRIMARY_OUTLET], false) :
            '';
        var /** @type {?} */ children_1 = [];
        forEach(segment.children, function (v, k) {
            if (k !== PRIMARY_OUTLET) {
                children_1.push(k + ":" + serializeSegment(v, false));
            }
        });
        return children_1.length > 0 ? primary + "(" + children_1.join('//') + ")" : primary;
    }
    else {
        var /** @type {?} */ children = mapChildrenIntoArray(segment, function (v, k) {
            if (k === PRIMARY_OUTLET) {
                return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];
            }
            return [k + ":" + serializeSegment(v, false)];
        });
        return serializePaths(segment) + "/(" + children.join('//') + ")";
    }
}
/**
 * This method is intended for encoding *key* or *value* parts of query component. We need a custom
 * method because encodeURIComponent is too aggressive and encodes stuff that doesn't have to be
 * encoded per http://tools.ietf.org/html/rfc3986:
 *    query         = *( pchar / "/" / "?" )
 *    pchar         = unreserved / pct-encoded / sub-delims / ":" / "\@"
 *    unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
 *    pct-encoded   = "%" HEXDIG HEXDIG
 *    sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
 *                     / "*" / "+" / "," / ";" / "="
 * @param {?} s
 * @return {?}
 */
function encode(s) {
    return encodeURIComponent(s)
        .replace(/%40/g, '@')
        .replace(/%3A/gi, ':')
        .replace(/%24/g, '$')
        .replace(/%2C/gi, ',')
        .replace(/%3B/gi, ';');
}
/**
 * @param {?} s
 * @return {?}
 */
function decode(s) {
    return decodeURIComponent(s);
}
/**
 * @param {?} path
 * @return {?}
 */
function serializePath(path) {
    return "" + encode(path.path) + serializeParams(path.parameters);
}
/**
 * @param {?} params
 * @return {?}
 */
function serializeParams(params) {
    return Object.keys(params).map(function (key) { return ";" + encode(key) + "=" + encode(params[key]); }).join('');
}
/**
 * @param {?} params
 * @return {?}
 */
function serializeQueryParams(params) {
    var /** @type {?} */ strParams = Object.keys(params).map(function (name) {
        var /** @type {?} */ value = params[name];
        return Array.isArray(value) ? value.map(function (v) { return encode(name) + "=" + encode(v); }).join('&') :
            encode(name) + "=" + encode(value);
    });
    return strParams.length ? "?" + strParams.join("&") : '';
}
var SEGMENT_RE = /^[^\/()?;=&#]+/;
/**
 * @param {?} str
 * @return {?}
 */
function matchSegments(str) {
    var /** @type {?} */ match = str.match(SEGMENT_RE);
    return match ? match[0] : '';
}
var QUERY_PARAM_RE = /^[^=?&#]+/;
/**
 * @param {?} str
 * @return {?}
 */
function matchQueryParams(str) {
    var /** @type {?} */ match = str.match(QUERY_PARAM_RE);
    return match ? match[0] : '';
}
var QUERY_PARAM_VALUE_RE = /^[^?&#]+/;
/**
 * @param {?} str
 * @return {?}
 */
function matchUrlQueryParamValue(str) {
    var /** @type {?} */ match = str.match(QUERY_PARAM_VALUE_RE);
    return match ? match[0] : '';
}
var UrlParser = (function () {
    /**
     * @param {?} url
     */
    function UrlParser(url) {
        this.url = url;
        this.remaining = url;
    }
    /**
     * @return {?}
     */
    UrlParser.prototype.parseRootSegment = function () {
        this.consumeOptional('/');
        if (this.remaining === '' || this.peekStartsWith('?') || this.peekStartsWith('#')) {
            return new UrlSegmentGroup([], {});
        }
        // The root segment group never has segments
        return new UrlSegmentGroup([], this.parseChildren());
    };
    /**
     * @return {?}
     */
    UrlParser.prototype.parseQueryParams = function () {
        var /** @type {?} */ params = {};
        if (this.consumeOptional('?')) {
            do {
                this.parseQueryParam(params);
            } while (this.consumeOptional('&'));
        }
        return params;
    };
    /**
     * @return {?}
     */
    UrlParser.prototype.parseFragment = function () {
        return this.consumeOptional('#') ? decodeURI(this.remaining) : null;
    };
    /**
     * @return {?}
     */
    UrlParser.prototype.parseChildren = function () {
        if (this.remaining === '') {
            return {};
        }
        this.consumeOptional('/');
        var /** @type {?} */ segments = [];
        if (!this.peekStartsWith('(')) {
            segments.push(this.parseSegment());
        }
        while (this.peekStartsWith('/') && !this.peekStartsWith('//') && !this.peekStartsWith('/(')) {
            this.capture('/');
            segments.push(this.parseSegment());
        }
        var /** @type {?} */ children = {};
        if (this.peekStartsWith('/(')) {
            this.capture('/');
            children = this.parseParens(true);
        }
        var /** @type {?} */ res = {};
        if (this.peekStartsWith('(')) {
            res = this.parseParens(false);
        }
        if (segments.length > 0 || Object.keys(children).length > 0) {
            res[PRIMARY_OUTLET] = new UrlSegmentGroup(segments, children);
        }
        return res;
    };
    /**
     * @return {?}
     */
    UrlParser.prototype.parseSegment = function () {
        var /** @type {?} */ path = matchSegments(this.remaining);
        if (path === '' && this.peekStartsWith(';')) {
            throw new Error("Empty path url segment cannot have parameters: '" + this.remaining + "'.");
        }
        this.capture(path);
        return new UrlSegment(decode(path), this.parseMatrixParams());
    };
    /**
     * @return {?}
     */
    UrlParser.prototype.parseMatrixParams = function () {
        var /** @type {?} */ params = {};
        while (this.consumeOptional(';')) {
            this.parseParam(params);
        }
        return params;
    };
    /**
     * @param {?} params
     * @return {?}
     */
    UrlParser.prototype.parseParam = function (params) {
        var /** @type {?} */ key = matchSegments(this.remaining);
        if (!key) {
            return;
        }
        this.capture(key);
        var /** @type {?} */ value = '';
        if (this.consumeOptional('=')) {
            var /** @type {?} */ valueMatch = matchSegments(this.remaining);
            if (valueMatch) {
                value = valueMatch;
                this.capture(value);
            }
        }
        params[decode(key)] = decode(value);
    };
    /**
     * @param {?} params
     * @return {?}
     */
    UrlParser.prototype.parseQueryParam = function (params) {
        var /** @type {?} */ key = matchQueryParams(this.remaining);
        if (!key) {
            return;
        }
        this.capture(key);
        var /** @type {?} */ value = '';
        if (this.consumeOptional('=')) {
            var /** @type {?} */ valueMatch = matchUrlQueryParamValue(this.remaining);
            if (valueMatch) {
                value = valueMatch;
                this.capture(value);
            }
        }
        var /** @type {?} */ decodedKey = decode(key);
        var /** @type {?} */ decodedVal = decode(value);
        if (params.hasOwnProperty(decodedKey)) {
            // Append to existing values
            var /** @type {?} */ currentVal = params[decodedKey];
            if (!Array.isArray(currentVal)) {
                currentVal = [currentVal];
                params[decodedKey] = currentVal;
            }
            currentVal.push(decodedVal);
        }
        else {
            // Create a new value
            params[decodedKey] = decodedVal;
        }
    };
    /**
     * @param {?} allowPrimary
     * @return {?}
     */
    UrlParser.prototype.parseParens = function (allowPrimary) {
        var /** @type {?} */ segments = {};
        this.capture('(');
        while (!this.consumeOptional(')') && this.remaining.length > 0) {
            var /** @type {?} */ path = matchSegments(this.remaining);
            var /** @type {?} */ next = this.remaining[path.length];
            // if is is not one of these characters, then the segment was unescaped
            // or the group was not closed
            if (next !== '/' && next !== ')' && next !== ';') {
                throw new Error("Cannot parse url '" + this.url + "'");
            }
            var /** @type {?} */ outletName = ((undefined));
            if (path.indexOf(':') > -1) {
                outletName = path.substr(0, path.indexOf(':'));
                this.capture(outletName);
                this.capture(':');
            }
            else if (allowPrimary) {
                outletName = PRIMARY_OUTLET;
            }
            var /** @type {?} */ children = this.parseChildren();
            segments[outletName] = Object.keys(children).length === 1 ? children[PRIMARY_OUTLET] :
                new UrlSegmentGroup([], children);
            this.consumeOptional('//');
        }
        return segments;
    };
    /**
     * @param {?} str
     * @return {?}
     */
    UrlParser.prototype.peekStartsWith = function (str) { return this.remaining.startsWith(str); };
    /**
     * @param {?} str
     * @return {?}
     */
    UrlParser.prototype.consumeOptional = function (str) {
        if (this.peekStartsWith(str)) {
            this.remaining = this.remaining.substring(str.length);
            return true;
        }
        return false;
    };
    /**
     * @param {?} str
     * @return {?}
     */
    UrlParser.prototype.capture = function (str) {
        if (!this.consumeOptional(str)) {
            throw new Error("Expected \"" + str + "\".");
        }
    };
    return UrlParser;
}());
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var NoMatch = (function () {
    /**
     * @param {?=} segmentGroup
     */
    function NoMatch(segmentGroup) {
        this.segmentGroup = segmentGroup || null;
    }
    return NoMatch;
}());
var AbsoluteRedirect = (function () {
    /**
     * @param {?} urlTree
     */
    function AbsoluteRedirect(urlTree) {
        this.urlTree = urlTree;
    }
    return AbsoluteRedirect;
}());
/**
 * @param {?} segmentGroup
 * @return {?}
 */
function noMatch(segmentGroup) {
    return new __WEBPACK_IMPORTED_MODULE_14_rxjs_Observable__["Observable"](function (obs) { return obs.error(new NoMatch(segmentGroup)); });
}
/**
 * @param {?} newTree
 * @return {?}
 */
function absoluteRedirect(newTree) {
    return new __WEBPACK_IMPORTED_MODULE_14_rxjs_Observable__["Observable"](function (obs) { return obs.error(new AbsoluteRedirect(newTree)); });
}
/**
 * @param {?} redirectTo
 * @return {?}
 */
function namedOutletsRedirect(redirectTo) {
    return new __WEBPACK_IMPORTED_MODULE_14_rxjs_Observable__["Observable"](function (obs) { return obs.error(new Error("Only absolute redirects can have named outlets. redirectTo: '" + redirectTo + "'")); });
}
/**
 * @param {?} route
 * @return {?}
 */
function canLoadFails(route) {
    return new __WEBPACK_IMPORTED_MODULE_14_rxjs_Observable__["Observable"](function (obs) { return obs.error(navigationCancelingError("Cannot load children because the guard of the route \"path: '" + route.path + "'\" returned false")); });
}
/**
 * Returns the `UrlTree` with the redirection applied.
 *
 * Lazy modules are loaded along the way.
 * @param {?} moduleInjector
 * @param {?} configLoader
 * @param {?} urlSerializer
 * @param {?} urlTree
 * @param {?} config
 * @return {?}
 */
function applyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config) {
    return new ApplyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config).apply();
}
var ApplyRedirects = (function () {
    /**
     * @param {?} moduleInjector
     * @param {?} configLoader
     * @param {?} urlSerializer
     * @param {?} urlTree
     * @param {?} config
     */
    function ApplyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config) {
        this.configLoader = configLoader;
        this.urlSerializer = urlSerializer;
        this.urlTree = urlTree;
        this.config = config;
        this.allowRedirects = true;
        this.ngModule = moduleInjector.get(__WEBPACK_IMPORTED_MODULE_2__angular_core__["NgModuleRef"]);
    }
    /**
     * @return {?}
     */
    ApplyRedirects.prototype.apply = function () {
        var _this = this;
        var /** @type {?} */ expanded$ = this.expandSegmentGroup(this.ngModule, this.config, this.urlTree.root, PRIMARY_OUTLET);
        var /** @type {?} */ urlTrees$ = __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(expanded$, function (rootSegmentGroup) { return _this.createUrlTree(rootSegmentGroup, _this.urlTree.queryParams, /** @type {?} */ ((_this.urlTree.fragment))); });
        return __WEBPACK_IMPORTED_MODULE_15_rxjs_operator_catch__["_catch"].call(urlTrees$, function (e) {
            if (e instanceof AbsoluteRedirect) {
                // after an absolute redirect we do not apply any more redirects!
                _this.allowRedirects = false;
                // we need to run matching, so we can fetch all lazy-loaded modules
                return _this.match(e.urlTree);
            }
            if (e instanceof NoMatch) {
                throw _this.noMatchError(e);
            }
            throw e;
        });
    };
    /**
     * @param {?} tree
     * @return {?}
     */
    ApplyRedirects.prototype.match = function (tree) {
        var _this = this;
        var /** @type {?} */ expanded$ = this.expandSegmentGroup(this.ngModule, this.config, tree.root, PRIMARY_OUTLET);
        var /** @type {?} */ mapped$ = __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(expanded$, function (rootSegmentGroup) { return _this.createUrlTree(rootSegmentGroup, tree.queryParams, /** @type {?} */ ((tree.fragment))); });
        return __WEBPACK_IMPORTED_MODULE_15_rxjs_operator_catch__["_catch"].call(mapped$, function (e) {
            if (e instanceof NoMatch) {
                throw _this.noMatchError(e);
            }
            throw e;
        });
    };
    /**
     * @param {?} e
     * @return {?}
     */
    ApplyRedirects.prototype.noMatchError = function (e) {
        return new Error("Cannot match any routes. URL Segment: '" + e.segmentGroup + "'");
    };
    /**
     * @param {?} rootCandidate
     * @param {?} queryParams
     * @param {?} fragment
     * @return {?}
     */
    ApplyRedirects.prototype.createUrlTree = function (rootCandidate, queryParams, fragment) {
        var /** @type {?} */ root = rootCandidate.segments.length > 0 ?
            new UrlSegmentGroup([], (_a = {}, _a[PRIMARY_OUTLET] = rootCandidate, _a)) :
            rootCandidate;
        return new UrlTree(root, queryParams, fragment);
        var _a;
    };
    /**
     * @param {?} ngModule
     * @param {?} routes
     * @param {?} segmentGroup
     * @param {?} outlet
     * @return {?}
     */
    ApplyRedirects.prototype.expandSegmentGroup = function (ngModule, routes, segmentGroup, outlet) {
        if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
            return __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(this.expandChildren(ngModule, routes, segmentGroup), function (children) { return new UrlSegmentGroup([], children); });
        }
        return this.expandSegment(ngModule, segmentGroup, routes, segmentGroup.segments, outlet, true);
    };
    /**
     * @param {?} ngModule
     * @param {?} routes
     * @param {?} segmentGroup
     * @return {?}
     */
    ApplyRedirects.prototype.expandChildren = function (ngModule, routes, segmentGroup) {
        var _this = this;
        return waitForMap(segmentGroup.children, function (childOutlet, child) { return _this.expandSegmentGroup(ngModule, routes, child, childOutlet); });
    };
    /**
     * @param {?} ngModule
     * @param {?} segmentGroup
     * @param {?} routes
     * @param {?} segments
     * @param {?} outlet
     * @param {?} allowRedirects
     * @return {?}
     */
    ApplyRedirects.prototype.expandSegment = function (ngModule, segmentGroup, routes, segments, outlet, allowRedirects) {
        var _this = this;
        var /** @type {?} */ routes$ = __WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"].apply(void 0, routes);
        var /** @type {?} */ processedRoutes$ = __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(routes$, function (r) {
            var /** @type {?} */ expanded$ = _this.expandSegmentAgainstRoute(ngModule, segmentGroup, routes, r, segments, outlet, allowRedirects);
            return __WEBPACK_IMPORTED_MODULE_15_rxjs_operator_catch__["_catch"].call(expanded$, function (e) {
                if (e instanceof NoMatch) {
                    return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(null);
                }
                throw e;
            });
        });
        var /** @type {?} */ concattedProcessedRoutes$ = __WEBPACK_IMPORTED_MODULE_16_rxjs_operator_concatAll__["concatAll"].call(processedRoutes$);
        var /** @type {?} */ first$ = __WEBPACK_IMPORTED_MODULE_9_rxjs_operator_first__["first"].call(concattedProcessedRoutes$, function (s) { return !!s; });
        return __WEBPACK_IMPORTED_MODULE_15_rxjs_operator_catch__["_catch"].call(first$, function (e, _) {
            if (e instanceof __WEBPACK_IMPORTED_MODULE_17_rxjs_util_EmptyError__["EmptyError"]) {
                if (_this.noLeftoversInUrl(segmentGroup, segments, outlet)) {
                    return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(new UrlSegmentGroup([], {}));
                }
                throw new NoMatch(segmentGroup);
            }
            throw e;
        });
    };
    /**
     * @param {?} segmentGroup
     * @param {?} segments
     * @param {?} outlet
     * @return {?}
     */
    ApplyRedirects.prototype.noLeftoversInUrl = function (segmentGroup, segments, outlet) {
        return segments.length === 0 && !segmentGroup.children[outlet];
    };
    /**
     * @param {?} ngModule
     * @param {?} segmentGroup
     * @param {?} routes
     * @param {?} route
     * @param {?} paths
     * @param {?} outlet
     * @param {?} allowRedirects
     * @return {?}
     */
    ApplyRedirects.prototype.expandSegmentAgainstRoute = function (ngModule, segmentGroup, routes, route, paths, outlet, allowRedirects) {
        if (getOutlet(route) !== outlet) {
            return noMatch(segmentGroup);
        }
        if (route.redirectTo === undefined) {
            return this.matchSegmentAgainstRoute(ngModule, segmentGroup, route, paths);
        }
        if (allowRedirects && this.allowRedirects) {
            return this.expandSegmentAgainstRouteUsingRedirect(ngModule, segmentGroup, routes, route, paths, outlet);
        }
        return noMatch(segmentGroup);
    };
    /**
     * @param {?} ngModule
     * @param {?} segmentGroup
     * @param {?} routes
     * @param {?} route
     * @param {?} segments
     * @param {?} outlet
     * @return {?}
     */
    ApplyRedirects.prototype.expandSegmentAgainstRouteUsingRedirect = function (ngModule, segmentGroup, routes, route, segments, outlet) {
        if (route.path === '**') {
            return this.expandWildCardWithParamsAgainstRouteUsingRedirect(ngModule, routes, route, outlet);
        }
        return this.expandRegularSegmentAgainstRouteUsingRedirect(ngModule, segmentGroup, routes, route, segments, outlet);
    };
    /**
     * @param {?} ngModule
     * @param {?} routes
     * @param {?} route
     * @param {?} outlet
     * @return {?}
     */
    ApplyRedirects.prototype.expandWildCardWithParamsAgainstRouteUsingRedirect = function (ngModule, routes, route, outlet) {
        var _this = this;
        var /** @type {?} */ newTree = this.applyRedirectCommands([], /** @type {?} */ ((route.redirectTo)), {});
        if (((route.redirectTo)).startsWith('/')) {
            return absoluteRedirect(newTree);
        }
        return __WEBPACK_IMPORTED_MODULE_12_rxjs_operator_mergeMap__["mergeMap"].call(this.lineralizeSegments(route, newTree), function (newSegments) {
            var /** @type {?} */ group = new UrlSegmentGroup(newSegments, {});
            return _this.expandSegment(ngModule, group, routes, newSegments, outlet, false);
        });
    };
    /**
     * @param {?} ngModule
     * @param {?} segmentGroup
     * @param {?} routes
     * @param {?} route
     * @param {?} segments
     * @param {?} outlet
     * @return {?}
     */
    ApplyRedirects.prototype.expandRegularSegmentAgainstRouteUsingRedirect = function (ngModule, segmentGroup, routes, route, segments, outlet) {
        var _this = this;
        var _a = match(segmentGroup, route, segments), matched = _a.matched, consumedSegments = _a.consumedSegments, lastChild = _a.lastChild, positionalParamSegments = _a.positionalParamSegments;
        if (!matched)
            return noMatch(segmentGroup);
        var /** @type {?} */ newTree = this.applyRedirectCommands(consumedSegments, /** @type {?} */ ((route.redirectTo)), /** @type {?} */ (positionalParamSegments));
        if (((route.redirectTo)).startsWith('/')) {
            return absoluteRedirect(newTree);
        }
        return __WEBPACK_IMPORTED_MODULE_12_rxjs_operator_mergeMap__["mergeMap"].call(this.lineralizeSegments(route, newTree), function (newSegments) {
            return _this.expandSegment(ngModule, segmentGroup, routes, newSegments.concat(segments.slice(lastChild)), outlet, false);
        });
    };
    /**
     * @param {?} ngModule
     * @param {?} rawSegmentGroup
     * @param {?} route
     * @param {?} segments
     * @return {?}
     */
    ApplyRedirects.prototype.matchSegmentAgainstRoute = function (ngModule, rawSegmentGroup, route, segments) {
        var _this = this;
        if (route.path === '**') {
            if (route.loadChildren) {
                return __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(this.configLoader.load(ngModule.injector, route), function (cfg) {
                    route._loadedConfig = cfg;
                    return new UrlSegmentGroup(segments, {});
                });
            }
            return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(new UrlSegmentGroup(segments, {}));
        }
        var _a = match(rawSegmentGroup, route, segments), matched = _a.matched, consumedSegments = _a.consumedSegments, lastChild = _a.lastChild;
        if (!matched)
            return noMatch(rawSegmentGroup);
        var /** @type {?} */ rawSlicedSegments = segments.slice(lastChild);
        var /** @type {?} */ childConfig$ = this.getChildConfig(ngModule, route);
        return __WEBPACK_IMPORTED_MODULE_12_rxjs_operator_mergeMap__["mergeMap"].call(childConfig$, function (routerConfig) {
            var /** @type {?} */ childModule = routerConfig.module;
            var /** @type {?} */ childConfig = routerConfig.routes;
            var _a = split(rawSegmentGroup, consumedSegments, rawSlicedSegments, childConfig), segmentGroup = _a.segmentGroup, slicedSegments = _a.slicedSegments;
            if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {
                var /** @type {?} */ expanded$_1 = _this.expandChildren(childModule, childConfig, segmentGroup);
                return __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(expanded$_1, function (children) { return new UrlSegmentGroup(consumedSegments, children); });
            }
            if (childConfig.length === 0 && slicedSegments.length === 0) {
                return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(new UrlSegmentGroup(consumedSegments, {}));
            }
            var /** @type {?} */ expanded$ = _this.expandSegment(childModule, segmentGroup, childConfig, slicedSegments, PRIMARY_OUTLET, true);
            return __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(expanded$, function (cs) { return new UrlSegmentGroup(consumedSegments.concat(cs.segments), cs.children); });
        });
    };
    /**
     * @param {?} ngModule
     * @param {?} route
     * @return {?}
     */
    ApplyRedirects.prototype.getChildConfig = function (ngModule, route) {
        var _this = this;
        if (route.children) {
            // The children belong to the same module
            return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(new LoadedRouterConfig(route.children, ngModule));
        }
        if (route.loadChildren) {
            // lazy children belong to the loaded module
            if (route._loadedConfig !== undefined) {
                return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(route._loadedConfig);
            }
            return __WEBPACK_IMPORTED_MODULE_12_rxjs_operator_mergeMap__["mergeMap"].call(runCanLoadGuard(ngModule.injector, route), function (shouldLoad) {
                if (shouldLoad) {
                    return __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(_this.configLoader.load(ngModule.injector, route), function (cfg) {
                        route._loadedConfig = cfg;
                        return cfg;
                    });
                }
                return canLoadFails(route);
            });
        }
        return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(new LoadedRouterConfig([], ngModule));
    };
    /**
     * @param {?} route
     * @param {?} urlTree
     * @return {?}
     */
    ApplyRedirects.prototype.lineralizeSegments = function (route, urlTree) {
        var /** @type {?} */ res = [];
        var /** @type {?} */ c = urlTree.root;
        while (true) {
            res = res.concat(c.segments);
            if (c.numberOfChildren === 0) {
                return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(res);
            }
            if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {
                return namedOutletsRedirect(/** @type {?} */ ((route.redirectTo)));
            }
            c = c.children[PRIMARY_OUTLET];
        }
    };
    /**
     * @param {?} segments
     * @param {?} redirectTo
     * @param {?} posParams
     * @return {?}
     */
    ApplyRedirects.prototype.applyRedirectCommands = function (segments, redirectTo, posParams) {
        return this.applyRedirectCreatreUrlTree(redirectTo, this.urlSerializer.parse(redirectTo), segments, posParams);
    };
    /**
     * @param {?} redirectTo
     * @param {?} urlTree
     * @param {?} segments
     * @param {?} posParams
     * @return {?}
     */
    ApplyRedirects.prototype.applyRedirectCreatreUrlTree = function (redirectTo, urlTree, segments, posParams) {
        var /** @type {?} */ newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);
        return new UrlTree(newRoot, this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams), urlTree.fragment);
    };
    /**
     * @param {?} redirectToParams
     * @param {?} actualParams
     * @return {?}
     */
    ApplyRedirects.prototype.createQueryParams = function (redirectToParams, actualParams) {
        var /** @type {?} */ res = {};
        forEach(redirectToParams, function (v, k) {
            var /** @type {?} */ copySourceValue = typeof v === 'string' && v.startsWith(':');
            if (copySourceValue) {
                var /** @type {?} */ sourceName = v.substring(1);
                res[k] = actualParams[sourceName];
            }
            else {
                res[k] = v;
            }
        });
        return res;
    };
    /**
     * @param {?} redirectTo
     * @param {?} group
     * @param {?} segments
     * @param {?} posParams
     * @return {?}
     */
    ApplyRedirects.prototype.createSegmentGroup = function (redirectTo, group, segments, posParams) {
        var _this = this;
        var /** @type {?} */ updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);
        var /** @type {?} */ children = {};
        forEach(group.children, function (child, name) {
            children[name] = _this.createSegmentGroup(redirectTo, child, segments, posParams);
        });
        return new UrlSegmentGroup(updatedSegments, children);
    };
    /**
     * @param {?} redirectTo
     * @param {?} redirectToSegments
     * @param {?} actualSegments
     * @param {?} posParams
     * @return {?}
     */
    ApplyRedirects.prototype.createSegments = function (redirectTo, redirectToSegments, actualSegments, posParams) {
        var _this = this;
        return redirectToSegments.map(function (s) { return s.path.startsWith(':') ? _this.findPosParam(redirectTo, s, posParams) :
            _this.findOrReturn(s, actualSegments); });
    };
    /**
     * @param {?} redirectTo
     * @param {?} redirectToUrlSegment
     * @param {?} posParams
     * @return {?}
     */
    ApplyRedirects.prototype.findPosParam = function (redirectTo, redirectToUrlSegment, posParams) {
        var /** @type {?} */ pos = posParams[redirectToUrlSegment.path.substring(1)];
        if (!pos)
            throw new Error("Cannot redirect to '" + redirectTo + "'. Cannot find '" + redirectToUrlSegment.path + "'.");
        return pos;
    };
    /**
     * @param {?} redirectToUrlSegment
     * @param {?} actualSegments
     * @return {?}
     */
    ApplyRedirects.prototype.findOrReturn = function (redirectToUrlSegment, actualSegments) {
        var /** @type {?} */ idx = 0;
        for (var _i = 0, actualSegments_1 = actualSegments; _i < actualSegments_1.length; _i++) {
            var s = actualSegments_1[_i];
            if (s.path === redirectToUrlSegment.path) {
                actualSegments.splice(idx);
                return s;
            }
            idx++;
        }
        return redirectToUrlSegment;
    };
    return ApplyRedirects;
}());
/**
 * @param {?} moduleInjector
 * @param {?} route
 * @return {?}
 */
function runCanLoadGuard(moduleInjector, route) {
    var /** @type {?} */ canLoad = route.canLoad;
    if (!canLoad || canLoad.length === 0)
        return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(true);
    var /** @type {?} */ obs = __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_from__["from"])(canLoad), function (injectionToken) {
        var /** @type {?} */ guard = moduleInjector.get(injectionToken);
        return wrapIntoObservable(guard.canLoad ? guard.canLoad(route) : guard(route));
    });
    return andObservables(obs);
}
/**
 * @param {?} segmentGroup
 * @param {?} route
 * @param {?} segments
 * @return {?}
 */
function match(segmentGroup, route, segments) {
    if (route.path === '') {
        if ((route.pathMatch === 'full') && (segmentGroup.hasChildren() || segments.length > 0)) {
            return { matched: false, consumedSegments: [], lastChild: 0, positionalParamSegments: {} };
        }
        return { matched: true, consumedSegments: [], lastChild: 0, positionalParamSegments: {} };
    }
    var /** @type {?} */ matcher = route.matcher || defaultUrlMatcher;
    var /** @type {?} */ res = matcher(segments, segmentGroup, route);
    if (!res) {
        return {
            matched: false,
            consumedSegments: /** @type {?} */ ([]),
            lastChild: 0,
            positionalParamSegments: {},
        };
    }
    return {
        matched: true,
        consumedSegments: /** @type {?} */ ((res.consumed)),
        lastChild: /** @type {?} */ ((res.consumed.length)),
        positionalParamSegments: /** @type {?} */ ((res.posParams)),
    };
}
/**
 * @param {?} segmentGroup
 * @param {?} consumedSegments
 * @param {?} slicedSegments
 * @param {?} config
 * @return {?}
 */
function split(segmentGroup, consumedSegments, slicedSegments, config) {
    if (slicedSegments.length > 0 &&
        containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, slicedSegments, config)) {
        var /** @type {?} */ s = new UrlSegmentGroup(consumedSegments, createChildrenForEmptySegments(config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));
        return { segmentGroup: mergeTrivialChildren(s), slicedSegments: [] };
    }
    if (slicedSegments.length === 0 &&
        containsEmptyPathRedirects(segmentGroup, slicedSegments, config)) {
        var /** @type {?} */ s = new UrlSegmentGroup(segmentGroup.segments, addEmptySegmentsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children));
        return { segmentGroup: mergeTrivialChildren(s), slicedSegments: slicedSegments };
    }
    return { segmentGroup: segmentGroup, slicedSegments: slicedSegments };
}
/**
 * @param {?} s
 * @return {?}
 */
function mergeTrivialChildren(s) {
    if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {
        var /** @type {?} */ c = s.children[PRIMARY_OUTLET];
        return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);
    }
    return s;
}
/**
 * @param {?} segmentGroup
 * @param {?} slicedSegments
 * @param {?} routes
 * @param {?} children
 * @return {?}
 */
function addEmptySegmentsToChildrenIfNeeded(segmentGroup, slicedSegments, routes, children) {
    var /** @type {?} */ res = {};
    for (var _i = 0, routes_1 = routes; _i < routes_1.length; _i++) {
        var r = routes_1[_i];
        if (isEmptyPathRedirect(segmentGroup, slicedSegments, r) && !children[getOutlet(r)]) {
            res[getOutlet(r)] = new UrlSegmentGroup([], {});
        }
    }
    return Object.assign({}, children, res);
}
/**
 * @param {?} routes
 * @param {?} primarySegmentGroup
 * @return {?}
 */
function createChildrenForEmptySegments(routes, primarySegmentGroup) {
    var /** @type {?} */ res = {};
    res[PRIMARY_OUTLET] = primarySegmentGroup;
    for (var _i = 0, routes_2 = routes; _i < routes_2.length; _i++) {
        var r = routes_2[_i];
        if (r.path === '' && getOutlet(r) !== PRIMARY_OUTLET) {
            res[getOutlet(r)] = new UrlSegmentGroup([], {});
        }
    }
    return res;
}
/**
 * @param {?} segmentGroup
 * @param {?} segments
 * @param {?} routes
 * @return {?}
 */
function containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, segments, routes) {
    return routes.some(function (r) { return isEmptyPathRedirect(segmentGroup, segments, r) && getOutlet(r) !== PRIMARY_OUTLET; });
}
/**
 * @param {?} segmentGroup
 * @param {?} segments
 * @param {?} routes
 * @return {?}
 */
function containsEmptyPathRedirects(segmentGroup, segments, routes) {
    return routes.some(function (r) { return isEmptyPathRedirect(segmentGroup, segments, r); });
}
/**
 * @param {?} segmentGroup
 * @param {?} segments
 * @param {?} r
 * @return {?}
 */
function isEmptyPathRedirect(segmentGroup, segments, r) {
    if ((segmentGroup.hasChildren() || segments.length > 0) && r.pathMatch === 'full') {
        return false;
    }
    return r.path === '' && r.redirectTo !== undefined;
}
/**
 * @param {?} route
 * @return {?}
 */
function getOutlet(route) {
    return route.outlet || PRIMARY_OUTLET;
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var Tree = (function () {
    /**
     * @param {?} root
     */
    function Tree(root) {
        this._root = root;
    }
    Object.defineProperty(Tree.prototype, "root", {
        /**
         * @return {?}
         */
        get: function () { return this._root.value; },
        enumerable: true,
        configurable: true
    });
    /**
     * \@internal
     * @param {?} t
     * @return {?}
     */
    Tree.prototype.parent = function (t) {
        var /** @type {?} */ p = this.pathFromRoot(t);
        return p.length > 1 ? p[p.length - 2] : null;
    };
    /**
     * \@internal
     * @param {?} t
     * @return {?}
     */
    Tree.prototype.children = function (t) {
        var /** @type {?} */ n = findNode(t, this._root);
        return n ? n.children.map(function (t) { return t.value; }) : [];
    };
    /**
     * \@internal
     * @param {?} t
     * @return {?}
     */
    Tree.prototype.firstChild = function (t) {
        var /** @type {?} */ n = findNode(t, this._root);
        return n && n.children.length > 0 ? n.children[0].value : null;
    };
    /**
     * \@internal
     * @param {?} t
     * @return {?}
     */
    Tree.prototype.siblings = function (t) {
        var /** @type {?} */ p = findPath(t, this._root);
        if (p.length < 2)
            return [];
        var /** @type {?} */ c = p[p.length - 2].children.map(function (c) { return c.value; });
        return c.filter(function (cc) { return cc !== t; });
    };
    /**
     * \@internal
     * @param {?} t
     * @return {?}
     */
    Tree.prototype.pathFromRoot = function (t) { return findPath(t, this._root).map(function (s) { return s.value; }); };
    return Tree;
}());
/**
 * @template T
 * @param {?} value
 * @param {?} node
 * @return {?}
 */
function findNode(value, node) {
    if (value === node.value)
        return node;
    for (var _i = 0, _a = node.children; _i < _a.length; _i++) {
        var child = _a[_i];
        var /** @type {?} */ node_1 = findNode(value, child);
        if (node_1)
            return node_1;
    }
    return null;
}
/**
 * @template T
 * @param {?} value
 * @param {?} node
 * @return {?}
 */
function findPath(value, node) {
    if (value === node.value)
        return [node];
    for (var _i = 0, _a = node.children; _i < _a.length; _i++) {
        var child = _a[_i];
        var /** @type {?} */ path = findPath(value, child);
        if (path.length) {
            path.unshift(node);
            return path;
        }
    }
    return [];
}
var TreeNode = (function () {
    /**
     * @param {?} value
     * @param {?} children
     */
    function TreeNode(value, children) {
        this.value = value;
        this.children = children;
    }
    /**
     * @return {?}
     */
    TreeNode.prototype.toString = function () { return "TreeNode(" + this.value + ")"; };
    return TreeNode;
}());
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * \@whatItDoes Represents the state of the router.
 *
 * \@howToUse
 *
 * ```
 * \@Component({templateUrl:'template.html'})
 * class MyComponent {
 *   constructor(router: Router) {
 *     const state: RouterState = router.routerState;
 *     const root: ActivatedRoute = state.root;
 *     const child = root.firstChild;
 *     const id: Observable<string> = child.params.map(p => p.id);
 *     //...
 *   }
 * }
 * ```
 *
 * \@description
 * RouterState is a tree of activated routes. Every node in this tree knows about the "consumed" URL
 * segments, the extracted parameters, and the resolved data.
 *
 * See {\@link ActivatedRoute} for more information.
 *
 * \@stable
 */
var RouterState = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](RouterState, _super);
    /**
     * \@internal
     * @param {?} root
     * @param {?} snapshot
     */
    function RouterState(root, snapshot) {
        var _this = _super.call(this, root) || this;
        _this.snapshot = snapshot;
        setRouterState(_this, root);
        return _this;
    }
    /**
     * @return {?}
     */
    RouterState.prototype.toString = function () { return this.snapshot.toString(); };
    return RouterState;
}(Tree));
/**
 * @param {?} urlTree
 * @param {?} rootComponent
 * @return {?}
 */
function createEmptyState(urlTree, rootComponent) {
    var /** @type {?} */ snapshot = createEmptyStateSnapshot(urlTree, rootComponent);
    var /** @type {?} */ emptyUrl = new __WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject__["BehaviorSubject"]([new UrlSegment('', {})]);
    var /** @type {?} */ emptyParams = new __WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject__["BehaviorSubject"]({});
    var /** @type {?} */ emptyData = new __WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject__["BehaviorSubject"]({});
    var /** @type {?} */ emptyQueryParams = new __WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject__["BehaviorSubject"]({});
    var /** @type {?} */ fragment = new __WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject__["BehaviorSubject"]('');
    var /** @type {?} */ activated = new ActivatedRoute(emptyUrl, emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, snapshot.root);
    activated.snapshot = snapshot.root;
    return new RouterState(new TreeNode(activated, []), snapshot);
}
/**
 * @param {?} urlTree
 * @param {?} rootComponent
 * @return {?}
 */
function createEmptyStateSnapshot(urlTree, rootComponent) {
    var /** @type {?} */ emptyParams = {};
    var /** @type {?} */ emptyData = {};
    var /** @type {?} */ emptyQueryParams = {};
    var /** @type {?} */ fragment = '';
    var /** @type {?} */ activated = new ActivatedRouteSnapshot([], emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, null, urlTree.root, -1, {});
    return new RouterStateSnapshot('', new TreeNode(activated, []));
}
/**
 * \@whatItDoes Contains the information about a route associated with a component loaded in an
 * outlet.
 * An `ActivatedRoute` can also be used to traverse the router state tree.
 *
 * \@howToUse
 *
 * ```
 * \@Component({...})
 * class MyComponent {
 *   constructor(route: ActivatedRoute) {
 *     const id: Observable<string> = route.params.map(p => p.id);
 *     const url: Observable<string> = route.url.map(segments => segments.join(''));
 *     // route.data includes both `data` and `resolve`
 *     const user = route.data.map(d => d.user);
 *   }
 * }
 * ```
 *
 * \@stable
 */
var ActivatedRoute = (function () {
    /**
     * \@internal
     * @param {?} url
     * @param {?} params
     * @param {?} queryParams
     * @param {?} fragment
     * @param {?} data
     * @param {?} outlet
     * @param {?} component
     * @param {?} futureSnapshot
     */
    function ActivatedRoute(url, params, queryParams, fragment, data, outlet, component, futureSnapshot) {
        this.url = url;
        this.params = params;
        this.queryParams = queryParams;
        this.fragment = fragment;
        this.data = data;
        this.outlet = outlet;
        this.component = component;
        this._futureSnapshot = futureSnapshot;
    }
    Object.defineProperty(ActivatedRoute.prototype, "routeConfig", {
        /**
         * The configuration used to match this route
         * @return {?}
         */
        get: function () { return this._futureSnapshot.routeConfig; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivatedRoute.prototype, "root", {
        /**
         * The root of the router state
         * @return {?}
         */
        get: function () { return this._routerState.root; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivatedRoute.prototype, "parent", {
        /**
         * The parent of this route in the router state tree
         * @return {?}
         */
        get: function () { return this._routerState.parent(this); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivatedRoute.prototype, "firstChild", {
        /**
         * The first child of this route in the router state tree
         * @return {?}
         */
        get: function () { return this._routerState.firstChild(this); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivatedRoute.prototype, "children", {
        /**
         * The children of this route in the router state tree
         * @return {?}
         */
        get: function () { return this._routerState.children(this); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivatedRoute.prototype, "pathFromRoot", {
        /**
         * The path from the root of the router state tree to this route
         * @return {?}
         */
        get: function () { return this._routerState.pathFromRoot(this); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivatedRoute.prototype, "paramMap", {
        /**
         * @return {?}
         */
        get: function () {
            if (!this._paramMap) {
                this._paramMap = __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(this.params, function (p) { return convertToParamMap(p); });
            }
            return this._paramMap;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivatedRoute.prototype, "queryParamMap", {
        /**
         * @return {?}
         */
        get: function () {
            if (!this._queryParamMap) {
                this._queryParamMap =
                    __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(this.queryParams, function (p) { return convertToParamMap(p); });
            }
            return this._queryParamMap;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ActivatedRoute.prototype.toString = function () {
        return this.snapshot ? this.snapshot.toString() : "Future(" + this._futureSnapshot + ")";
    };
    return ActivatedRoute;
}());
/**
 * \@internal
 * @param {?} route
 * @return {?}
 */
function inheritedParamsDataResolve(route) {
    var /** @type {?} */ pathToRoot = route.pathFromRoot;
    var /** @type {?} */ inhertingStartingFrom = pathToRoot.length - 1;
    while (inhertingStartingFrom >= 1) {
        var /** @type {?} */ current = pathToRoot[inhertingStartingFrom];
        var /** @type {?} */ parent = pathToRoot[inhertingStartingFrom - 1];
        // current route is an empty path => inherits its parent's params and data
        if (current.routeConfig && current.routeConfig.path === '') {
            inhertingStartingFrom--;
            // parent is componentless => current route should inherit its params and data
        }
        else if (!parent.component) {
            inhertingStartingFrom--;
        }
        else {
            break;
        }
    }
    return pathToRoot.slice(inhertingStartingFrom).reduce(function (res, curr) {
        var /** @type {?} */ params = Object.assign({}, res.params, curr.params);
        var /** @type {?} */ data = Object.assign({}, res.data, curr.data);
        var /** @type {?} */ resolve = Object.assign({}, res.resolve, curr._resolvedData);
        return { params: params, data: data, resolve: resolve };
    }, /** @type {?} */ ({ params: {}, data: {}, resolve: {} }));
}
/**
 * \@whatItDoes Contains the information about a route associated with a component loaded in an
 * outlet
 * at a particular moment in time. ActivatedRouteSnapshot can also be used to traverse the router
 * state tree.
 *
 * \@howToUse
 *
 * ```
 * \@Component({templateUrl:'./my-component.html'})
 * class MyComponent {
 *   constructor(route: ActivatedRoute) {
 *     const id: string = route.snapshot.params.id;
 *     const url: string = route.snapshot.url.join('');
 *     const user = route.snapshot.data.user;
 *   }
 * }
 * ```
 *
 * \@stable
 */
var ActivatedRouteSnapshot = (function () {
    /**
     * \@internal
     * @param {?} url
     * @param {?} params
     * @param {?} queryParams
     * @param {?} fragment
     * @param {?} data
     * @param {?} outlet
     * @param {?} component
     * @param {?} routeConfig
     * @param {?} urlSegment
     * @param {?} lastPathIndex
     * @param {?} resolve
     */
    function ActivatedRouteSnapshot(url, params, queryParams, fragment, data, outlet, component, routeConfig, urlSegment, lastPathIndex, resolve) {
        this.url = url;
        this.params = params;
        this.queryParams = queryParams;
        this.fragment = fragment;
        this.data = data;
        this.outlet = outlet;
        this.component = component;
        this._routeConfig = routeConfig;
        this._urlSegment = urlSegment;
        this._lastPathIndex = lastPathIndex;
        this._resolve = resolve;
    }
    Object.defineProperty(ActivatedRouteSnapshot.prototype, "routeConfig", {
        /**
         * The configuration used to match this route
         * @return {?}
         */
        get: function () { return this._routeConfig; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivatedRouteSnapshot.prototype, "root", {
        /**
         * The root of the router state
         * @return {?}
         */
        get: function () { return this._routerState.root; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivatedRouteSnapshot.prototype, "parent", {
        /**
         * The parent of this route in the router state tree
         * @return {?}
         */
        get: function () { return this._routerState.parent(this); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivatedRouteSnapshot.prototype, "firstChild", {
        /**
         * The first child of this route in the router state tree
         * @return {?}
         */
        get: function () { return this._routerState.firstChild(this); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivatedRouteSnapshot.prototype, "children", {
        /**
         * The children of this route in the router state tree
         * @return {?}
         */
        get: function () { return this._routerState.children(this); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivatedRouteSnapshot.prototype, "pathFromRoot", {
        /**
         * The path from the root of the router state tree to this route
         * @return {?}
         */
        get: function () { return this._routerState.pathFromRoot(this); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivatedRouteSnapshot.prototype, "paramMap", {
        /**
         * @return {?}
         */
        get: function () {
            if (!this._paramMap) {
                this._paramMap = convertToParamMap(this.params);
            }
            return this._paramMap;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivatedRouteSnapshot.prototype, "queryParamMap", {
        /**
         * @return {?}
         */
        get: function () {
            if (!this._queryParamMap) {
                this._queryParamMap = convertToParamMap(this.queryParams);
            }
            return this._queryParamMap;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ActivatedRouteSnapshot.prototype.toString = function () {
        var /** @type {?} */ url = this.url.map(function (segment) { return segment.toString(); }).join('/');
        var /** @type {?} */ matched = this._routeConfig ? this._routeConfig.path : '';
        return "Route(url:'" + url + "', path:'" + matched + "')";
    };
    return ActivatedRouteSnapshot;
}());
/**
 * \@whatItDoes Represents the state of the router at a moment in time.
 *
 * \@howToUse
 *
 * ```
 * \@Component({templateUrl:'template.html'})
 * class MyComponent {
 *   constructor(router: Router) {
 *     const state: RouterState = router.routerState;
 *     const snapshot: RouterStateSnapshot = state.snapshot;
 *     const root: ActivatedRouteSnapshot = snapshot.root;
 *     const child = root.firstChild;
 *     const id: Observable<string> = child.params.map(p => p.id);
 *     //...
 *   }
 * }
 * ```
 *
 * \@description
 * RouterStateSnapshot is a tree of activated route snapshots. Every node in this tree knows about
 * the "consumed" URL segments, the extracted parameters, and the resolved data.
 *
 * \@stable
 */
var RouterStateSnapshot = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](RouterStateSnapshot, _super);
    /**
     * \@internal
     * @param {?} url
     * @param {?} root
     */
    function RouterStateSnapshot(url, root) {
        var _this = _super.call(this, root) || this;
        _this.url = url;
        setRouterState(_this, root);
        return _this;
    }
    /**
     * @return {?}
     */
    RouterStateSnapshot.prototype.toString = function () { return serializeNode(this._root); };
    return RouterStateSnapshot;
}(Tree));
/**
 * @template U, T
 * @param {?} state
 * @param {?} node
 * @return {?}
 */
function setRouterState(state, node) {
    node.value._routerState = state;
    node.children.forEach(function (c) { return setRouterState(state, c); });
}
/**
 * @param {?} node
 * @return {?}
 */
function serializeNode(node) {
    var /** @type {?} */ c = node.children.length > 0 ? " { " + node.children.map(serializeNode).join(", ") + " } " : '';
    return "" + node.value + c;
}
/**
 * The expectation is that the activate route is created with the right set of parameters.
 * So we push new values into the observables only when they are not the initial values.
 * And we detect that by checking if the snapshot field is set.
 * @param {?} route
 * @return {?}
 */
function advanceActivatedRoute(route) {
    if (route.snapshot) {
        var /** @type {?} */ currentSnapshot = route.snapshot;
        var /** @type {?} */ nextSnapshot = route._futureSnapshot;
        route.snapshot = nextSnapshot;
        if (!shallowEqual(currentSnapshot.queryParams, nextSnapshot.queryParams)) {
            ((route.queryParams)).next(nextSnapshot.queryParams);
        }
        if (currentSnapshot.fragment !== nextSnapshot.fragment) {
            ((route.fragment)).next(nextSnapshot.fragment);
        }
        if (!shallowEqual(currentSnapshot.params, nextSnapshot.params)) {
            ((route.params)).next(nextSnapshot.params);
        }
        if (!shallowEqualArrays(currentSnapshot.url, nextSnapshot.url)) {
            ((route.url)).next(nextSnapshot.url);
        }
        if (!shallowEqual(currentSnapshot.data, nextSnapshot.data)) {
            ((route.data)).next(nextSnapshot.data);
        }
    }
    else {
        route.snapshot = route._futureSnapshot;
        // this is for resolved data
        ((route.data)).next(route._futureSnapshot.data);
    }
}
/**
 * @param {?} a
 * @param {?} b
 * @return {?}
 */
function equalParamsAndUrlSegments(a, b) {
    var /** @type {?} */ equalUrlParams = shallowEqual(a.params, b.params) && equalSegments(a.url, b.url);
    var /** @type {?} */ parentsMismatch = !a.parent !== !b.parent;
    return equalUrlParams && !parentsMismatch &&
        (!a.parent || equalParamsAndUrlSegments(a.parent, /** @type {?} */ ((b.parent))));
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @param {?} routeReuseStrategy
 * @param {?} curr
 * @param {?} prevState
 * @return {?}
 */
function createRouterState(routeReuseStrategy, curr, prevState) {
    var /** @type {?} */ root = createNode(routeReuseStrategy, curr._root, prevState ? prevState._root : undefined);
    return new RouterState(root, curr);
}
/**
 * @param {?} routeReuseStrategy
 * @param {?} curr
 * @param {?=} prevState
 * @return {?}
 */
function createNode(routeReuseStrategy, curr, prevState) {
    // reuse an activated route that is currently displayed on the screen
    if (prevState && routeReuseStrategy.shouldReuseRoute(curr.value, prevState.value.snapshot)) {
        var /** @type {?} */ value = prevState.value;
        value._futureSnapshot = curr.value;
        var /** @type {?} */ children = createOrReuseChildren(routeReuseStrategy, curr, prevState);
        return new TreeNode(value, children);
        // retrieve an activated route that is used to be displayed, but is not currently displayed
    }
    else if (routeReuseStrategy.retrieve(curr.value)) {
        var /** @type {?} */ tree_1 = ((routeReuseStrategy.retrieve(curr.value))).route;
        setFutureSnapshotsOfActivatedRoutes(curr, tree_1);
        return tree_1;
    }
    else {
        var /** @type {?} */ value = createActivatedRoute(curr.value);
        var /** @type {?} */ children = curr.children.map(function (c) { return createNode(routeReuseStrategy, c); });
        return new TreeNode(value, children);
    }
}
/**
 * @param {?} curr
 * @param {?} result
 * @return {?}
 */
function setFutureSnapshotsOfActivatedRoutes(curr, result) {
    if (curr.value.routeConfig !== result.value.routeConfig) {
        throw new Error('Cannot reattach ActivatedRouteSnapshot created from a different route');
    }
    if (curr.children.length !== result.children.length) {
        throw new Error('Cannot reattach ActivatedRouteSnapshot with a different number of children');
    }
    result.value._futureSnapshot = curr.value;
    for (var /** @type {?} */ i = 0; i < curr.children.length; ++i) {
        setFutureSnapshotsOfActivatedRoutes(curr.children[i], result.children[i]);
    }
}
/**
 * @param {?} routeReuseStrategy
 * @param {?} curr
 * @param {?} prevState
 * @return {?}
 */
function createOrReuseChildren(routeReuseStrategy, curr, prevState) {
    return curr.children.map(function (child) {
        for (var _i = 0, _a = prevState.children; _i < _a.length; _i++) {
            var p = _a[_i];
            if (routeReuseStrategy.shouldReuseRoute(p.value.snapshot, child.value)) {
                return createNode(routeReuseStrategy, child, p);
            }
        }
        return createNode(routeReuseStrategy, child);
    });
}
/**
 * @param {?} c
 * @return {?}
 */
function createActivatedRoute(c) {
    return new ActivatedRoute(new __WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject__["BehaviorSubject"](c.url), new __WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject__["BehaviorSubject"](c.params), new __WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject__["BehaviorSubject"](c.queryParams), new __WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject__["BehaviorSubject"](c.fragment), new __WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject__["BehaviorSubject"](c.data), c.outlet, c.component, c);
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @param {?} route
 * @param {?} urlTree
 * @param {?} commands
 * @param {?} queryParams
 * @param {?} fragment
 * @return {?}
 */
function createUrlTree(route, urlTree, commands, queryParams, fragment) {
    if (commands.length === 0) {
        return tree(urlTree.root, urlTree.root, urlTree, queryParams, fragment);
    }
    var /** @type {?} */ nav = computeNavigation(commands);
    if (nav.toRoot()) {
        return tree(urlTree.root, new UrlSegmentGroup([], {}), urlTree, queryParams, fragment);
    }
    var /** @type {?} */ startingPosition = findStartingPosition(nav, urlTree, route);
    var /** @type {?} */ segmentGroup = startingPosition.processChildren ?
        updateSegmentGroupChildren(startingPosition.segmentGroup, startingPosition.index, nav.commands) :
        updateSegmentGroup(startingPosition.segmentGroup, startingPosition.index, nav.commands);
    return tree(startingPosition.segmentGroup, segmentGroup, urlTree, queryParams, fragment);
}
/**
 * @param {?} command
 * @return {?}
 */
function isMatrixParams(command) {
    return typeof command === 'object' && command != null && !command.outlets && !command.segmentPath;
}
/**
 * @param {?} oldSegmentGroup
 * @param {?} newSegmentGroup
 * @param {?} urlTree
 * @param {?} queryParams
 * @param {?} fragment
 * @return {?}
 */
function tree(oldSegmentGroup, newSegmentGroup, urlTree, queryParams, fragment) {
    var /** @type {?} */ qp = {};
    if (queryParams) {
        forEach(queryParams, function (value, name) {
            qp[name] = Array.isArray(value) ? value.map(function (v) { return "" + v; }) : "" + value;
        });
    }
    if (urlTree.root === oldSegmentGroup) {
        return new UrlTree(newSegmentGroup, qp, fragment);
    }
    return new UrlTree(replaceSegment(urlTree.root, oldSegmentGroup, newSegmentGroup), qp, fragment);
}
/**
 * @param {?} current
 * @param {?} oldSegment
 * @param {?} newSegment
 * @return {?}
 */
function replaceSegment(current, oldSegment, newSegment) {
    var /** @type {?} */ children = {};
    forEach(current.children, function (c, outletName) {
        if (c === oldSegment) {
            children[outletName] = newSegment;
        }
        else {
            children[outletName] = replaceSegment(c, oldSegment, newSegment);
        }
    });
    return new UrlSegmentGroup(current.segments, children);
}
var Navigation = (function () {
    /**
     * @param {?} isAbsolute
     * @param {?} numberOfDoubleDots
     * @param {?} commands
     */
    function Navigation(isAbsolute, numberOfDoubleDots, commands) {
        this.isAbsolute = isAbsolute;
        this.numberOfDoubleDots = numberOfDoubleDots;
        this.commands = commands;
        if (isAbsolute && commands.length > 0 && isMatrixParams(commands[0])) {
            throw new Error('Root segment cannot have matrix parameters');
        }
        var cmdWithOutlet = commands.find(function (c) { return typeof c === 'object' && c != null && c.outlets; });
        if (cmdWithOutlet && cmdWithOutlet !== last$1(commands)) {
            throw new Error('{outlets:{}} has to be the last command');
        }
    }
    /**
     * @return {?}
     */
    Navigation.prototype.toRoot = function () {
        return this.isAbsolute && this.commands.length === 1 && this.commands[0] == '/';
    };
    return Navigation;
}());
/**
 * Transforms commands to a normalized `Navigation`
 * @param {?} commands
 * @return {?}
 */
function computeNavigation(commands) {
    if ((typeof commands[0] === 'string') && commands.length === 1 && commands[0] === '/') {
        return new Navigation(true, 0, commands);
    }
    var /** @type {?} */ numberOfDoubleDots = 0;
    var /** @type {?} */ isAbsolute = false;
    var /** @type {?} */ res = commands.reduce(function (res, cmd, cmdIdx) {
        if (typeof cmd === 'object' && cmd != null) {
            if (cmd.outlets) {
                var /** @type {?} */ outlets_1 = {};
                forEach(cmd.outlets, function (commands, name) {
                    outlets_1[name] = typeof commands === 'string' ? commands.split('/') : commands;
                });
                return res.concat([{ outlets: outlets_1 }]);
            }
            if (cmd.segmentPath) {
                return res.concat([cmd.segmentPath]);
            }
        }
        if (!(typeof cmd === 'string')) {
            return res.concat([cmd]);
        }
        if (cmdIdx === 0) {
            cmd.split('/').forEach(function (urlPart, partIndex) {
                if (partIndex == 0 && urlPart === '.') {
                    // skip './a'
                }
                else if (partIndex == 0 && urlPart === '') {
                    isAbsolute = true;
                }
                else if (urlPart === '..') {
                    numberOfDoubleDots++;
                }
                else if (urlPart != '') {
                    res.push(urlPart);
                }
            });
            return res;
        }
        return res.concat([cmd]);
    }, []);
    return new Navigation(isAbsolute, numberOfDoubleDots, res);
}
var Position = (function () {
    /**
     * @param {?} segmentGroup
     * @param {?} processChildren
     * @param {?} index
     */
    function Position(segmentGroup, processChildren, index) {
        this.segmentGroup = segmentGroup;
        this.processChildren = processChildren;
        this.index = index;
    }
    return Position;
}());
/**
 * @param {?} nav
 * @param {?} tree
 * @param {?} route
 * @return {?}
 */
function findStartingPosition(nav, tree, route) {
    if (nav.isAbsolute) {
        return new Position(tree.root, true, 0);
    }
    if (route.snapshot._lastPathIndex === -1) {
        return new Position(route.snapshot._urlSegment, true, 0);
    }
    var /** @type {?} */ modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;
    var /** @type {?} */ index = route.snapshot._lastPathIndex + modifier;
    return createPositionApplyingDoubleDots(route.snapshot._urlSegment, index, nav.numberOfDoubleDots);
}
/**
 * @param {?} group
 * @param {?} index
 * @param {?} numberOfDoubleDots
 * @return {?}
 */
function createPositionApplyingDoubleDots(group, index, numberOfDoubleDots) {
    var /** @type {?} */ g = group;
    var /** @type {?} */ ci = index;
    var /** @type {?} */ dd = numberOfDoubleDots;
    while (dd > ci) {
        dd -= ci;
        g = ((g.parent));
        if (!g) {
            throw new Error('Invalid number of \'../\'');
        }
        ci = g.segments.length;
    }
    return new Position(g, false, ci - dd);
}
/**
 * @param {?} command
 * @return {?}
 */
function getPath(command) {
    if (typeof command === 'object' && command != null && command.outlets) {
        return command.outlets[PRIMARY_OUTLET];
    }
    return "" + command;
}
/**
 * @param {?} commands
 * @return {?}
 */
function getOutlets(commands) {
    if (!(typeof commands[0] === 'object'))
        return _a = {}, _a[PRIMARY_OUTLET] = commands, _a;
    if (commands[0].outlets === undefined)
        return _b = {}, _b[PRIMARY_OUTLET] = commands, _b;
    return commands[0].outlets;
    var _a, _b;
}
/**
 * @param {?} segmentGroup
 * @param {?} startIndex
 * @param {?} commands
 * @return {?}
 */
function updateSegmentGroup(segmentGroup, startIndex, commands) {
    if (!segmentGroup) {
        segmentGroup = new UrlSegmentGroup([], {});
    }
    if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
        return updateSegmentGroupChildren(segmentGroup, startIndex, commands);
    }
    var /** @type {?} */ m = prefixedWith(segmentGroup, startIndex, commands);
    var /** @type {?} */ slicedCommands = commands.slice(m.commandIndex);
    if (m.match && m.pathIndex < segmentGroup.segments.length) {
        var /** @type {?} */ g = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});
        g.children[PRIMARY_OUTLET] =
            new UrlSegmentGroup(segmentGroup.segments.slice(m.pathIndex), segmentGroup.children);
        return updateSegmentGroupChildren(g, 0, slicedCommands);
    }
    else if (m.match && slicedCommands.length === 0) {
        return new UrlSegmentGroup(segmentGroup.segments, {});
    }
    else if (m.match && !segmentGroup.hasChildren()) {
        return createNewSegmentGroup(segmentGroup, startIndex, commands);
    }
    else if (m.match) {
        return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);
    }
    else {
        return createNewSegmentGroup(segmentGroup, startIndex, commands);
    }
}
/**
 * @param {?} segmentGroup
 * @param {?} startIndex
 * @param {?} commands
 * @return {?}
 */
function updateSegmentGroupChildren(segmentGroup, startIndex, commands) {
    if (commands.length === 0) {
        return new UrlSegmentGroup(segmentGroup.segments, {});
    }
    else {
        var /** @type {?} */ outlets_2 = getOutlets(commands);
        var /** @type {?} */ children_2 = {};
        forEach(outlets_2, function (commands, outlet) {
            if (commands !== null) {
                children_2[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands);
            }
        });
        forEach(segmentGroup.children, function (child, childOutlet) {
            if (outlets_2[childOutlet] === undefined) {
                children_2[childOutlet] = child;
            }
        });
        return new UrlSegmentGroup(segmentGroup.segments, children_2);
    }
}
/**
 * @param {?} segmentGroup
 * @param {?} startIndex
 * @param {?} commands
 * @return {?}
 */
function prefixedWith(segmentGroup, startIndex, commands) {
    var /** @type {?} */ currentCommandIndex = 0;
    var /** @type {?} */ currentPathIndex = startIndex;
    var /** @type {?} */ noMatch = { match: false, pathIndex: 0, commandIndex: 0 };
    while (currentPathIndex < segmentGroup.segments.length) {
        if (currentCommandIndex >= commands.length)
            return noMatch;
        var /** @type {?} */ path = segmentGroup.segments[currentPathIndex];
        var /** @type {?} */ curr = getPath(commands[currentCommandIndex]);
        var /** @type {?} */ next = currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;
        if (currentPathIndex > 0 && curr === undefined)
            break;
        if (curr && next && (typeof next === 'object') && next.outlets === undefined) {
            if (!compare(curr, next, path))
                return noMatch;
            currentCommandIndex += 2;
        }
        else {
            if (!compare(curr, {}, path))
                return noMatch;
            currentCommandIndex++;
        }
        currentPathIndex++;
    }
    return { match: true, pathIndex: currentPathIndex, commandIndex: currentCommandIndex };
}
/**
 * @param {?} segmentGroup
 * @param {?} startIndex
 * @param {?} commands
 * @return {?}
 */
function createNewSegmentGroup(segmentGroup, startIndex, commands) {
    var /** @type {?} */ paths = segmentGroup.segments.slice(0, startIndex);
    var /** @type {?} */ i = 0;
    while (i < commands.length) {
        if (typeof commands[i] === 'object' && commands[i].outlets !== undefined) {
            var /** @type {?} */ children = createNewSegmentChildren(commands[i].outlets);
            return new UrlSegmentGroup(paths, children);
        }
        // if we start with an object literal, we need to reuse the path part from the segment
        if (i === 0 && isMatrixParams(commands[0])) {
            var /** @type {?} */ p = segmentGroup.segments[startIndex];
            paths.push(new UrlSegment(p.path, commands[0]));
            i++;
            continue;
        }
        var /** @type {?} */ curr = getPath(commands[i]);
        var /** @type {?} */ next = (i < commands.length - 1) ? commands[i + 1] : null;
        if (curr && next && isMatrixParams(next)) {
            paths.push(new UrlSegment(curr, stringify(next)));
            i += 2;
        }
        else {
            paths.push(new UrlSegment(curr, {}));
            i++;
        }
    }
    return new UrlSegmentGroup(paths, {});
}
/**
 * @param {?} outlets
 * @return {?}
 */
function createNewSegmentChildren(outlets) {
    var /** @type {?} */ children = {};
    forEach(outlets, function (commands, outlet) {
        if (commands !== null) {
            children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);
        }
    });
    return children;
}
/**
 * @param {?} params
 * @return {?}
 */
function stringify(params) {
    var /** @type {?} */ res = {};
    forEach(params, function (v, k) { return res[k] = "" + v; });
    return res;
}
/**
 * @param {?} path
 * @param {?} params
 * @param {?} segment
 * @return {?}
 */
function compare(path, params, segment) {
    return path == segment.path && shallowEqual(params, segment.parameters);
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var NoMatch$1 = (function () {
    function NoMatch$1() {
    }
    return NoMatch$1;
}());
/**
 * @param {?} rootComponentType
 * @param {?} config
 * @param {?} urlTree
 * @param {?} url
 * @return {?}
 */
function recognize(rootComponentType, config, urlTree, url) {
    return new Recognizer(rootComponentType, config, urlTree, url).recognize();
}
var Recognizer = (function () {
    /**
     * @param {?} rootComponentType
     * @param {?} config
     * @param {?} urlTree
     * @param {?} url
     */
    function Recognizer(rootComponentType, config, urlTree, url) {
        this.rootComponentType = rootComponentType;
        this.config = config;
        this.urlTree = urlTree;
        this.url = url;
    }
    /**
     * @return {?}
     */
    Recognizer.prototype.recognize = function () {
        try {
            var /** @type {?} */ rootSegmentGroup = split$1(this.urlTree.root, [], [], this.config).segmentGroup;
            var /** @type {?} */ children = this.processSegmentGroup(this.config, rootSegmentGroup, PRIMARY_OUTLET);
            var /** @type {?} */ root = new ActivatedRouteSnapshot([], Object.freeze({}), Object.freeze(this.urlTree.queryParams), /** @type {?} */ ((this.urlTree.fragment)), {}, PRIMARY_OUTLET, this.rootComponentType, null, this.urlTree.root, -1, {});
            var /** @type {?} */ rootNode = new TreeNode(root, children);
            var /** @type {?} */ routeState = new RouterStateSnapshot(this.url, rootNode);
            this.inheritParamsAndData(routeState._root);
            return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(routeState);
        }
        catch (e) {
            return new __WEBPACK_IMPORTED_MODULE_14_rxjs_Observable__["Observable"](function (obs) { return obs.error(e); });
        }
    };
    /**
     * @param {?} routeNode
     * @return {?}
     */
    Recognizer.prototype.inheritParamsAndData = function (routeNode) {
        var _this = this;
        var /** @type {?} */ route = routeNode.value;
        var /** @type {?} */ i = inheritedParamsDataResolve(route);
        route.params = Object.freeze(i.params);
        route.data = Object.freeze(i.data);
        routeNode.children.forEach(function (n) { return _this.inheritParamsAndData(n); });
    };
    /**
     * @param {?} config
     * @param {?} segmentGroup
     * @param {?} outlet
     * @return {?}
     */
    Recognizer.prototype.processSegmentGroup = function (config, segmentGroup, outlet) {
        if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
            return this.processChildren(config, segmentGroup);
        }
        return this.processSegment(config, segmentGroup, segmentGroup.segments, outlet);
    };
    /**
     * @param {?} config
     * @param {?} segmentGroup
     * @return {?}
     */
    Recognizer.prototype.processChildren = function (config, segmentGroup) {
        var _this = this;
        var /** @type {?} */ children = mapChildrenIntoArray(segmentGroup, function (child, childOutlet) { return _this.processSegmentGroup(config, child, childOutlet); });
        checkOutletNameUniqueness(children);
        sortActivatedRouteSnapshots(children);
        return children;
    };
    /**
     * @param {?} config
     * @param {?} segmentGroup
     * @param {?} segments
     * @param {?} outlet
     * @return {?}
     */
    Recognizer.prototype.processSegment = function (config, segmentGroup, segments, outlet) {
        for (var _i = 0, config_1 = config; _i < config_1.length; _i++) {
            var r = config_1[_i];
            try {
                return this.processSegmentAgainstRoute(r, segmentGroup, segments, outlet);
            }
            catch (e) {
                if (!(e instanceof NoMatch$1))
                    throw e;
            }
        }
        if (this.noLeftoversInUrl(segmentGroup, segments, outlet)) {
            return [];
        }
        throw new NoMatch$1();
    };
    /**
     * @param {?} segmentGroup
     * @param {?} segments
     * @param {?} outlet
     * @return {?}
     */
    Recognizer.prototype.noLeftoversInUrl = function (segmentGroup, segments, outlet) {
        return segments.length === 0 && !segmentGroup.children[outlet];
    };
    /**
     * @param {?} route
     * @param {?} rawSegment
     * @param {?} segments
     * @param {?} outlet
     * @return {?}
     */
    Recognizer.prototype.processSegmentAgainstRoute = function (route, rawSegment, segments, outlet) {
        if (route.redirectTo)
            throw new NoMatch$1();
        if ((route.outlet || PRIMARY_OUTLET) !== outlet)
            throw new NoMatch$1();
        if (route.path === '**') {
            var /** @type {?} */ params = segments.length > 0 ? ((last$1(segments))).parameters : {};
            var /** @type {?} */ snapshot_1 = new ActivatedRouteSnapshot(segments, params, Object.freeze(this.urlTree.queryParams), /** @type {?} */ ((this.urlTree.fragment)), getData(route), outlet, /** @type {?} */ ((route.component)), route, getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + segments.length, getResolve(route));
            return [new TreeNode(snapshot_1, [])];
        }
        var _a = match$1(rawSegment, route, segments), consumedSegments = _a.consumedSegments, parameters = _a.parameters, lastChild = _a.lastChild;
        var /** @type {?} */ rawSlicedSegments = segments.slice(lastChild);
        var /** @type {?} */ childConfig = getChildConfig(route);
        var _b = split$1(rawSegment, consumedSegments, rawSlicedSegments, childConfig), segmentGroup = _b.segmentGroup, slicedSegments = _b.slicedSegments;
        var /** @type {?} */ snapshot = new ActivatedRouteSnapshot(consumedSegments, parameters, Object.freeze(this.urlTree.queryParams), /** @type {?} */ ((this.urlTree.fragment)), getData(route), outlet, /** @type {?} */ ((route.component)), route, getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + consumedSegments.length, getResolve(route));
        if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {
            var /** @type {?} */ children_3 = this.processChildren(childConfig, segmentGroup);
            return [new TreeNode(snapshot, children_3)];
        }
        if (childConfig.length === 0 && slicedSegments.length === 0) {
            return [new TreeNode(snapshot, [])];
        }
        var /** @type {?} */ children = this.processSegment(childConfig, segmentGroup, slicedSegments, PRIMARY_OUTLET);
        return [new TreeNode(snapshot, children)];
    };
    return Recognizer;
}());
/**
 * @param {?} nodes
 * @return {?}
 */
function sortActivatedRouteSnapshots(nodes) {
    nodes.sort(function (a, b) {
        if (a.value.outlet === PRIMARY_OUTLET)
            return -1;
        if (b.value.outlet === PRIMARY_OUTLET)
            return 1;
        return a.value.outlet.localeCompare(b.value.outlet);
    });
}
/**
 * @param {?} route
 * @return {?}
 */
function getChildConfig(route) {
    if (route.children) {
        return route.children;
    }
    if (route.loadChildren) {
        return ((route._loadedConfig)).routes;
    }
    return [];
}
/**
 * @param {?} segmentGroup
 * @param {?} route
 * @param {?} segments
 * @return {?}
 */
function match$1(segmentGroup, route, segments) {
    if (route.path === '') {
        if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || segments.length > 0)) {
            throw new NoMatch$1();
        }
        return { consumedSegments: [], lastChild: 0, parameters: {} };
    }
    var /** @type {?} */ matcher = route.matcher || defaultUrlMatcher;
    var /** @type {?} */ res = matcher(segments, segmentGroup, route);
    if (!res)
        throw new NoMatch$1();
    var /** @type {?} */ posParams = {};
    forEach(/** @type {?} */ ((res.posParams)), function (v, k) { posParams[k] = v.path; });
    var /** @type {?} */ parameters = res.consumed.length > 0 ? Object.assign({}, posParams, res.consumed[res.consumed.length - 1].parameters) :
        posParams;
    return { consumedSegments: res.consumed, lastChild: res.consumed.length, parameters: parameters };
}
/**
 * @param {?} nodes
 * @return {?}
 */
function checkOutletNameUniqueness(nodes) {
    var /** @type {?} */ names = {};
    nodes.forEach(function (n) {
        var /** @type {?} */ routeWithSameOutletName = names[n.value.outlet];
        if (routeWithSameOutletName) {
            var /** @type {?} */ p = routeWithSameOutletName.url.map(function (s) { return s.toString(); }).join('/');
            var /** @type {?} */ c = n.value.url.map(function (s) { return s.toString(); }).join('/');
            throw new Error("Two segments cannot have the same outlet name: '" + p + "' and '" + c + "'.");
        }
        names[n.value.outlet] = n.value;
    });
}
/**
 * @param {?} segmentGroup
 * @return {?}
 */
function getSourceSegmentGroup(segmentGroup) {
    var /** @type {?} */ s = segmentGroup;
    while (s._sourceSegment) {
        s = s._sourceSegment;
    }
    return s;
}
/**
 * @param {?} segmentGroup
 * @return {?}
 */
function getPathIndexShift(segmentGroup) {
    var /** @type {?} */ s = segmentGroup;
    var /** @type {?} */ res = (s._segmentIndexShift ? s._segmentIndexShift : 0);
    while (s._sourceSegment) {
        s = s._sourceSegment;
        res += (s._segmentIndexShift ? s._segmentIndexShift : 0);
    }
    return res - 1;
}
/**
 * @param {?} segmentGroup
 * @param {?} consumedSegments
 * @param {?} slicedSegments
 * @param {?} config
 * @return {?}
 */
function split$1(segmentGroup, consumedSegments, slicedSegments, config) {
    if (slicedSegments.length > 0 &&
        containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config)) {
        var /** @type {?} */ s_1 = new UrlSegmentGroup(consumedSegments, createChildrenForEmptyPaths(segmentGroup, consumedSegments, config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));
        s_1._sourceSegment = segmentGroup;
        s_1._segmentIndexShift = consumedSegments.length;
        return { segmentGroup: s_1, slicedSegments: [] };
    }
    if (slicedSegments.length === 0 &&
        containsEmptyPathMatches(segmentGroup, slicedSegments, config)) {
        var /** @type {?} */ s_2 = new UrlSegmentGroup(segmentGroup.segments, addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children));
        s_2._sourceSegment = segmentGroup;
        s_2._segmentIndexShift = consumedSegments.length;
        return { segmentGroup: s_2, slicedSegments: slicedSegments };
    }
    var /** @type {?} */ s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);
    s._sourceSegment = segmentGroup;
    s._segmentIndexShift = consumedSegments.length;
    return { segmentGroup: s, slicedSegments: slicedSegments };
}
/**
 * @param {?} segmentGroup
 * @param {?} slicedSegments
 * @param {?} routes
 * @param {?} children
 * @return {?}
 */
function addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, routes, children) {
    var /** @type {?} */ res = {};
    for (var _i = 0, routes_3 = routes; _i < routes_3.length; _i++) {
        var r = routes_3[_i];
        if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet$1(r)]) {
            var /** @type {?} */ s = new UrlSegmentGroup([], {});
            s._sourceSegment = segmentGroup;
            s._segmentIndexShift = segmentGroup.segments.length;
            res[getOutlet$1(r)] = s;
        }
    }
    return Object.assign({}, children, res);
}
/**
 * @param {?} segmentGroup
 * @param {?} consumedSegments
 * @param {?} routes
 * @param {?} primarySegment
 * @return {?}
 */
function createChildrenForEmptyPaths(segmentGroup, consumedSegments, routes, primarySegment) {
    var /** @type {?} */ res = {};
    res[PRIMARY_OUTLET] = primarySegment;
    primarySegment._sourceSegment = segmentGroup;
    primarySegment._segmentIndexShift = consumedSegments.length;
    for (var _i = 0, routes_4 = routes; _i < routes_4.length; _i++) {
        var r = routes_4[_i];
        if (r.path === '' && getOutlet$1(r) !== PRIMARY_OUTLET) {
            var /** @type {?} */ s = new UrlSegmentGroup([], {});
            s._sourceSegment = segmentGroup;
            s._segmentIndexShift = consumedSegments.length;
            res[getOutlet$1(r)] = s;
        }
    }
    return res;
}
/**
 * @param {?} segmentGroup
 * @param {?} slicedSegments
 * @param {?} routes
 * @return {?}
 */
function containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, routes) {
    return routes.some(function (r) { return emptyPathMatch(segmentGroup, slicedSegments, r) && getOutlet$1(r) !== PRIMARY_OUTLET; });
}
/**
 * @param {?} segmentGroup
 * @param {?} slicedSegments
 * @param {?} routes
 * @return {?}
 */
function containsEmptyPathMatches(segmentGroup, slicedSegments, routes) {
    return routes.some(function (r) { return emptyPathMatch(segmentGroup, slicedSegments, r); });
}
/**
 * @param {?} segmentGroup
 * @param {?} slicedSegments
 * @param {?} r
 * @return {?}
 */
function emptyPathMatch(segmentGroup, slicedSegments, r) {
    if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === 'full') {
        return false;
    }
    return r.path === '' && r.redirectTo === undefined;
}
/**
 * @param {?} route
 * @return {?}
 */
function getOutlet$1(route) {
    return route.outlet || PRIMARY_OUTLET;
}
/**
 * @param {?} route
 * @return {?}
 */
function getData(route) {
    return route.data || {};
}
/**
 * @param {?} route
 * @return {?}
 */
function getResolve(route) {
    return route.resolve || {};
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * \@whatItDoes Provides a way to customize when activated routes get reused.
 *
 * \@experimental
 * @abstract
 */
var RouteReuseStrategy = (function () {
    function RouteReuseStrategy() {
    }
    /**
     * Determines if this route (and its subtree) should be detached to be reused later
     * @abstract
     * @param {?} route
     * @return {?}
     */
    RouteReuseStrategy.prototype.shouldDetach = function (route) { };
    /**
     * Stores the detached route.
     *
     * Storing a `null` value should erase the previously stored value.
     * @abstract
     * @param {?} route
     * @param {?} handle
     * @return {?}
     */
    RouteReuseStrategy.prototype.store = function (route, handle) { };
    /**
     * Determines if this route (and its subtree) should be reattached
     * @abstract
     * @param {?} route
     * @return {?}
     */
    RouteReuseStrategy.prototype.shouldAttach = function (route) { };
    /**
     * Retrieves the previously stored route
     * @abstract
     * @param {?} route
     * @return {?}
     */
    RouteReuseStrategy.prototype.retrieve = function (route) { };
    /**
     * Determines if a route should be reused
     * @abstract
     * @param {?} future
     * @param {?} curr
     * @return {?}
     */
    RouteReuseStrategy.prototype.shouldReuseRoute = function (future, curr) { };
    return RouteReuseStrategy;
}());
/**
 * Does not detach any subtrees. Reuses routes as long as their route config is the same.
 */
var DefaultRouteReuseStrategy = (function () {
    function DefaultRouteReuseStrategy() {
    }
    /**
     * @param {?} route
     * @return {?}
     */
    DefaultRouteReuseStrategy.prototype.shouldDetach = function (route) { return false; };
    /**
     * @param {?} route
     * @param {?} detachedTree
     * @return {?}
     */
    DefaultRouteReuseStrategy.prototype.store = function (route, detachedTree) { };
    /**
     * @param {?} route
     * @return {?}
     */
    DefaultRouteReuseStrategy.prototype.shouldAttach = function (route) { return false; };
    /**
     * @param {?} route
     * @return {?}
     */
    DefaultRouteReuseStrategy.prototype.retrieve = function (route) { return null; };
    /**
     * @param {?} future
     * @param {?} curr
     * @return {?}
     */
    DefaultRouteReuseStrategy.prototype.shouldReuseRoute = function (future, curr) {
        return future.routeConfig === curr.routeConfig;
    };
    return DefaultRouteReuseStrategy;
}());
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * \@docsNotRequired
 * \@experimental
 */
var ROUTES = new __WEBPACK_IMPORTED_MODULE_2__angular_core__["InjectionToken"]('ROUTES');
var RouterConfigLoader = (function () {
    /**
     * @param {?} loader
     * @param {?} compiler
     * @param {?=} onLoadStartListener
     * @param {?=} onLoadEndListener
     */
    function RouterConfigLoader(loader, compiler, onLoadStartListener, onLoadEndListener) {
        this.loader = loader;
        this.compiler = compiler;
        this.onLoadStartListener = onLoadStartListener;
        this.onLoadEndListener = onLoadEndListener;
    }
    /**
     * @param {?} parentInjector
     * @param {?} route
     * @return {?}
     */
    RouterConfigLoader.prototype.load = function (parentInjector, route) {
        var _this = this;
        if (this.onLoadStartListener) {
            this.onLoadStartListener(route);
        }
        var /** @type {?} */ moduleFactory$ = this.loadModuleFactory(/** @type {?} */ ((route.loadChildren)));
        return __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(moduleFactory$, function (factory) {
            if (_this.onLoadEndListener) {
                _this.onLoadEndListener(route);
            }
            var /** @type {?} */ module = factory.create(parentInjector);
            return new LoadedRouterConfig(flatten(module.injector.get(ROUTES)), module);
        });
    };
    /**
     * @param {?} loadChildren
     * @return {?}
     */
    RouterConfigLoader.prototype.loadModuleFactory = function (loadChildren) {
        var _this = this;
        if (typeof loadChildren === 'string') {
            return Object(__WEBPACK_IMPORTED_MODULE_18_rxjs_observable_fromPromise__["fromPromise"])(this.loader.load(loadChildren));
        }
        else {
            return __WEBPACK_IMPORTED_MODULE_12_rxjs_operator_mergeMap__["mergeMap"].call(wrapIntoObservable(loadChildren()), function (t) {
                if (t instanceof __WEBPACK_IMPORTED_MODULE_2__angular_core__["NgModuleFactory"]) {
                    return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(t);
                }
                else {
                    return Object(__WEBPACK_IMPORTED_MODULE_18_rxjs_observable_fromPromise__["fromPromise"])(_this.compiler.compileModuleAsync(t));
                }
            });
        }
    };
    return RouterConfigLoader;
}());
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * \@whatItDoes Provides a way to migrate AngularJS applications to Angular.
 *
 * \@experimental
 * @abstract
 */
var UrlHandlingStrategy = (function () {
    function UrlHandlingStrategy() {
    }
    /**
     * Tells the router if this URL should be processed.
     *
     * When it returns true, the router will execute the regular navigation.
     * When it returns false, the router will set the router state to an empty state.
     * As a result, all the active components will be destroyed.
     *
     * @abstract
     * @param {?} url
     * @return {?}
     */
    UrlHandlingStrategy.prototype.shouldProcessUrl = function (url) { };
    /**
     * Extracts the part of the URL that should be handled by the router.
     * The rest of the URL will remain untouched.
     * @abstract
     * @param {?} url
     * @return {?}
     */
    UrlHandlingStrategy.prototype.extract = function (url) { };
    /**
     * Merges the URL fragment with the rest of the URL.
     * @abstract
     * @param {?} newUrlPart
     * @param {?} rawUrl
     * @return {?}
     */
    UrlHandlingStrategy.prototype.merge = function (newUrlPart, rawUrl) { };
    return UrlHandlingStrategy;
}());
/**
 * \@experimental
 */
var DefaultUrlHandlingStrategy = (function () {
    function DefaultUrlHandlingStrategy() {
    }
    /**
     * @param {?} url
     * @return {?}
     */
    DefaultUrlHandlingStrategy.prototype.shouldProcessUrl = function (url) { return true; };
    /**
     * @param {?} url
     * @return {?}
     */
    DefaultUrlHandlingStrategy.prototype.extract = function (url) { return url; };
    /**
     * @param {?} newUrlPart
     * @param {?} wholeUrl
     * @return {?}
     */
    DefaultUrlHandlingStrategy.prototype.merge = function (newUrlPart, wholeUrl) { return newUrlPart; };
    return DefaultUrlHandlingStrategy;
}());
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @param {?} error
 * @return {?}
 */
function defaultErrorHandler(error) {
    throw error;
}
/**
 * \@internal
 * @param {?} snapshot
 * @return {?}
 */
function defaultRouterHook(snapshot) {
    return (Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(null));
}
/**
 * \@whatItDoes Provides the navigation and url manipulation capabilities.
 *
 * See {\@link Routes} for more details and examples.
 *
 * \@ngModule RouterModule
 *
 * \@stable
 */
var Router = (function () {
    /**
     * @param {?} rootComponentType
     * @param {?} urlSerializer
     * @param {?} rootContexts
     * @param {?} location
     * @param {?} injector
     * @param {?} loader
     * @param {?} compiler
     * @param {?} config
     */
    function Router(rootComponentType, urlSerializer, rootContexts, location, injector, loader, compiler, config) {
        var _this = this;
        this.rootComponentType = rootComponentType;
        this.urlSerializer = urlSerializer;
        this.rootContexts = rootContexts;
        this.location = location;
        this.config = config;
        this.navigations = new __WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject__["BehaviorSubject"](/** @type {?} */ ((null)));
        this.routerEvents = new __WEBPACK_IMPORTED_MODULE_4_rxjs_Subject__["Subject"]();
        this.navigationId = 0;
        /**
         * Error handler that is invoked when a navigation errors.
         *
         * See {\@link ErrorHandler} for more information.
         */
        this.errorHandler = defaultErrorHandler;
        /**
         * Indicates if at least one navigation happened.
         */
        this.navigated = false;
        /**
         * Used by RouterModule. This allows us to
         * pause the navigation either before preactivation or after it.
         * \@internal
         */
        this.hooks = {
            beforePreactivation: defaultRouterHook,
            afterPreactivation: defaultRouterHook
        };
        /**
         * Extracts and merges URLs. Used for AngularJS to Angular migrations.
         */
        this.urlHandlingStrategy = new DefaultUrlHandlingStrategy();
        this.routeReuseStrategy = new DefaultRouteReuseStrategy();
        var onLoadStart = function (r) { return _this.triggerEvent(new RouteConfigLoadStart(r)); };
        var onLoadEnd = function (r) { return _this.triggerEvent(new RouteConfigLoadEnd(r)); };
        this.ngModule = injector.get(__WEBPACK_IMPORTED_MODULE_2__angular_core__["NgModuleRef"]);
        this.resetConfig(config);
        this.currentUrlTree = createEmptyUrlTree();
        this.rawUrlTree = this.currentUrlTree;
        this.configLoader = new RouterConfigLoader(loader, compiler, onLoadStart, onLoadEnd);
        this.currentRouterState = createEmptyState(this.currentUrlTree, this.rootComponentType);
        this.processNavigations();
    }
    /**
     * \@internal
     * TODO: this should be removed once the constructor of the router made internal
     * @param {?} rootComponentType
     * @return {?}
     */
    Router.prototype.resetRootComponentType = function (rootComponentType) {
        this.rootComponentType = rootComponentType;
        // TODO: vsavkin router 4.0 should make the root component set to null
        // this will simplify the lifecycle of the router.
        this.currentRouterState.root.component = this.rootComponentType;
    };
    /**
     * Sets up the location change listener and performs the initial navigation.
     * @return {?}
     */
    Router.prototype.initialNavigation = function () {
        this.setUpLocationChangeListener();
        if (this.navigationId === 0) {
            this.navigateByUrl(this.location.path(true), { replaceUrl: true });
        }
    };
    /**
     * Sets up the location change listener.
     * @return {?}
     */
    Router.prototype.setUpLocationChangeListener = function () {
        var _this = this;
        // Zone.current.wrap is needed because of the issue with RxJS scheduler,
        // which does not work properly with zone.js in IE and Safari
        if (!this.locationSubscription) {
            this.locationSubscription = (this.location.subscribe(Zone.current.wrap(function (change) {
                var /** @type {?} */ rawUrlTree = _this.urlSerializer.parse(change['url']);
                var /** @type {?} */ source = change['type'] === 'popstate' ? 'popstate' : 'hashchange';
                setTimeout(function () { _this.scheduleNavigation(rawUrlTree, source, { replaceUrl: true }); }, 0);
            })));
        }
    };
    Object.defineProperty(Router.prototype, "routerState", {
        /**
         * The current route state
         * @return {?}
         */
        get: function () { return this.currentRouterState; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Router.prototype, "url", {
        /**
         * The current url
         * @return {?}
         */
        get: function () { return this.serializeUrl(this.currentUrlTree); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Router.prototype, "events", {
        /**
         * An observable of router events
         * @return {?}
         */
        get: function () { return this.routerEvents; },
        enumerable: true,
        configurable: true
    });
    /**
     * \@internal
     * @param {?} e
     * @return {?}
     */
    Router.prototype.triggerEvent = function (e) { this.routerEvents.next(e); };
    /**
     * Resets the configuration used for navigation and generating links.
     *
     * ### Usage
     *
     * ```
     * router.resetConfig([
     *  { path: 'team/:id', component: TeamCmp, children: [
     *    { path: 'simple', component: SimpleCmp },
     *    { path: 'user/:name', component: UserCmp }
     *  ]}
     * ]);
     * ```
     * @param {?} config
     * @return {?}
     */
    Router.prototype.resetConfig = function (config) {
        validateConfig(config);
        this.config = config;
        this.navigated = false;
    };
    /**
     * \@docsNotRequired
     * @return {?}
     */
    Router.prototype.ngOnDestroy = function () { this.dispose(); };
    /**
     * Disposes of the router
     * @return {?}
     */
    Router.prototype.dispose = function () {
        if (this.locationSubscription) {
            this.locationSubscription.unsubscribe();
            this.locationSubscription = ((null));
        }
    };
    /**
     * Applies an array of commands to the current url tree and creates a new url tree.
     *
     * When given an activate route, applies the given commands starting from the route.
     * When not given a route, applies the given command starting from the root.
     *
     * ### Usage
     *
     * ```
     * // create /team/33/user/11
     * router.createUrlTree(['/team', 33, 'user', 11]);
     *
     * // create /team/33;expand=true/user/11
     * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);
     *
     * // you can collapse static segments like this (this works only with the first passed-in value):
     * router.createUrlTree(['/team/33/user', userId]);
     *
     * // If the first segment can contain slashes, and you do not want the router to split it, you
     * // can do the following:
     *
     * router.createUrlTree([{segmentPath: '/one/two'}]);
     *
     * // create /team/33/(user/11//right:chat)
     * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);
     *
     * // remove the right secondary node
     * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);
     *
     * // assuming the current url is `/team/33/user/11` and the route points to `user/11`
     *
     * // navigate to /team/33/user/11/details
     * router.createUrlTree(['details'], {relativeTo: route});
     *
     * // navigate to /team/33/user/22
     * router.createUrlTree(['../22'], {relativeTo: route});
     *
     * // navigate to /team/44/user/22
     * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});
     * ```
     * @param {?} commands
     * @param {?=} navigationExtras
     * @return {?}
     */
    Router.prototype.createUrlTree = function (commands, navigationExtras) {
        if (navigationExtras === void 0) { navigationExtras = {}; }
        var relativeTo = navigationExtras.relativeTo, queryParams = navigationExtras.queryParams, fragment = navigationExtras.fragment, preserveQueryParams = navigationExtras.preserveQueryParams, queryParamsHandling = navigationExtras.queryParamsHandling, preserveFragment = navigationExtras.preserveFragment;
        if (Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["isDevMode"])() && preserveQueryParams && (console) && (console.warn)) {
            console.warn('preserveQueryParams is deprecated, use queryParamsHandling instead.');
        }
        var /** @type {?} */ a = relativeTo || this.routerState.root;
        var /** @type {?} */ f = preserveFragment ? this.currentUrlTree.fragment : fragment;
        var /** @type {?} */ q = null;
        if (queryParamsHandling) {
            switch (queryParamsHandling) {
                case 'merge':
                    q = Object.assign({}, this.currentUrlTree.queryParams, queryParams);
                    break;
                case 'preserve':
                    q = this.currentUrlTree.queryParams;
                    break;
                default:
                    q = queryParams || null;
            }
        }
        else {
            q = preserveQueryParams ? this.currentUrlTree.queryParams : queryParams || null;
        }
        return createUrlTree(a, this.currentUrlTree, commands, /** @type {?} */ ((q)), /** @type {?} */ ((f)));
    };
    /**
     * Navigate based on the provided url. This navigation is always absolute.
     *
     * Returns a promise that:
     * - resolves to 'true' when navigation succeeds,
     * - resolves to 'false' when navigation fails,
     * - is rejected when an error happens.
     *
     * ### Usage
     *
     * ```
     * router.navigateByUrl("/team/33/user/11");
     *
     * // Navigate without updating the URL
     * router.navigateByUrl("/team/33/user/11", { skipLocationChange: true });
     * ```
     *
     * In opposite to `navigate`, `navigateByUrl` takes a whole URL
     * and does not apply any delta to the current one.
     * @param {?} url
     * @param {?=} extras
     * @return {?}
     */
    Router.prototype.navigateByUrl = function (url, extras) {
        if (extras === void 0) { extras = { skipLocationChange: false }; }
        var /** @type {?} */ urlTree = url instanceof UrlTree ? url : this.parseUrl(url);
        var /** @type {?} */ mergedTree = this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree);
        return this.scheduleNavigation(mergedTree, 'imperative', extras);
    };
    /**
     * Navigate based on the provided array of commands and a starting point.
     * If no starting route is provided, the navigation is absolute.
     *
     * Returns a promise that:
     * - resolves to 'true' when navigation succeeds,
     * - resolves to 'false' when navigation fails,
     * - is rejected when an error happens.
     *
     * ### Usage
     *
     * ```
     * router.navigate(['team', 33, 'user', 11], {relativeTo: route});
     *
     * // Navigate without updating the URL
     * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});
     * ```
     *
     * In opposite to `navigateByUrl`, `navigate` always takes a delta that is applied to the current
     * URL.
     * @param {?} commands
     * @param {?=} extras
     * @return {?}
     */
    Router.prototype.navigate = function (commands, extras) {
        if (extras === void 0) { extras = { skipLocationChange: false }; }
        validateCommands(commands);
        if (typeof extras.queryParams === 'object' && extras.queryParams !== null) {
            extras.queryParams = this.removeEmptyProps(extras.queryParams);
        }
        return this.navigateByUrl(this.createUrlTree(commands, extras), extras);
    };
    /**
     * Serializes a {\@link UrlTree} into a string
     * @param {?} url
     * @return {?}
     */
    Router.prototype.serializeUrl = function (url) { return this.urlSerializer.serialize(url); };
    /**
     * Parses a string into a {\@link UrlTree}
     * @param {?} url
     * @return {?}
     */
    Router.prototype.parseUrl = function (url) { return this.urlSerializer.parse(url); };
    /**
     * Returns whether the url is activated
     * @param {?} url
     * @param {?} exact
     * @return {?}
     */
    Router.prototype.isActive = function (url, exact) {
        if (url instanceof UrlTree) {
            return containsTree(this.currentUrlTree, url, exact);
        }
        var /** @type {?} */ urlTree = this.urlSerializer.parse(url);
        return containsTree(this.currentUrlTree, urlTree, exact);
    };
    /**
     * @param {?} params
     * @return {?}
     */
    Router.prototype.removeEmptyProps = function (params) {
        return Object.keys(params).reduce(function (result, key) {
            var /** @type {?} */ value = params[key];
            if (value !== null && value !== undefined) {
                result[key] = value;
            }
            return result;
        }, {});
    };
    /**
     * @return {?}
     */
    Router.prototype.processNavigations = function () {
        var _this = this;
        __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_concatMap__["concatMap"]
            .call(this.navigations, function (nav) {
            if (nav) {
                _this.executeScheduledNavigation(nav);
                // a failed navigation should not stop the router from processing
                // further navigations => the catch
                return nav.promise.catch(function () { });
            }
            else {
                return (Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(null));
            }
        })
            .subscribe(function () { });
    };
    /**
     * @param {?} rawUrl
     * @param {?} source
     * @param {?} extras
     * @return {?}
     */
    Router.prototype.scheduleNavigation = function (rawUrl, source, extras) {
        var /** @type {?} */ lastNavigation = this.navigations.value;
        // If the user triggers a navigation imperatively (e.g., by using navigateByUrl),
        // and that navigation results in 'replaceState' that leads to the same URL,
        // we should skip those.
        if (lastNavigation && source !== 'imperative' && lastNavigation.source === 'imperative' &&
            lastNavigation.rawUrl.toString() === rawUrl.toString()) {
            return Promise.resolve(true); // return value is not used
        }
        // Because of a bug in IE and Edge, the location class fires two events (popstate and
        // hashchange) every single time. The second one should be ignored. Otherwise, the URL will
        // flicker.
        if (lastNavigation && source == 'hashchange' && lastNavigation.source === 'popstate' &&
            lastNavigation.rawUrl.toString() === rawUrl.toString()) {
            return Promise.resolve(true); // return value is not used
        }
        var /** @type {?} */ resolve = null;
        var /** @type {?} */ reject = null;
        var /** @type {?} */ promise = new Promise(function (res, rej) {
            resolve = res;
            reject = rej;
        });
        var /** @type {?} */ id = ++this.navigationId;
        this.navigations.next({ id: id, source: source, rawUrl: rawUrl, extras: extras, resolve: resolve, reject: reject, promise: promise });
        // Make sure that the error is propagated even though `processNavigations` catch
        // handler does not rethrow
        return promise.catch(function (e) { return Promise.reject(e); });
    };
    /**
     * @param {?} __0
     * @return {?}
     */
    Router.prototype.executeScheduledNavigation = function (_a) {
        var _this = this;
        var id = _a.id, rawUrl = _a.rawUrl, extras = _a.extras, resolve = _a.resolve, reject = _a.reject;
        var /** @type {?} */ url = this.urlHandlingStrategy.extract(rawUrl);
        var /** @type {?} */ urlTransition = !this.navigated || url.toString() !== this.currentUrlTree.toString();
        if (urlTransition && this.urlHandlingStrategy.shouldProcessUrl(rawUrl)) {
            this.routerEvents.next(new NavigationStart(id, this.serializeUrl(url)));
            Promise.resolve()
                .then(function (_) { return _this.runNavigate(url, rawUrl, !!extras.skipLocationChange, !!extras.replaceUrl, id, null); })
                .then(resolve, reject);
            // we cannot process the current URL, but we could process the previous one =>
            // we need to do some cleanup
        }
        else if (urlTransition && this.rawUrlTree &&
            this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)) {
            this.routerEvents.next(new NavigationStart(id, this.serializeUrl(url)));
            Promise.resolve()
                .then(function (_) { return _this.runNavigate(url, rawUrl, false, false, id, createEmptyState(url, _this.rootComponentType).snapshot); })
                .then(resolve, reject);
        }
        else {
            this.rawUrlTree = rawUrl;
            resolve(null);
        }
    };
    /**
     * @param {?} url
     * @param {?} rawUrl
     * @param {?} shouldPreventPushState
     * @param {?} shouldReplaceUrl
     * @param {?} id
     * @param {?} precreatedState
     * @return {?}
     */
    Router.prototype.runNavigate = function (url, rawUrl, shouldPreventPushState, shouldReplaceUrl, id, precreatedState) {
        var _this = this;
        if (id !== this.navigationId) {
            this.location.go(this.urlSerializer.serialize(this.currentUrlTree));
            this.routerEvents.next(new NavigationCancel(id, this.serializeUrl(url), "Navigation ID " + id + " is not equal to the current navigation id " + this.navigationId));
            return Promise.resolve(false);
        }
        return new Promise(function (resolvePromise, rejectPromise) {
            // create an observable of the url and route state snapshot
            // this operation do not result in any side effects
            var /** @type {?} */ urlAndSnapshot$;
            if (!precreatedState) {
                var /** @type {?} */ moduleInjector = _this.ngModule.injector;
                var /** @type {?} */ redirectsApplied$ = applyRedirects(moduleInjector, _this.configLoader, _this.urlSerializer, url, _this.config);
                urlAndSnapshot$ = __WEBPACK_IMPORTED_MODULE_12_rxjs_operator_mergeMap__["mergeMap"].call(redirectsApplied$, function (appliedUrl) {
                    return __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(recognize(_this.rootComponentType, _this.config, appliedUrl, _this.serializeUrl(appliedUrl)), function (snapshot) {
                        _this.routerEvents.next(new RoutesRecognized(id, _this.serializeUrl(url), _this.serializeUrl(appliedUrl), snapshot));
                        return { appliedUrl: appliedUrl, snapshot: snapshot };
                    });
                });
            }
            else {
                urlAndSnapshot$ = Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])({ appliedUrl: url, snapshot: precreatedState });
            }
            var /** @type {?} */ beforePreactivationDone$ = __WEBPACK_IMPORTED_MODULE_12_rxjs_operator_mergeMap__["mergeMap"].call(urlAndSnapshot$, function (p) {
                return __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(_this.hooks.beforePreactivation(p.snapshot), function () { return p; });
            });
            // run preactivation: guards and data resolvers
            var /** @type {?} */ preActivation;
            var /** @type {?} */ preactivationTraverse$ = __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(beforePreactivationDone$, function (_a) {
                var appliedUrl = _a.appliedUrl, snapshot = _a.snapshot;
                var /** @type {?} */ moduleInjector = _this.ngModule.injector;
                preActivation =
                    new PreActivation(snapshot, _this.currentRouterState.snapshot, moduleInjector);
                preActivation.traverse(_this.rootContexts);
                return { appliedUrl: appliedUrl, snapshot: snapshot };
            });
            var /** @type {?} */ preactivationCheckGuards$ = __WEBPACK_IMPORTED_MODULE_12_rxjs_operator_mergeMap__["mergeMap"].call(preactivationTraverse$, function (_a) {
                var appliedUrl = _a.appliedUrl, snapshot = _a.snapshot;
                if (_this.navigationId !== id)
                    return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(false);
                _this.triggerEvent(new GuardsCheckStart(id, _this.serializeUrl(url), appliedUrl, snapshot));
                return __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(preActivation.checkGuards(), function (shouldActivate) {
                    _this.triggerEvent(new GuardsCheckEnd(id, _this.serializeUrl(url), appliedUrl, snapshot, shouldActivate));
                    return { appliedUrl: appliedUrl, snapshot: snapshot, shouldActivate: shouldActivate };
                });
            });
            var /** @type {?} */ preactivationResolveData$ = __WEBPACK_IMPORTED_MODULE_12_rxjs_operator_mergeMap__["mergeMap"].call(preactivationCheckGuards$, function (p) {
                if (_this.navigationId !== id)
                    return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(false);
                if (p.shouldActivate && preActivation.isActivating()) {
                    _this.triggerEvent(new ResolveStart(id, _this.serializeUrl(url), p.appliedUrl, p.snapshot));
                    return __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(preActivation.resolveData(), function () {
                        _this.triggerEvent(new ResolveEnd(id, _this.serializeUrl(url), p.appliedUrl, p.snapshot));
                        return p;
                    });
                }
                else {
                    return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(p);
                }
            });
            var /** @type {?} */ preactivationDone$ = __WEBPACK_IMPORTED_MODULE_12_rxjs_operator_mergeMap__["mergeMap"].call(preactivationResolveData$, function (p) {
                return __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(_this.hooks.afterPreactivation(p.snapshot), function () { return p; });
            });
            // create router state
            // this operation has side effects => route state is being affected
            var /** @type {?} */ routerState$ = __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(preactivationDone$, function (_a) {
                var appliedUrl = _a.appliedUrl, snapshot = _a.snapshot, shouldActivate = _a.shouldActivate;
                if (shouldActivate) {
                    var /** @type {?} */ state = createRouterState(_this.routeReuseStrategy, snapshot, _this.currentRouterState);
                    return { appliedUrl: appliedUrl, state: state, shouldActivate: shouldActivate };
                }
                else {
                    return { appliedUrl: appliedUrl, state: null, shouldActivate: shouldActivate };
                }
            });
            // applied the new router state
            // this operation has side effects
            var /** @type {?} */ navigationIsSuccessful;
            var /** @type {?} */ storedState = _this.currentRouterState;
            var /** @type {?} */ storedUrl = _this.currentUrlTree;
            routerState$
                .forEach(function (_a) {
                var appliedUrl = _a.appliedUrl, state = _a.state, shouldActivate = _a.shouldActivate;
                if (!shouldActivate || id !== _this.navigationId) {
                    navigationIsSuccessful = false;
                    return;
                }
                _this.currentUrlTree = appliedUrl;
                _this.rawUrlTree = _this.urlHandlingStrategy.merge(_this.currentUrlTree, rawUrl);
                _this.currentRouterState = state;
                if (!shouldPreventPushState) {
                    var /** @type {?} */ path = _this.urlSerializer.serialize(_this.rawUrlTree);
                    if (_this.location.isCurrentPathEqualTo(path) || shouldReplaceUrl) {
                        _this.location.replaceState(path);
                    }
                    else {
                        _this.location.go(path);
                    }
                }
                new ActivateRoutes(_this.routeReuseStrategy, state, storedState)
                    .activate(_this.rootContexts);
                navigationIsSuccessful = true;
            })
                .then(function () {
                if (navigationIsSuccessful) {
                    _this.navigated = true;
                    _this.routerEvents.next(new NavigationEnd(id, _this.serializeUrl(url), _this.serializeUrl(_this.currentUrlTree)));
                    resolvePromise(true);
                }
                else {
                    _this.resetUrlToCurrentUrlTree();
                    _this.routerEvents.next(new NavigationCancel(id, _this.serializeUrl(url), ''));
                    resolvePromise(false);
                }
            }, function (e) {
                if (isNavigationCancelingError(e)) {
                    _this.resetUrlToCurrentUrlTree();
                    _this.navigated = true;
                    _this.routerEvents.next(new NavigationCancel(id, _this.serializeUrl(url), e.message));
                    resolvePromise(false);
                }
                else {
                    _this.routerEvents.next(new NavigationError(id, _this.serializeUrl(url), e));
                    try {
                        resolvePromise(_this.errorHandler(e));
                    }
                    catch (ee) {
                        rejectPromise(ee);
                    }
                }
                _this.currentRouterState = storedState;
                _this.currentUrlTree = storedUrl;
                _this.rawUrlTree = _this.urlHandlingStrategy.merge(_this.currentUrlTree, rawUrl);
                _this.location.replaceState(_this.serializeUrl(_this.rawUrlTree));
            });
        });
    };
    /**
     * @return {?}
     */
    Router.prototype.resetUrlToCurrentUrlTree = function () {
        var /** @type {?} */ path = this.urlSerializer.serialize(this.rawUrlTree);
        this.location.replaceState(path);
    };
    return Router;
}());
var CanActivate = (function () {
    /**
     * @param {?} path
     */
    function CanActivate(path) {
        this.path = path;
    }
    Object.defineProperty(CanActivate.prototype, "route", {
        /**
         * @return {?}
         */
        get: function () { return this.path[this.path.length - 1]; },
        enumerable: true,
        configurable: true
    });
    return CanActivate;
}());
var CanDeactivate = (function () {
    /**
     * @param {?} component
     * @param {?} route
     */
    function CanDeactivate(component, route) {
        this.component = component;
        this.route = route;
    }
    return CanDeactivate;
}());
var PreActivation = (function () {
    /**
     * @param {?} future
     * @param {?} curr
     * @param {?} moduleInjector
     */
    function PreActivation(future, curr, moduleInjector) {
        this.future = future;
        this.curr = curr;
        this.moduleInjector = moduleInjector;
        this.canActivateChecks = [];
        this.canDeactivateChecks = [];
    }
    /**
     * @param {?} parentContexts
     * @return {?}
     */
    PreActivation.prototype.traverse = function (parentContexts) {
        var /** @type {?} */ futureRoot = this.future._root;
        var /** @type {?} */ currRoot = this.curr ? this.curr._root : null;
        this.traverseChildRoutes(futureRoot, currRoot, parentContexts, [futureRoot.value]);
    };
    /**
     * @return {?}
     */
    PreActivation.prototype.checkGuards = function () {
        var _this = this;
        if (!this.isDeactivating() && !this.isActivating()) {
            return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(true);
        }
        var /** @type {?} */ canDeactivate$ = this.runCanDeactivateChecks();
        return __WEBPACK_IMPORTED_MODULE_12_rxjs_operator_mergeMap__["mergeMap"].call(canDeactivate$, function (canDeactivate) { return canDeactivate ? _this.runCanActivateChecks() : Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(false); });
    };
    /**
     * @return {?}
     */
    PreActivation.prototype.resolveData = function () {
        var _this = this;
        if (!this.isActivating())
            return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(null);
        var /** @type {?} */ checks$ = Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_from__["from"])(this.canActivateChecks);
        var /** @type {?} */ runningChecks$ = __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_concatMap__["concatMap"].call(checks$, function (check) { return _this.runResolve(check.route); });
        return __WEBPACK_IMPORTED_MODULE_13_rxjs_operator_reduce__["reduce"].call(runningChecks$, function (_, __) { return _; });
    };
    /**
     * @return {?}
     */
    PreActivation.prototype.isDeactivating = function () { return this.canDeactivateChecks.length !== 0; };
    /**
     * @return {?}
     */
    PreActivation.prototype.isActivating = function () { return this.canActivateChecks.length !== 0; };
    /**
     * @param {?} futureNode
     * @param {?} currNode
     * @param {?} contexts
     * @param {?} futurePath
     * @return {?}
     */
    PreActivation.prototype.traverseChildRoutes = function (futureNode, currNode, contexts, futurePath) {
        var _this = this;
        var /** @type {?} */ prevChildren = nodeChildrenAsMap(currNode);
        // Process the children of the future route
        futureNode.children.forEach(function (c) {
            _this.traverseRoutes(c, prevChildren[c.value.outlet], contexts, futurePath.concat([c.value]));
            delete prevChildren[c.value.outlet];
        });
        // Process any children left from the current route (not active for the future route)
        forEach(prevChildren, function (v, k) { return _this.deactivateRouteAndItsChildren(v, /** @type {?} */ ((contexts)).getContext(k)); });
    };
    /**
     * @param {?} futureNode
     * @param {?} currNode
     * @param {?} parentContexts
     * @param {?} futurePath
     * @return {?}
     */
    PreActivation.prototype.traverseRoutes = function (futureNode, currNode, parentContexts, futurePath) {
        var /** @type {?} */ future = futureNode.value;
        var /** @type {?} */ curr = currNode ? currNode.value : null;
        var /** @type {?} */ context = parentContexts ? parentContexts.getContext(futureNode.value.outlet) : null;
        // reusing the node
        if (curr && future._routeConfig === curr._routeConfig) {
            var /** @type {?} */ shouldRunGuardsAndResolvers = this.shouldRunGuardsAndResolvers(curr, future, /** @type {?} */ ((future._routeConfig)).runGuardsAndResolvers);
            if (shouldRunGuardsAndResolvers) {
                this.canActivateChecks.push(new CanActivate(futurePath));
            }
            else {
                // we need to set the data
                future.data = curr.data;
                future._resolvedData = curr._resolvedData;
            }
            // If we have a component, we need to go through an outlet.
            if (future.component) {
                this.traverseChildRoutes(futureNode, currNode, context ? context.children : null, futurePath);
                // if we have a componentless route, we recurse but keep the same outlet map.
            }
            else {
                this.traverseChildRoutes(futureNode, currNode, parentContexts, futurePath);
            }
            if (shouldRunGuardsAndResolvers) {
                var /** @type {?} */ outlet = ((((context)).outlet));
                this.canDeactivateChecks.push(new CanDeactivate(outlet.component, curr));
            }
        }
        else {
            if (curr) {
                this.deactivateRouteAndItsChildren(currNode, context);
            }
            this.canActivateChecks.push(new CanActivate(futurePath));
            // If we have a component, we need to go through an outlet.
            if (future.component) {
                this.traverseChildRoutes(futureNode, null, context ? context.children : null, futurePath);
                // if we have a componentless route, we recurse but keep the same outlet map.
            }
            else {
                this.traverseChildRoutes(futureNode, null, parentContexts, futurePath);
            }
        }
    };
    /**
     * @param {?} curr
     * @param {?} future
     * @param {?} mode
     * @return {?}
     */
    PreActivation.prototype.shouldRunGuardsAndResolvers = function (curr, future, mode) {
        switch (mode) {
            case 'always':
                return true;
            case 'paramsOrQueryParamsChange':
                return !equalParamsAndUrlSegments(curr, future) ||
                    !shallowEqual(curr.queryParams, future.queryParams);
            case 'paramsChange':
            default:
                return !equalParamsAndUrlSegments(curr, future);
        }
    };
    /**
     * @param {?} route
     * @param {?} context
     * @return {?}
     */
    PreActivation.prototype.deactivateRouteAndItsChildren = function (route, context) {
        var _this = this;
        var /** @type {?} */ children = nodeChildrenAsMap(route);
        var /** @type {?} */ r = route.value;
        forEach(children, function (node, childName) {
            if (!r.component) {
                _this.deactivateRouteAndItsChildren(node, context);
            }
            else if (context) {
                _this.deactivateRouteAndItsChildren(node, context.children.getContext(childName));
            }
            else {
                _this.deactivateRouteAndItsChildren(node, null);
            }
        });
        if (!r.component) {
            this.canDeactivateChecks.push(new CanDeactivate(null, r));
        }
        else if (context && context.outlet && context.outlet.isActivated) {
            this.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, r));
        }
        else {
            this.canDeactivateChecks.push(new CanDeactivate(null, r));
        }
    };
    /**
     * @return {?}
     */
    PreActivation.prototype.runCanDeactivateChecks = function () {
        var _this = this;
        var /** @type {?} */ checks$ = Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_from__["from"])(this.canDeactivateChecks);
        var /** @type {?} */ runningChecks$ = __WEBPACK_IMPORTED_MODULE_12_rxjs_operator_mergeMap__["mergeMap"].call(checks$, function (check) { return _this.runCanDeactivate(check.component, check.route); });
        return __WEBPACK_IMPORTED_MODULE_8_rxjs_operator_every__["every"].call(runningChecks$, function (result) { return result === true; });
    };
    /**
     * @return {?}
     */
    PreActivation.prototype.runCanActivateChecks = function () {
        var _this = this;
        var /** @type {?} */ checks$ = Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_from__["from"])(this.canActivateChecks);
        var /** @type {?} */ runningChecks$ = __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_concatMap__["concatMap"].call(checks$, function (check) { return andObservables(Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_from__["from"])([_this.runCanActivateChild(check.path), _this.runCanActivate(check.route)])); });
        return __WEBPACK_IMPORTED_MODULE_8_rxjs_operator_every__["every"].call(runningChecks$, function (result) { return result === true; });
    };
    /**
     * @param {?} future
     * @return {?}
     */
    PreActivation.prototype.runCanActivate = function (future) {
        var _this = this;
        var /** @type {?} */ canActivate = future._routeConfig ? future._routeConfig.canActivate : null;
        if (!canActivate || canActivate.length === 0)
            return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(true);
        var /** @type {?} */ obs = __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_from__["from"])(canActivate), function (c) {
            var /** @type {?} */ guard = _this.getToken(c, future);
            var /** @type {?} */ observable;
            if (guard.canActivate) {
                observable = wrapIntoObservable(guard.canActivate(future, _this.future));
            }
            else {
                observable = wrapIntoObservable(guard(future, _this.future));
            }
            return __WEBPACK_IMPORTED_MODULE_9_rxjs_operator_first__["first"].call(observable);
        });
        return andObservables(obs);
    };
    /**
     * @param {?} path
     * @return {?}
     */
    PreActivation.prototype.runCanActivateChild = function (path) {
        var _this = this;
        var /** @type {?} */ future = path[path.length - 1];
        var /** @type {?} */ canActivateChildGuards = path.slice(0, path.length - 1)
            .reverse()
            .map(function (p) { return _this.extractCanActivateChild(p); })
            .filter(function (_) { return _ !== null; });
        return andObservables(__WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_from__["from"])(canActivateChildGuards), function (d) {
            var /** @type {?} */ obs = __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_from__["from"])(d.guards), function (c) {
                var /** @type {?} */ guard = _this.getToken(c, d.node);
                var /** @type {?} */ observable;
                if (guard.canActivateChild) {
                    observable = wrapIntoObservable(guard.canActivateChild(future, _this.future));
                }
                else {
                    observable = wrapIntoObservable(guard(future, _this.future));
                }
                return __WEBPACK_IMPORTED_MODULE_9_rxjs_operator_first__["first"].call(observable);
            });
            return andObservables(obs);
        }));
    };
    /**
     * @param {?} p
     * @return {?}
     */
    PreActivation.prototype.extractCanActivateChild = function (p) {
        var /** @type {?} */ canActivateChild = p._routeConfig ? p._routeConfig.canActivateChild : null;
        if (!canActivateChild || canActivateChild.length === 0)
            return null;
        return { node: p, guards: canActivateChild };
    };
    /**
     * @param {?} component
     * @param {?} curr
     * @return {?}
     */
    PreActivation.prototype.runCanDeactivate = function (component, curr) {
        var _this = this;
        var /** @type {?} */ canDeactivate = curr && curr._routeConfig ? curr._routeConfig.canDeactivate : null;
        if (!canDeactivate || canDeactivate.length === 0)
            return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(true);
        var /** @type {?} */ canDeactivate$ = __WEBPACK_IMPORTED_MODULE_12_rxjs_operator_mergeMap__["mergeMap"].call(Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_from__["from"])(canDeactivate), function (c) {
            var /** @type {?} */ guard = _this.getToken(c, curr);
            var /** @type {?} */ observable;
            if (guard.canDeactivate) {
                observable =
                    wrapIntoObservable(guard.canDeactivate(component, curr, _this.curr, _this.future));
            }
            else {
                observable = wrapIntoObservable(guard(component, curr, _this.curr, _this.future));
            }
            return __WEBPACK_IMPORTED_MODULE_9_rxjs_operator_first__["first"].call(observable);
        });
        return __WEBPACK_IMPORTED_MODULE_8_rxjs_operator_every__["every"].call(canDeactivate$, function (result) { return result === true; });
    };
    /**
     * @param {?} future
     * @return {?}
     */
    PreActivation.prototype.runResolve = function (future) {
        var /** @type {?} */ resolve = future._resolve;
        return __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(this.resolveNode(resolve, future), function (resolvedData) {
            future._resolvedData = resolvedData;
            future.data = Object.assign({}, future.data, inheritedParamsDataResolve(future).resolve);
            return null;
        });
    };
    /**
     * @param {?} resolve
     * @param {?} future
     * @return {?}
     */
    PreActivation.prototype.resolveNode = function (resolve, future) {
        var _this = this;
        var /** @type {?} */ keys = Object.keys(resolve);
        if (keys.length === 0) {
            return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])({});
        }
        if (keys.length === 1) {
            var /** @type {?} */ key_1 = keys[0];
            return __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(this.getResolver(resolve[key_1], future), function (value) {
                return _a = {}, _a[key_1] = value, _a;
                var _a;
            });
        }
        var /** @type {?} */ data = {};
        var /** @type {?} */ runningResolvers$ = __WEBPACK_IMPORTED_MODULE_12_rxjs_operator_mergeMap__["mergeMap"].call(Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_from__["from"])(keys), function (key) {
            return __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(_this.getResolver(resolve[key], future), function (value) {
                data[key] = value;
                return value;
            });
        });
        return __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(__WEBPACK_IMPORTED_MODULE_10_rxjs_operator_last__["last"].call(runningResolvers$), function () { return data; });
    };
    /**
     * @param {?} injectionToken
     * @param {?} future
     * @return {?}
     */
    PreActivation.prototype.getResolver = function (injectionToken, future) {
        var /** @type {?} */ resolver = this.getToken(injectionToken, future);
        return resolver.resolve ? wrapIntoObservable(resolver.resolve(future, this.future)) :
            wrapIntoObservable(resolver(future, this.future));
    };
    /**
     * @param {?} token
     * @param {?} snapshot
     * @return {?}
     */
    PreActivation.prototype.getToken = function (token, snapshot) {
        var /** @type {?} */ config = closestLoadedConfig(snapshot);
        var /** @type {?} */ injector = config ? config.module.injector : this.moduleInjector;
        return injector.get(token);
    };
    return PreActivation;
}());
var ActivateRoutes = (function () {
    /**
     * @param {?} routeReuseStrategy
     * @param {?} futureState
     * @param {?} currState
     */
    function ActivateRoutes(routeReuseStrategy, futureState, currState) {
        this.routeReuseStrategy = routeReuseStrategy;
        this.futureState = futureState;
        this.currState = currState;
    }
    /**
     * @param {?} parentContexts
     * @return {?}
     */
    ActivateRoutes.prototype.activate = function (parentContexts) {
        var /** @type {?} */ futureRoot = this.futureState._root;
        var /** @type {?} */ currRoot = this.currState ? this.currState._root : null;
        this.deactivateChildRoutes(futureRoot, currRoot, parentContexts);
        advanceActivatedRoute(this.futureState.root);
        this.activateChildRoutes(futureRoot, currRoot, parentContexts);
    };
    /**
     * @param {?} futureNode
     * @param {?} currNode
     * @param {?} contexts
     * @return {?}
     */
    ActivateRoutes.prototype.deactivateChildRoutes = function (futureNode, currNode, contexts) {
        var _this = this;
        var /** @type {?} */ children = nodeChildrenAsMap(currNode);
        // Recurse on the routes active in the future state to de-activate deeper children
        futureNode.children.forEach(function (futureChild) {
            var /** @type {?} */ childOutletName = futureChild.value.outlet;
            _this.deactivateRoutes(futureChild, children[childOutletName], contexts);
            delete children[childOutletName];
        });
        // De-activate the routes that will not be re-used
        forEach(children, function (v, childName) {
            _this.deactivateRouteAndItsChildren(v, contexts);
        });
    };
    /**
     * @param {?} futureNode
     * @param {?} currNode
     * @param {?} parentContext
     * @return {?}
     */
    ActivateRoutes.prototype.deactivateRoutes = function (futureNode, currNode, parentContext) {
        var /** @type {?} */ future = futureNode.value;
        var /** @type {?} */ curr = currNode ? currNode.value : null;
        if (future === curr) {
            // Reusing the node, check to see if the children need to be de-activated
            if (future.component) {
                // If we have a normal route, we need to go through an outlet.
                var /** @type {?} */ context = parentContext.getContext(future.outlet);
                if (context) {
                    this.deactivateChildRoutes(futureNode, currNode, context.children);
                }
            }
            else {
                // if we have a componentless route, we recurse but keep the same outlet map.
                this.deactivateChildRoutes(futureNode, currNode, parentContext);
            }
        }
        else {
            if (curr) {
                // Deactivate the current route which will not be re-used
                this.deactivateRouteAndItsChildren(currNode, parentContext);
            }
        }
    };
    /**
     * @param {?} route
     * @param {?} parentContexts
     * @return {?}
     */
    ActivateRoutes.prototype.deactivateRouteAndItsChildren = function (route, parentContexts) {
        if (this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {
            this.detachAndStoreRouteSubtree(route, parentContexts);
        }
        else {
            this.deactivateRouteAndOutlet(route, parentContexts);
        }
    };
    /**
     * @param {?} route
     * @param {?} parentContexts
     * @return {?}
     */
    ActivateRoutes.prototype.detachAndStoreRouteSubtree = function (route, parentContexts) {
        var /** @type {?} */ context = parentContexts.getContext(route.value.outlet);
        if (context && context.outlet) {
            var /** @type {?} */ componentRef = context.outlet.detach();
            var /** @type {?} */ contexts = context.children.onOutletDeactivated();
            this.routeReuseStrategy.store(route.value.snapshot, { componentRef: componentRef, route: route, contexts: contexts });
        }
    };
    /**
     * @param {?} route
     * @param {?} parentContexts
     * @return {?}
     */
    ActivateRoutes.prototype.deactivateRouteAndOutlet = function (route, parentContexts) {
        var _this = this;
        var /** @type {?} */ context = parentContexts.getContext(route.value.outlet);
        if (context) {
            var /** @type {?} */ children = nodeChildrenAsMap(route);
            var /** @type {?} */ contexts_1 = route.value.component ? context.children : parentContexts;
            forEach(children, function (v, k) { return _this.deactivateRouteAndItsChildren(v, contexts_1); });
            if (context.outlet) {
                // Destroy the component
                context.outlet.deactivate();
                // Destroy the contexts for all the outlets that were in the component
                context.children.onOutletDeactivated();
            }
        }
    };
    /**
     * @param {?} futureNode
     * @param {?} currNode
     * @param {?} contexts
     * @return {?}
     */
    ActivateRoutes.prototype.activateChildRoutes = function (futureNode, currNode, contexts) {
        var _this = this;
        var /** @type {?} */ children = nodeChildrenAsMap(currNode);
        futureNode.children.forEach(function (c) { _this.activateRoutes(c, children[c.value.outlet], contexts); });
    };
    /**
     * @param {?} futureNode
     * @param {?} currNode
     * @param {?} parentContexts
     * @return {?}
     */
    ActivateRoutes.prototype.activateRoutes = function (futureNode, currNode, parentContexts) {
        var /** @type {?} */ future = futureNode.value;
        var /** @type {?} */ curr = currNode ? currNode.value : null;
        advanceActivatedRoute(future);
        // reusing the node
        if (future === curr) {
            if (future.component) {
                // If we have a normal route, we need to go through an outlet.
                var /** @type {?} */ context = parentContexts.getOrCreateContext(future.outlet);
                this.activateChildRoutes(futureNode, currNode, context.children);
            }
            else {
                // if we have a componentless route, we recurse but keep the same outlet map.
                this.activateChildRoutes(futureNode, currNode, parentContexts);
            }
        }
        else {
            if (future.component) {
                // if we have a normal route, we need to place the component into the outlet and recurse.
                var /** @type {?} */ context = parentContexts.getOrCreateContext(future.outlet);
                if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {
                    var /** @type {?} */ stored = ((this.routeReuseStrategy.retrieve(future.snapshot)));
                    this.routeReuseStrategy.store(future.snapshot, null);
                    context.children.onOutletReAttached(stored.contexts);
                    context.attachRef = stored.componentRef;
                    context.route = stored.route.value;
                    if (context.outlet) {
                        // Attach right away when the outlet has already been instantiated
                        // Otherwise attach from `RouterOutlet.ngOnInit` when it is instantiated
                        context.outlet.attach(stored.componentRef, stored.route.value);
                    }
                    advanceActivatedRouteNodeAndItsChildren(stored.route);
                }
                else {
                    var /** @type {?} */ config = parentLoadedConfig(future.snapshot);
                    var /** @type {?} */ cmpFactoryResolver = config ? config.module.componentFactoryResolver : null;
                    context.route = future;
                    context.resolver = cmpFactoryResolver;
                    if (context.outlet) {
                        // Activate the outlet when it has already been instantiated
                        // Otherwise it will get activated from its `ngOnInit` when instantiated
                        context.outlet.activateWith(future, cmpFactoryResolver);
                    }
                    this.activateChildRoutes(futureNode, null, context.children);
                }
            }
            else {
                // if we have a componentless route, we recurse but keep the same outlet map.
                this.activateChildRoutes(futureNode, null, parentContexts);
            }
        }
    };
    return ActivateRoutes;
}());
/**
 * @param {?} node
 * @return {?}
 */
function advanceActivatedRouteNodeAndItsChildren(node) {
    advanceActivatedRoute(node.value);
    node.children.forEach(advanceActivatedRouteNodeAndItsChildren);
}
/**
 * @param {?} snapshot
 * @return {?}
 */
function parentLoadedConfig(snapshot) {
    for (var /** @type {?} */ s = snapshot.parent; s; s = s.parent) {
        var /** @type {?} */ route = s._routeConfig;
        if (route && route._loadedConfig)
            return route._loadedConfig;
        if (route && route.component)
            return null;
    }
    return null;
}
/**
 * @param {?} snapshot
 * @return {?}
 */
function closestLoadedConfig(snapshot) {
    if (!snapshot)
        return null;
    for (var /** @type {?} */ s = snapshot.parent; s; s = s.parent) {
        var /** @type {?} */ route = s._routeConfig;
        if (route && route._loadedConfig)
            return route._loadedConfig;
    }
    return null;
}
/**
 * @template T
 * @param {?} node
 * @return {?}
 */
function nodeChildrenAsMap(node) {
    var /** @type {?} */ map$$1 = {};
    if (node) {
        node.children.forEach(function (child) { return map$$1[child.value.outlet] = child; });
    }
    return map$$1;
}
/**
 * @param {?} commands
 * @return {?}
 */
function validateCommands(commands) {
    for (var /** @type {?} */ i = 0; i < commands.length; i++) {
        var /** @type {?} */ cmd = commands[i];
        if (cmd == null) {
            throw new Error("The requested path contains " + cmd + " segment at index " + i);
        }
    }
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * \@whatItDoes Lets you link to specific parts of your app.
 *
 * \@howToUse
 *
 * Consider the following route configuration:
 * `[{ path: 'user/:name', component: UserCmp }]`
 *
 * When linking to this `user/:name` route, you can write:
 * `<a routerLink='/user/bob'>link to user component</a>`
 *
 * \@description
 *
 * The RouterLink directives let you link to specific parts of your app.
 *
 * When the link is static, you can use the directive as follows:
 * `<a routerLink="/user/bob">link to user component</a>`
 *
 * If you use dynamic values to generate the link, you can pass an array of path
 * segments, followed by the params for each segment.
 *
 * For instance `['/team', teamId, 'user', userName, {details: true}]`
 * means that we want to generate a link to `/team/11/user/bob;details=true`.
 *
 * Multiple static segments can be merged into one
 * (e.g., `['/team/11/user', userName, {details: true}]`).
 *
 * The first segment name can be prepended with `/`, `./`, or `../`:
 * * If the first segment begins with `/`, the router will look up the route from the root of the
 *   app.
 * * If the first segment begins with `./`, or doesn't begin with a slash, the router will
 *   instead look in the children of the current activated route.
 * * And if the first segment begins with `../`, the router will go up one level.
 *
 * You can set query params and fragment as follows:
 *
 * ```
 * <a [routerLink]="['/user/bob']" [queryParams]="{debug: true}" fragment="education">
 *   link to user component
 * </a>
 * ```
 * RouterLink will use these to generate this link: `/user/bob#education?debug=true`.
 *
 * (Deprecated in v4.0.0 use `queryParamsHandling` instead) You can also tell the
 * directive to preserve the current query params and fragment:
 *
 * ```
 * <a [routerLink]="['/user/bob']" preserveQueryParams preserveFragment>
 *   link to user component
 * </a>
 * ```
 *
 * You can tell the directive to how to handle queryParams, available options are:
 *  - 'merge' merge the queryParams into the current queryParams
 *  - 'preserve' preserve the current queryParams
 *  - default / '' use the queryParams only
 *  same options for {\@link NavigationExtras#queryParamsHandling}
 *
 * ```
 * <a [routerLink]="['/user/bob']" [queryParams]="{debug: true}" queryParamsHandling="merge">
 *   link to user component
 * </a>
 * ```
 *
 * The router link directive always treats the provided input as a delta to the current url.
 *
 * For instance, if the current url is `/user/(box//aux:team)`.
 *
 * Then the following link `<a [routerLink]="['/user/jim']">Jim</a>` will generate the link
 * `/user/(jim//aux:team)`.
 *
 * \@ngModule RouterModule
 *
 * See {\@link Router#createUrlTree} for more information.
 *
 * \@stable
 */
var RouterLink = (function () {
    /**
     * @param {?} router
     * @param {?} route
     * @param {?} tabIndex
     * @param {?} renderer
     * @param {?} el
     */
    function RouterLink(router, route, tabIndex, renderer, el) {
        this.router = router;
        this.route = route;
        this.commands = [];
        if (tabIndex == null) {
            renderer.setAttribute(el.nativeElement, 'tabindex', '0');
        }
    }
    Object.defineProperty(RouterLink.prototype, "routerLink", {
        /**
         * @param {?} commands
         * @return {?}
         */
        set: function (commands) {
            if (commands != null) {
                this.commands = Array.isArray(commands) ? commands : [commands];
            }
            else {
                this.commands = [];
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RouterLink.prototype, "preserveQueryParams", {
        /**
         * @deprecated 4.0.0 use `queryParamsHandling` instead.
         * @param {?} value
         * @return {?}
         */
        set: function (value) {
            if (Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["isDevMode"])() && (console) && (console.warn)) {
                console.warn('preserveQueryParams is deprecated!, use queryParamsHandling instead.');
            }
            this.preserve = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    RouterLink.prototype.onClick = function () {
        var /** @type {?} */ extras = {
            skipLocationChange: attrBoolValue(this.skipLocationChange),
            replaceUrl: attrBoolValue(this.replaceUrl),
        };
        this.router.navigateByUrl(this.urlTree, extras);
        return true;
    };
    Object.defineProperty(RouterLink.prototype, "urlTree", {
        /**
         * @return {?}
         */
        get: function () {
            return this.router.createUrlTree(this.commands, {
                relativeTo: this.route,
                queryParams: this.queryParams,
                fragment: this.fragment,
                preserveQueryParams: attrBoolValue(this.preserve),
                queryParamsHandling: this.queryParamsHandling,
                preserveFragment: attrBoolValue(this.preserveFragment),
            });
        },
        enumerable: true,
        configurable: true
    });
    return RouterLink;
}());
RouterLink.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Directive"], args: [{ selector: ':not(a)[routerLink]' },] },
];
/**
 * @nocollapse
 */
RouterLink.ctorParameters = function () { return [
    { type: Router, },
    { type: ActivatedRoute, },
    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Attribute"], args: ['tabindex',] },] },
    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Renderer2"], },
    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["ElementRef"], },
]; };
RouterLink.propDecorators = {
    'queryParams': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Input"] },],
    'fragment': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Input"] },],
    'queryParamsHandling': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Input"] },],
    'preserveFragment': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Input"] },],
    'skipLocationChange': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Input"] },],
    'replaceUrl': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Input"] },],
    'routerLink': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Input"] },],
    'preserveQueryParams': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Input"] },],
    'onClick': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["HostListener"], args: ['click',] },],
};
/**
 * \@whatItDoes Lets you link to specific parts of your app.
 *
 * See {\@link RouterLink} for more information.
 *
 * \@ngModule RouterModule
 *
 * \@stable
 */
var RouterLinkWithHref = (function () {
    /**
     * @param {?} router
     * @param {?} route
     * @param {?} locationStrategy
     */
    function RouterLinkWithHref(router, route, locationStrategy) {
        var _this = this;
        this.router = router;
        this.route = route;
        this.locationStrategy = locationStrategy;
        this.commands = [];
        this.subscription = router.events.subscribe(function (s) {
            if (s instanceof NavigationEnd) {
                _this.updateTargetUrlAndHref();
            }
        });
    }
    Object.defineProperty(RouterLinkWithHref.prototype, "routerLink", {
        /**
         * @param {?} commands
         * @return {?}
         */
        set: function (commands) {
            if (commands != null) {
                this.commands = Array.isArray(commands) ? commands : [commands];
            }
            else {
                this.commands = [];
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RouterLinkWithHref.prototype, "preserveQueryParams", {
        /**
         * @param {?} value
         * @return {?}
         */
        set: function (value) {
            if (Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["isDevMode"])() && (console) && (console.warn)) {
                console.warn('preserveQueryParams is deprecated, use queryParamsHandling instead.');
            }
            this.preserve = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} changes
     * @return {?}
     */
    RouterLinkWithHref.prototype.ngOnChanges = function (changes) { this.updateTargetUrlAndHref(); };
    /**
     * @return {?}
     */
    RouterLinkWithHref.prototype.ngOnDestroy = function () { this.subscription.unsubscribe(); };
    /**
     * @param {?} button
     * @param {?} ctrlKey
     * @param {?} metaKey
     * @param {?} shiftKey
     * @return {?}
     */
    RouterLinkWithHref.prototype.onClick = function (button, ctrlKey, metaKey, shiftKey) {
        if (button !== 0 || ctrlKey || metaKey || shiftKey) {
            return true;
        }
        if (typeof this.target === 'string' && this.target != '_self') {
            return true;
        }
        var /** @type {?} */ extras = {
            skipLocationChange: attrBoolValue(this.skipLocationChange),
            replaceUrl: attrBoolValue(this.replaceUrl),
        };
        this.router.navigateByUrl(this.urlTree, extras);
        return false;
    };
    /**
     * @return {?}
     */
    RouterLinkWithHref.prototype.updateTargetUrlAndHref = function () {
        this.href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree));
    };
    Object.defineProperty(RouterLinkWithHref.prototype, "urlTree", {
        /**
         * @return {?}
         */
        get: function () {
            return this.router.createUrlTree(this.commands, {
                relativeTo: this.route,
                queryParams: this.queryParams,
                fragment: this.fragment,
                preserveQueryParams: attrBoolValue(this.preserve),
                queryParamsHandling: this.queryParamsHandling,
                preserveFragment: attrBoolValue(this.preserveFragment),
            });
        },
        enumerable: true,
        configurable: true
    });
    return RouterLinkWithHref;
}());
RouterLinkWithHref.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Directive"], args: [{ selector: 'a[routerLink]' },] },
];
/**
 * @nocollapse
 */
RouterLinkWithHref.ctorParameters = function () { return [
    { type: Router, },
    { type: ActivatedRoute, },
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_common__["LocationStrategy"], },
]; };
RouterLinkWithHref.propDecorators = {
    'target': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["HostBinding"], args: ['attr.target',] }, { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Input"] },],
    'queryParams': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Input"] },],
    'fragment': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Input"] },],
    'queryParamsHandling': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Input"] },],
    'preserveFragment': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Input"] },],
    'skipLocationChange': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Input"] },],
    'replaceUrl': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Input"] },],
    'href': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["HostBinding"] },],
    'routerLink': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Input"] },],
    'preserveQueryParams': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Input"] },],
    'onClick': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["HostListener"], args: ['click', ['$event.button', '$event.ctrlKey', '$event.metaKey', '$event.shiftKey'],] },],
};
/**
 * @param {?} s
 * @return {?}
 */
function attrBoolValue(s) {
    return s === '' || !!s;
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * \@whatItDoes Lets you add a CSS class to an element when the link's route becomes active.
 *
 * \@howToUse
 *
 * ```
 * <a routerLink="/user/bob" routerLinkActive="active-link">Bob</a>
 * ```
 *
 * \@description
 *
 * The RouterLinkActive directive lets you add a CSS class to an element when the link's route
 * becomes active.
 *
 * Consider the following example:
 *
 * ```
 * <a routerLink="/user/bob" routerLinkActive="active-link">Bob</a>
 * ```
 *
 * When the url is either '/user' or '/user/bob', the active-link class will
 * be added to the `a` tag. If the url changes, the class will be removed.
 *
 * You can set more than one class, as follows:
 *
 * ```
 * <a routerLink="/user/bob" routerLinkActive="class1 class2">Bob</a>
 * <a routerLink="/user/bob" [routerLinkActive]="['class1', 'class2']">Bob</a>
 * ```
 *
 * You can configure RouterLinkActive by passing `exact: true`. This will add the classes
 * only when the url matches the link exactly.
 *
 * ```
 * <a routerLink="/user/bob" routerLinkActive="active-link" [routerLinkActiveOptions]="{exact:
 * true}">Bob</a>
 * ```
 *
 * You can assign the RouterLinkActive instance to a template variable and directly check
 * the `isActive` status.
 * ```
 * <a routerLink="/user/bob" routerLinkActive #rla="routerLinkActive">
 *   Bob {{ rla.isActive ? '(already open)' : ''}}
 * </a>
 * ```
 *
 * Finally, you can apply the RouterLinkActive directive to an ancestor of a RouterLink.
 *
 * ```
 * <div routerLinkActive="active-link" [routerLinkActiveOptions]="{exact: true}">
 *   <a routerLink="/user/jim">Jim</a>
 *   <a routerLink="/user/bob">Bob</a>
 * </div>
 * ```
 *
 * This will set the active-link class on the div tag if the url is either '/user/jim' or
 * '/user/bob'.
 *
 * \@ngModule RouterModule
 *
 * \@stable
 */
var RouterLinkActive = (function () {
    /**
     * @param {?} router
     * @param {?} element
     * @param {?} renderer
     * @param {?} cdr
     */
    function RouterLinkActive(router, element, renderer, cdr) {
        var _this = this;
        this.router = router;
        this.element = element;
        this.renderer = renderer;
        this.cdr = cdr;
        this.classes = [];
        this.active = false;
        this.routerLinkActiveOptions = { exact: false };
        this.subscription = router.events.subscribe(function (s) {
            if (s instanceof NavigationEnd) {
                _this.update();
            }
        });
    }
    Object.defineProperty(RouterLinkActive.prototype, "isActive", {
        /**
         * @return {?}
         */
        get: function () { return this.active; },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    RouterLinkActive.prototype.ngAfterContentInit = function () {
        var _this = this;
        this.links.changes.subscribe(function (_) { return _this.update(); });
        this.linksWithHrefs.changes.subscribe(function (_) { return _this.update(); });
        this.update();
    };
    Object.defineProperty(RouterLinkActive.prototype, "routerLinkActive", {
        /**
         * @param {?} data
         * @return {?}
         */
        set: function (data) {
            var /** @type {?} */ classes = Array.isArray(data) ? data : data.split(' ');
            this.classes = classes.filter(function (c) { return !!c; });
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} changes
     * @return {?}
     */
    RouterLinkActive.prototype.ngOnChanges = function (changes) { this.update(); };
    /**
     * @return {?}
     */
    RouterLinkActive.prototype.ngOnDestroy = function () { this.subscription.unsubscribe(); };
    /**
     * @return {?}
     */
    RouterLinkActive.prototype.update = function () {
        var _this = this;
        if (!this.links || !this.linksWithHrefs || !this.router.navigated)
            return;
        var /** @type {?} */ hasActiveLinks = this.hasActiveLinks();
        // react only when status has changed to prevent unnecessary dom updates
        if (this.active !== hasActiveLinks) {
            this.classes.forEach(function (c) {
                if (hasActiveLinks) {
                    _this.renderer.addClass(_this.element.nativeElement, c);
                }
                else {
                    _this.renderer.removeClass(_this.element.nativeElement, c);
                }
            });
            Promise.resolve(hasActiveLinks).then(function (active) { return _this.active = active; });
        }
    };
    /**
     * @param {?} router
     * @return {?}
     */
    RouterLinkActive.prototype.isLinkActive = function (router) {
        var _this = this;
        return function (link) { return router.isActive(link.urlTree, _this.routerLinkActiveOptions.exact); };
    };
    /**
     * @return {?}
     */
    RouterLinkActive.prototype.hasActiveLinks = function () {
        return this.links.some(this.isLinkActive(this.router)) ||
            this.linksWithHrefs.some(this.isLinkActive(this.router));
    };
    return RouterLinkActive;
}());
RouterLinkActive.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Directive"], args: [{
                selector: '[routerLinkActive]',
                exportAs: 'routerLinkActive',
            },] },
];
/**
 * @nocollapse
 */
RouterLinkActive.ctorParameters = function () { return [
    { type: Router, },
    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["ElementRef"], },
    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Renderer2"], },
    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["ChangeDetectorRef"], },
]; };
RouterLinkActive.propDecorators = {
    'links': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["ContentChildren"], args: [RouterLink, { descendants: true },] },],
    'linksWithHrefs': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["ContentChildren"], args: [RouterLinkWithHref, { descendants: true },] },],
    'routerLinkActiveOptions': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Input"] },],
    'routerLinkActive': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Input"] },],
};
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Store contextual information about a {\@link RouterOutlet}
 *
 * \@stable
 */
var OutletContext = (function () {
    function OutletContext() {
        this.outlet = null;
        this.route = null;
        this.resolver = null;
        this.children = new ChildrenOutletContexts();
        this.attachRef = null;
    }
    return OutletContext;
}());
/**
 * Store contextual information about the children (= nested) {\@link RouterOutlet}
 *
 * \@stable
 */
var ChildrenOutletContexts = (function () {
    function ChildrenOutletContexts() {
        this.contexts = new Map();
    }
    /**
     * Called when a `RouterOutlet` directive is instantiated
     * @param {?} childName
     * @param {?} outlet
     * @return {?}
     */
    ChildrenOutletContexts.prototype.onChildOutletCreated = function (childName, outlet) {
        var /** @type {?} */ context = this.getOrCreateContext(childName);
        context.outlet = outlet;
        this.contexts.set(childName, context);
    };
    /**
     * Called when a `RouterOutlet` directive is destroyed.
     * We need to keep the context as the outlet could be destroyed inside a NgIf and might be
     * re-created later.
     * @param {?} childName
     * @return {?}
     */
    ChildrenOutletContexts.prototype.onChildOutletDestroyed = function (childName) {
        var /** @type {?} */ context = this.getContext(childName);
        if (context) {
            context.outlet = null;
        }
    };
    /**
     * Called when the corresponding route is deactivated during navigation.
     * Because the component get destroyed, all children outlet are destroyed.
     * @return {?}
     */
    ChildrenOutletContexts.prototype.onOutletDeactivated = function () {
        var /** @type {?} */ contexts = this.contexts;
        this.contexts = new Map();
        return contexts;
    };
    /**
     * @param {?} contexts
     * @return {?}
     */
    ChildrenOutletContexts.prototype.onOutletReAttached = function (contexts) { this.contexts = contexts; };
    /**
     * @param {?} childName
     * @return {?}
     */
    ChildrenOutletContexts.prototype.getOrCreateContext = function (childName) {
        var /** @type {?} */ context = this.getContext(childName);
        if (!context) {
            context = new OutletContext();
            this.contexts.set(childName, context);
        }
        return context;
    };
    /**
     * @param {?} childName
     * @return {?}
     */
    ChildrenOutletContexts.prototype.getContext = function (childName) { return this.contexts.get(childName) || null; };
    return ChildrenOutletContexts;
}());
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * \@whatItDoes Acts as a placeholder that Angular dynamically fills based on the current router
 * state.
 *
 * \@howToUse
 *
 * ```
 * <router-outlet></router-outlet>
 * <router-outlet name='left'></router-outlet>
 * <router-outlet name='right'></router-outlet>
 * ```
 *
 * A router outlet will emit an activate event any time a new component is being instantiated,
 * and a deactivate event when it is being destroyed.
 *
 * ```
 * <router-outlet
 *   (activate)='onActivate($event)'
 *   (deactivate)='onDeactivate($event)'></router-outlet>
 * ```
 * \@ngModule RouterModule
 *
 * \@stable
 */
var RouterOutlet = (function () {
    /**
     * @param {?} parentContexts
     * @param {?} location
     * @param {?} resolver
     * @param {?} name
     * @param {?} changeDetector
     */
    function RouterOutlet(parentContexts, location, resolver, name, changeDetector) {
        this.parentContexts = parentContexts;
        this.location = location;
        this.resolver = resolver;
        this.changeDetector = changeDetector;
        this.activated = null;
        this._activatedRoute = null;
        this.activateEvents = new __WEBPACK_IMPORTED_MODULE_2__angular_core__["EventEmitter"]();
        this.deactivateEvents = new __WEBPACK_IMPORTED_MODULE_2__angular_core__["EventEmitter"]();
        this.name = name || PRIMARY_OUTLET;
        parentContexts.onChildOutletCreated(this.name, this);
    }
    /**
     * @return {?}
     */
    RouterOutlet.prototype.ngOnDestroy = function () { this.parentContexts.onChildOutletDestroyed(this.name); };
    /**
     * @return {?}
     */
    RouterOutlet.prototype.ngOnInit = function () {
        if (!this.activated) {
            // If the outlet was not instantiated at the time the route got activated we need to populate
            // the outlet when it is initialized (ie inside a NgIf)
            var /** @type {?} */ context = this.parentContexts.getContext(this.name);
            if (context && context.route) {
                if (context.attachRef) {
                    // `attachRef` is populated when there is an existing component to mount
                    this.attach(context.attachRef, context.route);
                }
                else {
                    // otherwise the component defined in the configuration is created
                    this.activateWith(context.route, context.resolver || null);
                }
            }
        }
    };
    Object.defineProperty(RouterOutlet.prototype, "locationInjector", {
        /**
         * @deprecated since v4 *
         * @return {?}
         */
        get: function () { return this.location.injector; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RouterOutlet.prototype, "locationFactoryResolver", {
        /**
         * @deprecated since v4 *
         * @return {?}
         */
        get: function () { return this.resolver; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RouterOutlet.prototype, "isActivated", {
        /**
         * @return {?}
         */
        get: function () { return !!this.activated; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RouterOutlet.prototype, "component", {
        /**
         * @return {?}
         */
        get: function () {
            if (!this.activated)
                throw new Error('Outlet is not activated');
            return this.activated.instance;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RouterOutlet.prototype, "activatedRoute", {
        /**
         * @return {?}
         */
        get: function () {
            if (!this.activated)
                throw new Error('Outlet is not activated');
            return (this._activatedRoute);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RouterOutlet.prototype, "activatedRouteData", {
        /**
         * @return {?}
         */
        get: function () {
            if (this._activatedRoute) {
                return this._activatedRoute.snapshot.data;
            }
            return {};
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Called when the `RouteReuseStrategy` instructs to detach the subtree
     * @return {?}
     */
    RouterOutlet.prototype.detach = function () {
        if (!this.activated)
            throw new Error('Outlet is not activated');
        this.location.detach();
        var /** @type {?} */ cmp = this.activated;
        this.activated = null;
        this._activatedRoute = null;
        return cmp;
    };
    /**
     * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree
     * @param {?} ref
     * @param {?} activatedRoute
     * @return {?}
     */
    RouterOutlet.prototype.attach = function (ref, activatedRoute) {
        this.activated = ref;
        this._activatedRoute = activatedRoute;
        this.location.insert(ref.hostView);
    };
    /**
     * @return {?}
     */
    RouterOutlet.prototype.deactivate = function () {
        if (this.activated) {
            var /** @type {?} */ c = this.component;
            this.activated.destroy();
            this.activated = null;
            this._activatedRoute = null;
            this.deactivateEvents.emit(c);
        }
    };
    /**
     * @param {?} activatedRoute
     * @param {?} resolver
     * @return {?}
     */
    RouterOutlet.prototype.activateWith = function (activatedRoute, resolver) {
        if (this.isActivated) {
            throw new Error('Cannot activate an already activated outlet');
        }
        this._activatedRoute = activatedRoute;
        var /** @type {?} */ snapshot = activatedRoute._futureSnapshot;
        var /** @type {?} */ component = (((snapshot._routeConfig)).component);
        resolver = resolver || this.resolver;
        var /** @type {?} */ factory = resolver.resolveComponentFactory(component);
        var /** @type {?} */ childContexts = this.parentContexts.getOrCreateContext(this.name).children;
        var /** @type {?} */ injector = new OutletInjector(activatedRoute, childContexts, this.location.injector);
        this.activated = this.location.createComponent(factory, this.location.length, injector);
        // Calling `markForCheck` to make sure we will run the change detection when the
        // `RouterOutlet` is inside a `ChangeDetectionStrategy.OnPush` component.
        this.changeDetector.markForCheck();
        this.activateEvents.emit(this.activated.instance);
    };
    return RouterOutlet;
}());
RouterOutlet.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Directive"], args: [{ selector: 'router-outlet', exportAs: 'outlet' },] },
];
/**
 * @nocollapse
 */
RouterOutlet.ctorParameters = function () { return [
    { type: ChildrenOutletContexts, },
    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["ViewContainerRef"], },
    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["ComponentFactoryResolver"], },
    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Attribute"], args: ['name',] },] },
    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["ChangeDetectorRef"], },
]; };
RouterOutlet.propDecorators = {
    'activateEvents': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Output"], args: ['activate',] },],
    'deactivateEvents': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Output"], args: ['deactivate',] },],
};
var OutletInjector = (function () {
    /**
     * @param {?} route
     * @param {?} childContexts
     * @param {?} parent
     */
    function OutletInjector(route, childContexts, parent) {
        this.route = route;
        this.childContexts = childContexts;
        this.parent = parent;
    }
    /**
     * @param {?} token
     * @param {?=} notFoundValue
     * @return {?}
     */
    OutletInjector.prototype.get = function (token, notFoundValue) {
        if (token === ActivatedRoute) {
            return this.route;
        }
        if (token === ChildrenOutletContexts) {
            return this.childContexts;
        }
        return this.parent.get(token, notFoundValue);
    };
    return OutletInjector;
}());
/**
*@license
*Copyright Google Inc. All Rights Reserved.
*
*Use of this source code is governed by an MIT-style license that can be
*found in the LICENSE file at https://angular.io/license
*/
/**
 * \@whatItDoes Provides a preloading strategy.
 *
 * \@experimental
 * @abstract
 */
var PreloadingStrategy = (function () {
    function PreloadingStrategy() {
    }
    /**
     * @abstract
     * @param {?} route
     * @param {?} fn
     * @return {?}
     */
    PreloadingStrategy.prototype.preload = function (route, fn) { };
    return PreloadingStrategy;
}());
/**
 * \@whatItDoes Provides a preloading strategy that preloads all modules as quickly as possible.
 *
 * \@howToUse
 *
 * ```
 * RouteModule.forRoot(ROUTES, {preloadingStrategy: PreloadAllModules})
 * ```
 *
 * \@experimental
 */
var PreloadAllModules = (function () {
    function PreloadAllModules() {
    }
    /**
     * @param {?} route
     * @param {?} fn
     * @return {?}
     */
    PreloadAllModules.prototype.preload = function (route, fn) {
        return __WEBPACK_IMPORTED_MODULE_15_rxjs_operator_catch__["_catch"].call(fn(), function () { return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(null); });
    };
    return PreloadAllModules;
}());
/**
 * \@whatItDoes Provides a preloading strategy that does not preload any modules.
 *
 * \@description
 *
 * This strategy is enabled by default.
 *
 * \@experimental
 */
var NoPreloading = (function () {
    function NoPreloading() {
    }
    /**
     * @param {?} route
     * @param {?} fn
     * @return {?}
     */
    NoPreloading.prototype.preload = function (route, fn) { return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(null); };
    return NoPreloading;
}());
/**
 * The preloader optimistically loads all router configurations to
 * make navigations into lazily-loaded sections of the application faster.
 *
 * The preloader runs in the background. When the router bootstraps, the preloader
 * starts listening to all navigation events. After every such event, the preloader
 * will check if any configurations can be loaded lazily.
 *
 * If a route is protected by `canLoad` guards, the preloaded will not load it.
 *
 * \@stable
 */
var RouterPreloader = (function () {
    /**
     * @param {?} router
     * @param {?} moduleLoader
     * @param {?} compiler
     * @param {?} injector
     * @param {?} preloadingStrategy
     */
    function RouterPreloader(router, moduleLoader, compiler, injector, preloadingStrategy) {
        this.router = router;
        this.injector = injector;
        this.preloadingStrategy = preloadingStrategy;
        var onStartLoad = function (r) { return router.triggerEvent(new RouteConfigLoadStart(r)); };
        var onEndLoad = function (r) { return router.triggerEvent(new RouteConfigLoadEnd(r)); };
        this.loader = new RouterConfigLoader(moduleLoader, compiler, onStartLoad, onEndLoad);
    }
    ;
    /**
     * @return {?}
     */
    RouterPreloader.prototype.setUpPreloading = function () {
        var _this = this;
        var /** @type {?} */ navigations$ = __WEBPACK_IMPORTED_MODULE_21_rxjs_operator_filter__["filter"].call(this.router.events, function (e) { return e instanceof NavigationEnd; });
        this.subscription = __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_concatMap__["concatMap"].call(navigations$, function () { return _this.preload(); }).subscribe(function () { });
    };
    /**
     * @return {?}
     */
    RouterPreloader.prototype.preload = function () {
        var /** @type {?} */ ngModule = this.injector.get(__WEBPACK_IMPORTED_MODULE_2__angular_core__["NgModuleRef"]);
        return this.processRoutes(ngModule, this.router.config);
    };
    /**
     * @return {?}
     */
    RouterPreloader.prototype.ngOnDestroy = function () { this.subscription.unsubscribe(); };
    /**
     * @param {?} ngModule
     * @param {?} routes
     * @return {?}
     */
    RouterPreloader.prototype.processRoutes = function (ngModule, routes) {
        var /** @type {?} */ res = [];
        for (var _i = 0, routes_5 = routes; _i < routes_5.length; _i++) {
            var route = routes_5[_i];
            // we already have the config loaded, just recurse
            if (route.loadChildren && !route.canLoad && route._loadedConfig) {
                var /** @type {?} */ childConfig = route._loadedConfig;
                res.push(this.processRoutes(childConfig.module, childConfig.routes));
                // no config loaded, fetch the config
            }
            else if (route.loadChildren && !route.canLoad) {
                res.push(this.preloadConfig(ngModule, route));
                // recurse into children
            }
            else if (route.children) {
                res.push(this.processRoutes(ngModule, route.children));
            }
        }
        return __WEBPACK_IMPORTED_MODULE_19_rxjs_operator_mergeAll__["mergeAll"].call(Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_from__["from"])(res));
    };
    /**
     * @param {?} ngModule
     * @param {?} route
     * @return {?}
     */
    RouterPreloader.prototype.preloadConfig = function (ngModule, route) {
        var _this = this;
        return this.preloadingStrategy.preload(route, function () {
            var /** @type {?} */ loaded$ = _this.loader.load(ngModule.injector, route);
            return __WEBPACK_IMPORTED_MODULE_12_rxjs_operator_mergeMap__["mergeMap"].call(loaded$, function (config) {
                route._loadedConfig = config;
                return _this.processRoutes(config.module, config.routes);
            });
        });
    };
    return RouterPreloader;
}());
RouterPreloader.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"] },
];
/**
 * @nocollapse
 */
RouterPreloader.ctorParameters = function () { return [
    { type: Router, },
    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["NgModuleFactoryLoader"], },
    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Compiler"], },
    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Injector"], },
    { type: PreloadingStrategy, },
]; };
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * \@whatItDoes Contains a list of directives
 * \@stable
 */
var ROUTER_DIRECTIVES = [RouterOutlet, RouterLink, RouterLinkWithHref, RouterLinkActive];
/**
 * \@whatItDoes Is used in DI to configure the router.
 * \@stable
 */
var ROUTER_CONFIGURATION = new __WEBPACK_IMPORTED_MODULE_2__angular_core__["InjectionToken"]('ROUTER_CONFIGURATION');
/**
 * \@docsNotRequired
 */
var ROUTER_FORROOT_GUARD = new __WEBPACK_IMPORTED_MODULE_2__angular_core__["InjectionToken"]('ROUTER_FORROOT_GUARD');
var ROUTER_PROVIDERS = [
    __WEBPACK_IMPORTED_MODULE_1__angular_common__["Location"],
    { provide: UrlSerializer, useClass: DefaultUrlSerializer },
    {
        provide: Router,
        useFactory: setupRouter,
        deps: [
            __WEBPACK_IMPORTED_MODULE_2__angular_core__["ApplicationRef"], UrlSerializer, ChildrenOutletContexts, __WEBPACK_IMPORTED_MODULE_1__angular_common__["Location"], __WEBPACK_IMPORTED_MODULE_2__angular_core__["Injector"],
            __WEBPACK_IMPORTED_MODULE_2__angular_core__["NgModuleFactoryLoader"], __WEBPACK_IMPORTED_MODULE_2__angular_core__["Compiler"], ROUTES, ROUTER_CONFIGURATION,
            [UrlHandlingStrategy, new __WEBPACK_IMPORTED_MODULE_2__angular_core__["Optional"]()], [RouteReuseStrategy, new __WEBPACK_IMPORTED_MODULE_2__angular_core__["Optional"]()]
        ]
    },
    ChildrenOutletContexts,
    { provide: ActivatedRoute, useFactory: rootRoute, deps: [Router] },
    { provide: __WEBPACK_IMPORTED_MODULE_2__angular_core__["NgModuleFactoryLoader"], useClass: __WEBPACK_IMPORTED_MODULE_2__angular_core__["SystemJsNgModuleLoader"] },
    RouterPreloader,
    NoPreloading,
    PreloadAllModules,
    { provide: ROUTER_CONFIGURATION, useValue: { enableTracing: false } },
];
/**
 * @return {?}
 */
function routerNgProbeToken() {
    return new __WEBPACK_IMPORTED_MODULE_2__angular_core__["NgProbeToken"]('Router', Router);
}
/**
 * \@whatItDoes Adds router directives and providers.
 *
 * \@howToUse
 *
 * RouterModule can be imported multiple times: once per lazily-loaded bundle.
 * Since the router deals with a global shared resource--location, we cannot have
 * more than one router service active.
 *
 * That is why there are two ways to create the module: `RouterModule.forRoot` and
 * `RouterModule.forChild`.
 *
 * * `forRoot` creates a module that contains all the directives, the given routes, and the router
 *   service itself.
 * * `forChild` creates a module that contains all the directives and the given routes, but does not
 *   include the router service.
 *
 * When registered at the root, the module should be used as follows
 *
 * ```
 * \@NgModule({
 *   imports: [RouterModule.forRoot(ROUTES)]
 * })
 * class MyNgModule {}
 * ```
 *
 * For submodules and lazy loaded submodules the module should be used as follows:
 *
 * ```
 * \@NgModule({
 *   imports: [RouterModule.forChild(ROUTES)]
 * })
 * class MyNgModule {}
 * ```
 *
 * \@description
 *
 * Managing state transitions is one of the hardest parts of building applications. This is
 * especially true on the web, where you also need to ensure that the state is reflected in the URL.
 * In addition, we often want to split applications into multiple bundles and load them on demand.
 * Doing this transparently is not trivial.
 *
 * The Angular router solves these problems. Using the router, you can declaratively specify
 * application states, manage state transitions while taking care of the URL, and load bundles on
 * demand.
 *
 * [Read this developer guide](https://angular.io/docs/ts/latest/guide/router.html) to get an
 * overview of how the router should be used.
 *
 * \@stable
 */
var RouterModule = (function () {
    /**
     * @param {?} guard
     * @param {?} router
     */
    function RouterModule(guard, router) {
    }
    /**
     * Creates a module with all the router providers and directives. It also optionally sets up an
     * application listener to perform an initial navigation.
     *
     * Options:
     * * `enableTracing` makes the router log all its internal events to the console.
     * * `useHash` enables the location strategy that uses the URL fragment instead of the history
     * API.
     * * `initialNavigation` disables the initial navigation.
     * * `errorHandler` provides a custom error handler.
     * @param {?} routes
     * @param {?=} config
     * @return {?}
     */
    RouterModule.forRoot = function (routes, config) {
        return {
            ngModule: RouterModule,
            providers: [
                ROUTER_PROVIDERS,
                provideRoutes(routes),
                {
                    provide: ROUTER_FORROOT_GUARD,
                    useFactory: provideForRootGuard,
                    deps: [[Router, new __WEBPACK_IMPORTED_MODULE_2__angular_core__["Optional"](), new __WEBPACK_IMPORTED_MODULE_2__angular_core__["SkipSelf"]()]]
                },
                { provide: ROUTER_CONFIGURATION, useValue: config ? config : {} },
                {
                    provide: __WEBPACK_IMPORTED_MODULE_1__angular_common__["LocationStrategy"],
                    useFactory: provideLocationStrategy,
                    deps: [
                        __WEBPACK_IMPORTED_MODULE_1__angular_common__["PlatformLocation"], [new __WEBPACK_IMPORTED_MODULE_2__angular_core__["Inject"](__WEBPACK_IMPORTED_MODULE_1__angular_common__["APP_BASE_HREF"]), new __WEBPACK_IMPORTED_MODULE_2__angular_core__["Optional"]()], ROUTER_CONFIGURATION
                    ]
                },
                {
                    provide: PreloadingStrategy,
                    useExisting: config && config.preloadingStrategy ? config.preloadingStrategy :
                        NoPreloading
                },
                { provide: __WEBPACK_IMPORTED_MODULE_2__angular_core__["NgProbeToken"], multi: true, useFactory: routerNgProbeToken },
                provideRouterInitializer(),
            ],
        };
    };
    /**
     * Creates a module with all the router directives and a provider registering routes.
     * @param {?} routes
     * @return {?}
     */
    RouterModule.forChild = function (routes) {
        return { ngModule: RouterModule, providers: [provideRoutes(routes)] };
    };
    return RouterModule;
}());
RouterModule.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["NgModule"], args: [{ declarations: ROUTER_DIRECTIVES, exports: ROUTER_DIRECTIVES },] },
];
/**
 * @nocollapse
 */
RouterModule.ctorParameters = function () { return [
    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Inject"], args: [ROUTER_FORROOT_GUARD,] },] },
    { type: Router, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Optional"] },] },
]; };
/**
 * @param {?} platformLocationStrategy
 * @param {?} baseHref
 * @param {?=} options
 * @return {?}
 */
function provideLocationStrategy(platformLocationStrategy, baseHref, options) {
    if (options === void 0) { options = {}; }
    return options.useHash ? new __WEBPACK_IMPORTED_MODULE_1__angular_common__["HashLocationStrategy"](platformLocationStrategy, baseHref) :
        new __WEBPACK_IMPORTED_MODULE_1__angular_common__["PathLocationStrategy"](platformLocationStrategy, baseHref);
}
/**
 * @param {?} router
 * @return {?}
 */
function provideForRootGuard(router) {
    if (router) {
        throw new Error("RouterModule.forRoot() called twice. Lazy loaded modules should use RouterModule.forChild() instead.");
    }
    return 'guarded';
}
/**
 * \@whatItDoes Registers routes.
 *
 * \@howToUse
 *
 * ```
 * \@NgModule({
 *   imports: [RouterModule.forChild(ROUTES)],
 *   providers: [provideRoutes(EXTRA_ROUTES)]
 * })
 * class MyNgModule {}
 * ```
 *
 * \@stable
 * @param {?} routes
 * @return {?}
 */
function provideRoutes(routes) {
    return [
        { provide: __WEBPACK_IMPORTED_MODULE_2__angular_core__["ANALYZE_FOR_ENTRY_COMPONENTS"], multi: true, useValue: routes },
        { provide: ROUTES, multi: true, useValue: routes },
    ];
}
/**
 * @param {?} ref
 * @param {?} urlSerializer
 * @param {?} contexts
 * @param {?} location
 * @param {?} injector
 * @param {?} loader
 * @param {?} compiler
 * @param {?} config
 * @param {?=} opts
 * @param {?=} urlHandlingStrategy
 * @param {?=} routeReuseStrategy
 * @return {?}
 */
function setupRouter(ref, urlSerializer, contexts, location, injector, loader, compiler, config, opts, urlHandlingStrategy, routeReuseStrategy) {
    if (opts === void 0) { opts = {}; }
    var /** @type {?} */ router = new Router(null, urlSerializer, contexts, location, injector, loader, compiler, flatten(config));
    if (urlHandlingStrategy) {
        router.urlHandlingStrategy = urlHandlingStrategy;
    }
    if (routeReuseStrategy) {
        router.routeReuseStrategy = routeReuseStrategy;
    }
    if (opts.errorHandler) {
        router.errorHandler = opts.errorHandler;
    }
    if (opts.enableTracing) {
        var /** @type {?} */ dom_1 = Object(__WEBPACK_IMPORTED_MODULE_20__angular_platform_browser__["ɵgetDOM"])();
        router.events.subscribe(function (e) {
            dom_1.logGroup("Router Event: " + ((e.constructor)).name);
            dom_1.log(e.toString());
            dom_1.log(e);
            dom_1.logGroupEnd();
        });
    }
    return router;
}
/**
 * @param {?} router
 * @return {?}
 */
function rootRoute(router) {
    return router.routerState.root;
}
/**
 * To initialize the router properly we need to do in two steps:
 *
 * We need to start the navigation in a APP_INITIALIZER to block the bootstrap if
 * a resolver or a guards executes asynchronously. Second, we need to actually run
 * activation in a BOOTSTRAP_LISTENER. We utilize the afterPreactivation
 * hook provided by the router to do that.
 *
 * The router navigation starts, reaches the point when preactivation is done, and then
 * pauses. It waits for the hook to be resolved. We then resolve it only in a bootstrap listener.
 */
var RouterInitializer = (function () {
    /**
     * @param {?} injector
     */
    function RouterInitializer(injector) {
        this.injector = injector;
        this.initNavigation = false;
        this.resultOfPreactivationDone = new __WEBPACK_IMPORTED_MODULE_4_rxjs_Subject__["Subject"]();
    }
    /**
     * @return {?}
     */
    RouterInitializer.prototype.appInitializer = function () {
        var _this = this;
        var /** @type {?} */ p = this.injector.get(__WEBPACK_IMPORTED_MODULE_1__angular_common__["LOCATION_INITIALIZED"], Promise.resolve(null));
        return p.then(function () {
            var /** @type {?} */ resolve = ((null));
            var /** @type {?} */ res = new Promise(function (r) { return resolve = r; });
            var /** @type {?} */ router = _this.injector.get(Router);
            var /** @type {?} */ opts = _this.injector.get(ROUTER_CONFIGURATION);
            if (_this.isLegacyDisabled(opts) || _this.isLegacyEnabled(opts)) {
                resolve(true);
            }
            else if (opts.initialNavigation === 'disabled') {
                router.setUpLocationChangeListener();
                resolve(true);
            }
            else if (opts.initialNavigation === 'enabled') {
                router.hooks.afterPreactivation = function () {
                    // only the initial navigation should be delayed
                    if (!_this.initNavigation) {
                        _this.initNavigation = true;
                        resolve(true);
                        return _this.resultOfPreactivationDone;
                        // subsequent navigations should not be delayed
                    }
                    else {
                        return (Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(null));
                    }
                };
                router.initialNavigation();
            }
            else {
                throw new Error("Invalid initialNavigation options: '" + opts.initialNavigation + "'");
            }
            return res;
        });
    };
    /**
     * @param {?} bootstrappedComponentRef
     * @return {?}
     */
    RouterInitializer.prototype.bootstrapListener = function (bootstrappedComponentRef) {
        var /** @type {?} */ opts = this.injector.get(ROUTER_CONFIGURATION);
        var /** @type {?} */ preloader = this.injector.get(RouterPreloader);
        var /** @type {?} */ router = this.injector.get(Router);
        var /** @type {?} */ ref = this.injector.get(__WEBPACK_IMPORTED_MODULE_2__angular_core__["ApplicationRef"]);
        if (bootstrappedComponentRef !== ref.components[0]) {
            return;
        }
        if (this.isLegacyEnabled(opts)) {
            router.initialNavigation();
        }
        else if (this.isLegacyDisabled(opts)) {
            router.setUpLocationChangeListener();
        }
        preloader.setUpPreloading();
        router.resetRootComponentType(ref.componentTypes[0]);
        this.resultOfPreactivationDone.next(/** @type {?} */ ((null)));
        this.resultOfPreactivationDone.complete();
    };
    /**
     * @param {?} opts
     * @return {?}
     */
    RouterInitializer.prototype.isLegacyEnabled = function (opts) {
        return opts.initialNavigation === 'legacy_enabled' || opts.initialNavigation === true ||
            opts.initialNavigation === undefined;
    };
    /**
     * @param {?} opts
     * @return {?}
     */
    RouterInitializer.prototype.isLegacyDisabled = function (opts) {
        return opts.initialNavigation === 'legacy_disabled' || opts.initialNavigation === false;
    };
    return RouterInitializer;
}());
RouterInitializer.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"] },
];
/**
 * @nocollapse
 */
RouterInitializer.ctorParameters = function () { return [
    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Injector"], },
]; };
/**
 * @param {?} r
 * @return {?}
 */
function getAppInitializer(r) {
    return r.appInitializer.bind(r);
}
/**
 * @param {?} r
 * @return {?}
 */
function getBootstrapListener(r) {
    return r.bootstrapListener.bind(r);
}
/**
 * A token for the router initializer that will be called after the app is bootstrapped.
 *
 * \@experimental
 */
var ROUTER_INITIALIZER = new __WEBPACK_IMPORTED_MODULE_2__angular_core__["InjectionToken"]('Router Initializer');
/**
 * @return {?}
 */
function provideRouterInitializer() {
    return [
        RouterInitializer,
        {
            provide: __WEBPACK_IMPORTED_MODULE_2__angular_core__["APP_INITIALIZER"],
            multi: true,
            useFactory: getAppInitializer,
            deps: [RouterInitializer]
        },
        { provide: ROUTER_INITIALIZER, useFactory: getBootstrapListener, deps: [RouterInitializer] },
        { provide: __WEBPACK_IMPORTED_MODULE_2__angular_core__["APP_BOOTSTRAP_LISTENER"], multi: true, useExisting: ROUTER_INITIALIZER },
    ];
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @module
 * @description
 * Entry point for all public APIs of the common package.
 */
/**
 * \@stable
 */
var VERSION = new __WEBPACK_IMPORTED_MODULE_2__angular_core__["Version"]('4.3.5');
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @module
 * @description
 * Entry point for all public APIs of the router package.
 */
// This file only reexports content of the `src` folder. Keep it that way.
/**
 * Generated bundle index. Do not edit.
 */

//# sourceMappingURL=router.es5.js.map


/***/ })

}`
  
  
  
  
Instances: 1
  
### Solution
<p>Ensure that application Source Code is not available with alternative extensions, and ensure that source code is not present within other files or data deployed to the web server, or served by the web server. </p>
  
### Other information
<p>class for {\@link FormControl}, {\@link FormGroup}, and</p><p> * {\@link FormArray}.</p><p> *</p><p> * It provides some of the shared behavior that all controls and groups of controls have, like</p><p> * running validators, calculating status, and resetting state. It also defines the properties</p><p> * that are shared between all sub-classes, like `value`, `valid`, and `dirty`. It shouldn't be</p><p> * instantiated directly.</p><p> *</p><p> * \@stable</p><p> * @abstract</p><p> */</p><p>var AbstractControl = (function () {</p><p>    /**</p><p>     * @param {?} validator</p><p>     * @param {?} asyncValidator</p><p>     */</p><p>    function AbstractControl(validator, asyncValidator) {</p><p>        this.validator = validator;</p><p>        this.asyncValidator = asyncValidator;</p><p>        /**</p><p>         * \@internal</p><p>         */</p><p>        this._onCollectionChange = function () { };</p><p>        this._pristine = true;</p><p>        this._touched = false;</p><p>        /**</p><p>         * \@internal</p><p>         */</p><p>        this._onDisabledChange = [];</p><p>    }</p><p>    Object.defineProperty(AbstractControl.prototype, "value", {</p><p>        /**</p><p>         * The value of the control.</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this._value; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(AbstractControl.prototype, "parent", {</p><p>        /**</p><p>         * The parent control.</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this._parent; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(AbstractControl.prototype, "status", {</p><p>        /**</p><p>         * The validation status of the control. There are four possible</p><p>         * validation statuses:</p><p>         *</p><p>         * * **VALID**:  control has passed all validation checks</p><p>         * * **INVALID**: control has failed at least one validation check</p><p>         * * **PENDING**: control is in the midst of conducting a validation check</p><p>         * * **DISABLED**: control is exempt from validation checks</p><p>         *</p><p>         * These statuses are mutually exclusive, so a control cannot be</p><p>         * both valid AND invalid or invalid AND disabled.</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this._status; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(AbstractControl.prototype, "valid", {</p><p>        /**</p><p>         * A control is `valid` when its `status === VALID`.</p><p>         *</p><p>         * In order to have this status, the control must have passed all its</p><p>         * validation checks.</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this._status === VALID; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(AbstractControl.prototype, "invalid", {</p><p>        /**</p><p>         * A control is `invalid` when its `status === INVALID`.</p><p>         *</p><p>         * In order to have this status, the control must have failed</p><p>         * at least one of its validation checks.</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this._status === INVALID; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(AbstractControl.prototype, "pending", {</p><p>        /**</p><p>         * A control is `pending` when its `status === PENDING`.</p><p>         *</p><p>         * In order to have this status, the control must be in the</p><p>         * middle of conducting a validation check.</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this._status == PENDING; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(AbstractControl.prototype, "disabled", {</p><p>        /**</p><p>         * A control is `disabled` when its `status === DISABLED`.</p><p>         *</p><p>         * Disabled controls are exempt from validation checks and</p><p>         * are not included in the aggregate value of their ancestor</p><p>         * controls.</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this._status === DISABLED; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(AbstractControl.prototype, "enabled", {</p><p>        /**</p><p>         * A control is `enabled` as long as its `status !== DISABLED`.</p><p>         *</p><p>         * In other words, it has a status of `VALID`, `INVALID`, or</p><p>         * `PENDING`.</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this._status !== DISABLED; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(AbstractControl.prototype, "errors", {</p><p>        /**</p><p>         * Returns any errors generated by failing validation. If there</p><p>         * are no errors, it will return null.</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this._errors; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(AbstractControl.prototype, "pristine", {</p><p>        /**</p><p>         * A control is `pristine` if the user has not yet changed</p><p>         * the value in the UI.</p><p>         *</p><p>         * Note that programmatic changes to a control's value will</p><p>         * *not* mark it dirty.</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this._pristine; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(AbstractControl.prototype, "dirty", {</p><p>        /**</p><p>         * A control is `dirty` if the user has changed the value</p><p>         * in the UI.</p><p>         *</p><p>         * Note that programmatic changes to a control's value will</p><p>         * *not* mark it dirty.</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return !this.pristine; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(AbstractControl.prototype, "touched", {</p><p>        /**</p><p>         * A control is marked `touched` once the user has triggered</p><p>         * a `blur` event on it.</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this._touched; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(AbstractControl.prototype, "untouched", {</p><p>        /**</p><p>         * A control is `untouched` if the user has not yet triggered</p><p>         * a `blur` event on it.</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return !this._touched; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(AbstractControl.prototype, "valueChanges", {</p><p>        /**</p><p>         * Emits an event every time the value of the control changes, in</p><p>         * the UI or programmatically.</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this._valueChanges; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(AbstractControl.prototype, "statusChanges", {</p><p>        /**</p><p>         * Emits an event every time the validation status of the control</p><p>         * is re-calculated.</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this._statusChanges; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    /**</p><p>     * Sets the synchronous validators that are active on this control.  Calling</p><p>     * this will overwrite any existing sync validators.</p><p>     * @param {?} newValidator</p><p>     * @return {?}</p><p>     */</p><p>    AbstractControl.prototype.setValidators = function (newValidator) {</p><p>        this.validator = coerceToValidator(newValidator);</p><p>    };</p><p>    /**</p><p>     * Sets the async validators that are active on this control. Calling this</p><p>     * will overwrite any existing async validators.</p><p>     * @param {?} newValidator</p><p>     * @return {?}</p><p>     */</p><p>    AbstractControl.prototype.setAsyncValidators = function (newValidator) {</p><p>        this.asyncValidator = coerceToAsyncValidator(newValidator);</p><p>    };</p><p>    /**</p><p>     * Empties out the sync validator list.</p><p>     * @return {?}</p><p>     */</p><p>    AbstractControl.prototype.clearValidators = function () { this.validator = null; };</p><p>    /**</p><p>     * Empties out the async validator list.</p><p>     * @return {?}</p><p>     */</p><p>    AbstractControl.prototype.clearAsyncValidators = function () { this.asyncValidator = null; };</p><p>    /**</p><p>     * Marks the control as `touched`.</p><p>     *</p><p>     * This will also mark all direct ancestors as `touched` to maintain</p><p>     * the model.</p><p>     * @param {?=} opts</p><p>     * @return {?}</p><p>     */</p><p>    AbstractControl.prototype.markAsTouched = function (opts) {</p><p>        if (opts === void 0) { opts = {}; }</p><p>        this._touched = true;</p><p>        if (this._parent && !opts.onlySelf) {</p><p>            this._parent.markAsTouched(opts);</p><p>        }</p><p>    };</p><p>    /**</p><p>     * Marks the control as `untouched`.</p><p>     *</p><p>     * If the control has any children, it will also mark all children as `untouched`</p><p>     * to maintain the model, and re-calculate the `touched` status of all parent</p><p>     * controls.</p><p>     * @param {?=} opts</p><p>     * @return {?}</p><p>     */</p><p>    AbstractControl.prototype.markAsUntouched = function (opts) {</p><p>        if (opts === void 0) { opts = {}; }</p><p>        this._touched = false;</p><p>        this._forEachChild(function (control) { control.markAsUntouched({ onlySelf: true }); });</p><p>        if (this._parent && !opts.onlySelf) {</p><p>            this._parent._updateTouched(opts);</p><p>        }</p><p>    };</p><p>    /**</p><p>     * Marks the control as `dirty`.</p><p>     *</p><p>     * This will also mark all direct ancestors as `dirty` to maintain</p><p>     * the model.</p><p>     * @param {?=} opts</p><p>     * @return {?}</p><p>     */</p><p>    AbstractControl.prototype.markAsDirty = function (opts) {</p><p>        if (opts === void 0) { opts = {}; }</p><p>        this._pristine = false;</p><p>        if (this._parent && !opts.onlySelf) {</p><p>            this._parent.markAsDirty(opts);</p><p>        }</p><p>    };</p><p>    /**</p><p>     * Marks the control as `pristine`.</p><p>     *</p><p>     * If the control has any children, it will also mark all children as `pristine`</p><p>     * to maintain the model, and re-calculate the `pristine` status of all parent</p><p>     * controls.</p><p>     * @param {?=} opts</p><p>     * @return {?}</p><p>     */</p><p>    AbstractControl.prototype.markAsPristine = function (opts) {</p><p>        if (opts === void 0) { opts = {}; }</p><p>        this._pristine = true;</p><p>        this._forEachChild(function (control) { control.markAsPristine({ onlySelf: true }); });</p><p>        if (this._parent && !opts.onlySelf) {</p><p>            this._parent._updatePristine(opts);</p><p>        }</p><p>    };</p><p>    /**</p><p>     * Marks the control as `pending`.</p><p>     * @param {?=} opts</p><p>     * @return {?}</p><p>     */</p><p>    AbstractControl.prototype.markAsPending = function (opts) {</p><p>        if (opts === void 0) { opts = {}; }</p><p>        this._status = PENDING;</p><p>        if (this._parent && !opts.onlySelf) {</p><p>            this._parent.markAsPending(opts);</p><p>        }</p><p>    };</p><p>    /**</p><p>     * Disables the control. This means the control will be exempt from validation checks and</p><p>     * excluded from the aggregate value of any parent. Its status is `DISABLED`.</p><p>     *</p><p>     * If the control has children, all children will be disabled to maintain the model.</p><p>     * @param {?=} opts</p><p>     * @return {?}</p><p>     */</p><p>    AbstractControl.prototype.disable = function (opts) {</p><p>        if (opts === void 0) { opts = {}; }</p><p>        this._status = DISABLED;</p><p>        this._errors = null;</p><p>        this._forEachChild(function (control) { control.disable({ onlySelf: true }); });</p><p>        this._updateValue();</p><p>        if (opts.emitEvent !== false) {</p><p>            this._valueChanges.emit(this._value);</p><p>            this._statusChanges.emit(this._status);</p><p>        }</p><p>        this._updateAncestors(!!opts.onlySelf);</p><p>        this._onDisabledChange.forEach(function (changeFn) { return changeFn(true); });</p><p>    };</p><p>    /**</p><p>     * Enables the control. This means the control will be included in validation checks and</p><p>     * the aggregate value of its parent. Its status is re-calculated based on its value and</p><p>     * its validators.</p><p>     *</p><p>     * If the control has children, all children will be enabled.</p><p>     * @param {?=} opts</p><p>     * @return {?}</p><p>     */</p><p>    AbstractControl.prototype.enable = function (opts) {</p><p>        if (opts === void 0) { opts = {}; }</p><p>        this._status = VALID;</p><p>        this._forEachChild(function (control) { control.enable({ onlySelf: true }); });</p><p>        this.updateValueAndValidity({ onlySelf: true, emitEvent: opts.emitEvent });</p><p>        this._updateAncestors(!!opts.onlySelf);</p><p>        this._onDisabledChange.forEach(function (changeFn) { return changeFn(false); });</p><p>    };</p><p>    /**</p><p>     * @param {?} onlySelf</p><p>     * @return {?}</p><p>     */</p><p>    AbstractControl.prototype._updateAncestors = function (onlySelf) {</p><p>        if (this._parent && !onlySelf) {</p><p>            this._parent.updateValueAndValidity();</p><p>            this._parent._updatePristine();</p><p>            this._parent._updateTouched();</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @param {?} parent</p><p>     * @return {?}</p><p>     */</p><p>    AbstractControl.prototype.setParent = function (parent) { this._parent = parent; };</p><p>    /**</p><p>     * Sets the value of the control. Abstract method (implemented in sub-classes).</p><p>     * @abstract</p><p>     * @param {?} value</p><p>     * @param {?=} options</p><p>     * @return {?}</p><p>     */</p><p>    AbstractControl.prototype.setValue = function (value, options) { };</p><p>    /**</p><p>     * Patches the value of the control. Abstract method (implemented in sub-classes).</p><p>     * @abstract</p><p>     * @param {?} value</p><p>     * @param {?=} options</p><p>     * @return {?}</p><p>     */</p><p>    AbstractControl.prototype.patchValue = function (value, options) { };</p><p>    /**</p><p>     * Resets the control. Abstract method (implemented in sub-classes).</p><p>     * @abstract</p><p>     * @param {?=} value</p><p>     * @param {?=} options</p><p>     * @return {?}</p><p>     */</p><p>    AbstractControl.prototype.reset = function (value, options) { };</p><p>    /**</p><p>     * Re-calculates the value and validation status of the control.</p><p>     *</p><p>     * By default, it will also update the value and validity of its ancestors.</p><p>     * @param {?=} opts</p><p>     * @return {?}</p><p>     */</p><p>    AbstractControl.prototype.updateValueAndValidity = function (opts) {</p><p>        if (opts === void 0) { opts = {}; }</p><p>        this._setInitialStatus();</p><p>        this._updateValue();</p><p>        if (this.enabled) {</p><p>            this._cancelExistingSubscription();</p><p>            this._errors = this._runValidator();</p><p>            this._status = this._calculateStatus();</p><p>            if (this._status === VALID || this._status === PENDING) {</p><p>                this._runAsyncValidator(opts.emitEvent);</p><p>            }</p><p>        }</p><p>        if (opts.emitEvent !== false) {</p><p>            this._valueChanges.emit(this._value);</p><p>            this._statusChanges.emit(this._status);</p><p>        }</p><p>        if (this._parent && !opts.onlySelf) {</p><p>            this._parent.updateValueAndValidity(opts);</p><p>        }</p><p>    };</p><p>    /**</p><p>     * \@internal</p><p>     * @param {?=} opts</p><p>     * @return {?}</p><p>     */</p><p>    AbstractControl.prototype._updateTreeValidity = function (opts) {</p><p>        if (opts === void 0) { opts = { emitEvent: true }; }</p><p>        this._forEachChild(function (ctrl) { return ctrl._updateTreeValidity(opts); });</p><p>        this.updateValueAndValidity({ onlySelf: true, emitEvent: opts.emitEvent });</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    AbstractControl.prototype._setInitialStatus = function () { this._status = this._allControlsDisabled() ? DISABLED : VALID; };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    AbstractControl.prototype._runValidator = function () {</p><p>        return this.validator ? this.validator(this) : null;</p><p>    };</p><p>    /**</p><p>     * @param {?=} emitEvent</p><p>     * @return {?}</p><p>     */</p><p>    AbstractControl.prototype._runAsyncValidator = function (emitEvent) {</p><p>        var _this = this;</p><p>        if (this.asyncValidator) {</p><p>            this._status = PENDING;</p><p>            var /** @type {?} */ obs = toObservable(this.asyncValidator(this));</p><p>            this._asyncValidationSubscription =</p><p>                obs.subscribe(function (errors) { return _this.setErrors(errors, { emitEvent: emitEvent }); });</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    AbstractControl.prototype._cancelExistingSubscription = function () {</p><p>        if (this._asyncValidationSubscription) {</p><p>            this._asyncValidationSubscription.unsubscribe();</p><p>        }</p><p>    };</p><p>    /**</p><p>     * Sets errors on a form control.</p><p>     *</p><p>     * This is used when validations are run manually by the user, rather than automatically.</p><p>     *</p><p>     * Calling `setErrors` will also update the validity of the parent control.</p><p>     *</p><p>     * ### Example</p><p>     *</p><p>     * ```</p><p>     * const login = new FormControl("someLogin");</p><p>     * login.setErrors({</p><p>     *   "notUnique": true</p><p>     * });</p><p>     *</p><p>     * expect(login.valid).toEqual(false);</p><p>     * expect(login.errors).toEqual({"notUnique": true});</p><p>     *</p><p>     * login.setValue("someOtherLogin");</p><p>     *</p><p>     * expect(login.valid).toEqual(true);</p><p>     * ```</p><p>     * @param {?} errors</p><p>     * @param {?=} opts</p><p>     * @return {?}</p><p>     */</p><p>    AbstractControl.prototype.setErrors = function (errors, opts) {</p><p>        if (opts === void 0) { opts = {}; }</p><p>        this._errors = errors;</p><p>        this._updateControlsErrors(opts.emitEvent !== false);</p><p>    };</p><p>    /**</p><p>     * Retrieves a child control given the control's name or path.</p><p>     *</p><p>     * Paths can be passed in as an array or a string delimited by a dot.</p><p>     *</p><p>     * To get a control nested within a `person` sub-group:</p><p>     *</p><p>     * * `this.form.get('person.name');`</p><p>     *</p><p>     * -OR-</p><p>     *</p><p>     * * `this.form.get(['person', 'name']);`</p><p>     * @param {?} path</p><p>     * @return {?}</p><p>     */</p><p>    AbstractControl.prototype.get = function (path) { return _find(this, path, '.'); };</p><p>    /**</p><p>     * Returns error data if the control with the given path has the error specified. Otherwise</p><p>     * returns null or undefined.</p><p>     *</p><p>     * If no path is given, it checks for the error on the present control.</p><p>     * @param {?} errorCode</p><p>     * @param {?=} path</p><p>     * @return {?}</p><p>     */</p><p>    AbstractControl.prototype.getError = function (errorCode, path) {</p><p>        var /** @type {?} */ control = path ? this.get(path) : this;</p><p>        return control && control._errors ? control._errors[errorCode] : null;</p><p>    };</p><p>    /**</p><p>     * Returns true if the control with the given path has the error specified. Otherwise</p><p>     * returns false.</p><p>     *</p><p>     * If no path is given, it checks for the error on the present control.</p><p>     * @param {?} errorCode</p><p>     * @param {?=} path</p><p>     * @return {?}</p><p>     */</p><p>    AbstractControl.prototype.hasError = function (errorCode, path) { return !!this.getError(errorCode, path); };</p><p>    Object.defineProperty(AbstractControl.prototype, "root", {</p><p>        /**</p><p>         * Retrieves the top-level ancestor of this control.</p><p>         * @return {?}</p><p>         */</p><p>        get: function () {</p><p>            var /** @type {?} */ x = this;</p><p>            while (x._parent) {</p><p>                x = x._parent;</p><p>            }</p><p>            return x;</p><p>        },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    /**</p><p>     * \@internal</p><p>     * @param {?} emitEvent</p><p>     * @return {?}</p><p>     */</p><p>    AbstractControl.prototype._updateControlsErrors = function (emitEvent) {</p><p>        this._status = this._calculateStatus();</p><p>        if (emitEvent) {</p><p>            this._statusChanges.emit(this._status);</p><p>        }</p><p>        if (this._parent) {</p><p>            this._parent._updateControlsErrors(emitEvent);</p><p>        }</p><p>    };</p><p>    /**</p><p>     * \@internal</p><p>     * @return {?}</p><p>     */</p><p>    AbstractControl.prototype._initObservables = function () {</p><p>        this._valueChanges = new __WEBPACK_IMPORTED_MODULE_1__angular_core__["EventEmitter"]();</p><p>        this._statusChanges = new __WEBPACK_IMPORTED_MODULE_1__angular_core__["EventEmitter"]();</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    AbstractControl.prototype._calculateStatus = function () {</p><p>        if (this._allControlsDisabled())</p><p>            return DISABLED;</p><p>        if (this._errors)</p><p>            return INVALID;</p><p>        if (this._anyControlsHaveStatus(PENDING))</p><p>            return PENDING;</p><p>        if (this._anyControlsHaveStatus(INVALID))</p><p>            return INVALID;</p><p>        return VALID;</p><p>    };</p><p>    /**</p><p>     * \@internal</p><p>     * @abstract</p><p>     * @return {?}</p><p>     */</p><p>    AbstractControl.prototype._updateValue = function () { };</p><p>    /**</p><p>     * \@internal</p><p>     * @abstract</p><p>     * @param {?} cb</p><p>     * @return {?}</p><p>     */</p><p>    AbstractControl.prototype._forEachChild = function (cb) { };</p><p>    /**</p><p>     * \@internal</p><p>     * @abstract</p><p>     * @param {?} condition</p><p>     * @return {?}</p><p>     */</p><p>    AbstractControl.prototype._anyControls = function (condition) { };</p><p>    /**</p><p>     * \@internal</p><p>     * @abstract</p><p>     * @return {?}</p><p>     */</p><p>    AbstractControl.prototype._allControlsDisabled = function () { };</p><p>    /**</p><p>     * \@internal</p><p>     * @param {?} status</p><p>     * @return {?}</p><p>     */</p><p>    AbstractControl.prototype._anyControlsHaveStatus = function (status) {</p><p>        return this._anyControls(function (control) { return control.status === status; });</p><p>    };</p><p>    /**</p><p>     * \@internal</p><p>     * @return {?}</p><p>     */</p><p>    AbstractControl.prototype._anyControlsDirty = function () {</p><p>        return this._anyControls(function (control) { return control.dirty; });</p><p>    };</p><p>    /**</p><p>     * \@internal</p><p>     * @return {?}</p><p>     */</p><p>    AbstractControl.prototype._anyControlsTouched = function () {</p><p>        return this._anyControls(function (control) { return control.touched; });</p><p>    };</p><p>    /**</p><p>     * \@internal</p><p>     * @param {?=} opts</p><p>     * @return {?}</p><p>     */</p><p>    AbstractControl.prototype._updatePristine = function (opts) {</p><p>        if (opts === void 0) { opts = {}; }</p><p>        this._pristine = !this._anyControlsDirty();</p><p>        if (this._parent && !opts.onlySelf) {</p><p>            this._parent._updatePristine(opts);</p><p>        }</p><p>    };</p><p>    /**</p><p>     * \@internal</p><p>     * @param {?=} opts</p><p>     * @return {?}</p><p>     */</p><p>    AbstractControl.prototype._updateTouched = function (opts) {</p><p>        if (opts === void 0) { opts = {}; }</p><p>        this._touched = this._anyControlsTouched();</p><p>        if (this._parent && !opts.onlySelf) {</p><p>            this._parent._updateTouched(opts);</p><p>        }</p><p>    };</p><p>    /**</p><p>     * \@internal</p><p>     * @param {?} formState</p><p>     * @return {?}</p><p>     */</p><p>    AbstractControl.prototype._isBoxedValue = function (formState) {</p><p>        return typeof formState === 'object' && formState !== null &&</p><p>            Object.keys(formState).length === 2 && 'value' in formState && 'disabled' in formState;</p><p>    };</p><p>    /**</p><p>     * \@internal</p><p>     * @param {?} fn</p><p>     * @return {?}</p><p>     */</p><p>    AbstractControl.prototype._registerOnCollectionChange = function (fn) { this._onCollectionChange = fn; };</p><p>    return AbstractControl;</p><p>}());</p><p>/**</p><p> * \@whatItDoes Tracks the value and validation status of an individual form control.</p><p> *</p><p> * It is one of the three fundamental building blocks of Angular forms, along with</p><p> * {\@link FormGroup} and {\@link FormArray}.</p><p> *</p><p> * \@howToUse</p><p> *</p><p> * When instantiating a {\@link FormControl}, you can pass in an initial value as the</p><p> * first argument. Example:</p><p> *</p><p> * ```ts</p><p> * const ctrl = new FormControl('some value');</p><p> * console.log(ctrl.value);     // 'some value'</p><p> * ```</p><p> *</p><p> * You can also initialize the control with a form state object on instantiation,</p><p> * which includes both the value and whether or not the control is disabled.</p><p> * You can't use the value key without the disabled key; both are required</p><p> * to use this way of initialization.</p><p> *</p><p> * ```ts</p><p> * const ctrl = new FormControl({value: 'n/a', disabled: true});</p><p> * console.log(ctrl.value);     // 'n/a'</p><p> * console.log(ctrl.status);   // 'DISABLED'</p><p> * ```</p><p> *</p><p> * To include a sync validator (or an array of sync validators) with the control,</p><p> * pass it in as the second argument. Async validators are also supported, but</p><p> * have to be passed in separately as the third arg.</p><p> *</p><p> * ```ts</p><p> * const ctrl = new FormControl('', Validators.required);</p><p> * console.log(ctrl.value);     // ''</p><p> * console.log(ctrl.status);   // 'INVALID'</p><p> * ```</p><p> *</p><p> * See its superclass, {\@link AbstractControl}, for more properties and methods.</p><p> *</p><p> * * **npm package**: `\@angular/forms`</p><p> *</p><p> * \@stable</p><p> */</p><p>var FormControl = (function (_super) {</p><p>    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](FormControl, _super);</p><p>    /**</p><p>     * @param {?=} formState</p><p>     * @param {?=} validator</p><p>     * @param {?=} asyncValidator</p><p>     */</p><p>    function FormControl(formState, validator, asyncValidator) {</p><p>        if (formState === void 0) { formState = null; }</p><p>        var _this = _super.call(this, coerceToValidator(validator), coerceToAsyncValidator(asyncValidator)) || this;</p><p>        /**</p><p>         * \@internal</p><p>         */</p><p>        _this._onChange = [];</p><p>        _this._applyFormState(formState);</p><p>        _this.updateValueAndValidity({ onlySelf: true, emitEvent: false });</p><p>        _this._initObservables();</p><p>        return _this;</p><p>    }</p><p>    /**</p><p>     * Set the value of the form control to `value`.</p><p>     *</p><p>     * If `onlySelf` is `true`, this change will only affect the validation of this `FormControl`</p><p>     * and not its parent component. This defaults to false.</p><p>     *</p><p>     * If `emitEvent` is `true`, this</p><p>     * change will cause a `valueChanges` event on the `FormControl` to be emitted. This defaults</p><p>     * to true (as it falls through to `updateValueAndValidity`).</p><p>     *</p><p>     * If `emitModelToViewChange` is `true`, the view will be notified about the new value</p><p>     * via an `onChange` event. This is the default behavior if `emitModelToViewChange` is not</p><p>     * specified.</p><p>     *</p><p>     * If `emitViewToModelChange` is `true`, an ngModelChange event will be fired to update the</p><p>     * model.  This is the default behavior if `emitViewToModelChange` is not specified.</p><p>     * @param {?} value</p><p>     * @param {?=} options</p><p>     * @return {?}</p><p>     */</p><p>    FormControl.prototype.setValue = function (value, options) {</p><p>        var _this = this;</p><p>        if (options === void 0) { options = {}; }</p><p>        this._value = value;</p><p>        if (this._onChange.length && options.emitModelToViewChange !== false) {</p><p>            this._onChange.forEach(function (changeFn) { return changeFn(_this._value, options.emitViewToModelChange !== false); });</p><p>        }</p><p>        this.updateValueAndValidity(options);</p><p>    };</p><p>    /**</p><p>     * Patches the value of a control.</p><p>     *</p><p>     * This function is functionally the same as {\@link FormControl#setValue} at this level.</p><p>     * It exists for symmetry with {\@link FormGroup#patchValue} on `FormGroups` and `FormArrays`,</p><p>     * where it does behave differently.</p><p>     * @param {?} value</p><p>     * @param {?=} options</p><p>     * @return {?}</p><p>     */</p><p>    FormControl.prototype.patchValue = function (value, options) {</p><p>        if (options === void 0) { options = {}; }</p><p>        this.setValue(value, options);</p><p>    };</p><p>    /**</p><p>     * Resets the form control. This means by default:</p><p>     *</p><p>     * * it is marked as `pristine`</p><p>     * * it is marked as `untouched`</p><p>     * * value is set to null</p><p>     *</p><p>     * You can also reset to a specific form state by passing through a standalone</p><p>     * value or a form state object that contains both a value and a disabled state</p><p>     * (these are the only two properties that cannot be calculated).</p><p>     *</p><p>     * Ex:</p><p>     *</p><p>     * ```ts</p><p>     * this.control.reset('Nancy');</p><p>     *</p><p>     * console.log(this.control.value);  // 'Nancy'</p><p>     * ```</p><p>     *</p><p>     * OR</p><p>     *</p><p>     * ```</p><p>     * this.control.reset({value: 'Nancy', disabled: true});</p><p>     *</p><p>     * console.log(this.control.value);  // 'Nancy'</p><p>     * console.log(this.control.status);  // 'DISABLED'</p><p>     * ```</p><p>     * @param {?=} formState</p><p>     * @param {?=} options</p><p>     * @return {?}</p><p>     */</p><p>    FormControl.prototype.reset = function (formState, options) {</p><p>        if (formState === void 0) { formState = null; }</p><p>        if (options === void 0) { options = {}; }</p><p>        this._applyFormState(formState);</p><p>        this.markAsPristine(options);</p><p>        this.markAsUntouched(options);</p><p>        this.setValue(this._value, options);</p><p>    };</p><p>    /**</p><p>     * \@internal</p><p>     * @return {?}</p><p>     */</p><p>    FormControl.prototype._updateValue = function () { };</p><p>    /**</p><p>     * \@internal</p><p>     * @param {?} condition</p><p>     * @return {?}</p><p>     */</p><p>    FormControl.prototype._anyControls = function (condition) { return false; };</p><p>    /**</p><p>     * \@internal</p><p>     * @return {?}</p><p>     */</p><p>    FormControl.prototype._allControlsDisabled = function () { return this.disabled; };</p><p>    /**</p><p>     * Register a listener for change events.</p><p>     * @param {?} fn</p><p>     * @return {?}</p><p>     */</p><p>    FormControl.prototype.registerOnChange = function (fn) { this._onChange.push(fn); };</p><p>    /**</p><p>     * \@internal</p><p>     * @return {?}</p><p>     */</p><p>    FormControl.prototype._clearChangeFns = function () {</p><p>        this._onChange = [];</p><p>        this._onDisabledChange = [];</p><p>        this._onCollectionChange = function () { };</p><p>    };</p><p>    /**</p><p>     * Register a listener for disabled events.</p><p>     * @param {?} fn</p><p>     * @return {?}</p><p>     */</p><p>    FormControl.prototype.registerOnDisabledChange = function (fn) {</p><p>        this._onDisabledChange.push(fn);</p><p>    };</p><p>    /**</p><p>     * \@internal</p><p>     * @param {?} cb</p><p>     * @return {?}</p><p>     */</p><p>    FormControl.prototype._forEachChild = function (cb) { };</p><p>    /**</p><p>     * @param {?} formState</p><p>     * @return {?}</p><p>     */</p><p>    FormControl.prototype._applyFormState = function (formState) {</p><p>        if (this._isBoxedValue(formState)) {</p><p>            this._value = formState.value;</p><p>            formState.disabled ? this.disable({ onlySelf: true, emitEvent: false }) :</p><p>                this.enable({ onlySelf: true, emitEvent: false });</p><p>        }</p><p>        else {</p><p>            this._value = formState;</p><p>        }</p><p>    };</p><p>    return FormControl;</p><p>}(AbstractControl));</p><p>/**</p><p> * \@whatItDoes Tracks the value and validity state of a group of {\@link FormControl}</p><p> * instances.</p><p> *</p><p> * A `FormGroup` aggregates the values of each child {\@link FormControl} into one object,</p><p> * with each control name as the key.  It calculates its status by reducing the statuses</p><p> * of its children. For example, if one of the controls in a group is invalid, the entire</p><p> * group becomes invalid.</p><p> *</p><p> * `FormGroup` is one of the three fundamental building blocks used to define forms in Angular,</p><p> * along with {\@link FormControl} and {\@link FormArray}.</p><p> *</p><p> * \@howToUse</p><p> *</p><p> * When instantiating a {\@link FormGroup}, pass in a collection of child controls as the first</p><p> * argument. The key for each child will be the name under which it is registered.</p><p> *</p><p> * ### Example</p><p> *</p><p> * ```</p><p> * const form = new FormGroup({</p><p> *   first: new FormControl('Nancy', Validators.minLength(2)),</p><p> *   last: new FormControl('Drew'),</p><p> * });</p><p> *</p><p> * console.log(form.value);   // {first: 'Nancy', last; 'Drew'}</p><p> * console.log(form.status);  // 'VALID'</p><p> * ```</p><p> *</p><p> * You can also include group-level validators as the second arg, or group-level async</p><p> * validators as the third arg. These come in handy when you want to perform validation</p><p> * that considers the value of more than one child control.</p><p> *</p><p> * ### Example</p><p> *</p><p> * ```</p><p> * const form = new FormGroup({</p><p> *   password: new FormControl('', Validators.minLength(2)),</p><p> *   passwordConfirm: new FormControl('', Validators.minLength(2)),</p><p> * }, passwordMatchValidator);</p><p> *</p><p> *</p><p> * function passwordMatchValidator(g: FormGroup) {</p><p> *    return g.get('password').value === g.get('passwordConfirm').value</p><p> *       ? null : {'mismatch': true};</p><p> * }</p><p> * ```</p><p> *</p><p> * * **npm package**: `\@angular/forms`</p><p> *</p><p> * \@stable</p><p> */</p><p>var FormGroup = (function (_super) {</p><p>    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](FormGroup, _super);</p><p>    /**</p><p>     * @param {?} controls</p><p>     * @param {?=} validator</p><p>     * @param {?=} asyncValidator</p><p>     */</p><p>    function FormGroup(controls, validator, asyncValidator) {</p><p>        var _this = _super.call(this, validator || null, asyncValidator || null) || this;</p><p>        _this.controls = controls;</p><p>        _this._initObservables();</p><p>        _this._setUpControls();</p><p>        _this.updateValueAndValidity({ onlySelf: true, emitEvent: false });</p><p>        return _this;</p><p>    }</p><p>    /**</p><p>     * Registers a control with the group's list of controls.</p><p>     *</p><p>     * This method does not update value or validity of the control, so for</p><p>     * most cases you'll want to use {\@link FormGroup#addControl} instead.</p><p>     * @param {?} name</p><p>     * @param {?} control</p><p>     * @return {?}</p><p>     */</p><p>    FormGroup.prototype.registerControl = function (name, control) {</p><p>        if (this.controls[name])</p><p>            return this.controls[name];</p><p>        this.controls[name] = control;</p><p>        control.setParent(this);</p><p>        control._registerOnCollectionChange(this._onCollectionChange);</p><p>        return control;</p><p>    };</p><p>    /**</p><p>     * Add a control to this group.</p><p>     * @param {?} name</p><p>     * @param {?} control</p><p>     * @return {?}</p><p>     */</p><p>    FormGroup.prototype.addControl = function (name, control) {</p><p>        this.registerControl(name, control);</p><p>        this.updateValueAndValidity();</p><p>        this._onCollectionChange();</p><p>    };</p><p>    /**</p><p>     * Remove a control from this group.</p><p>     * @param {?} name</p><p>     * @return {?}</p><p>     */</p><p>    FormGroup.prototype.removeControl = function (name) {</p><p>        if (this.controls[name])</p><p>            this.controls[name]._registerOnCollectionChange(function () { });</p><p>        delete (this.controls[name]);</p><p>        this.updateValueAndValidity();</p><p>        this._onCollectionChange();</p><p>    };</p><p>    /**</p><p>     * Replace an existing control.</p><p>     * @param {?} name</p><p>     * @param {?} control</p><p>     * @return {?}</p><p>     */</p><p>    FormGroup.prototype.setControl = function (name, control) {</p><p>        if (this.controls[name])</p><p>            this.controls[name]._registerOnCollectionChange(function () { });</p><p>        delete (this.controls[name]);</p><p>        if (control)</p><p>            this.registerControl(name, control);</p><p>        this.updateValueAndValidity();</p><p>        this._onCollectionChange();</p><p>    };</p><p>    /**</p><p>     * Check whether there is an enabled control with the given name in the group.</p><p>     *</p><p>     * It will return false for disabled controls. If you'd like to check for</p><p>     * existence in the group only, use {\@link AbstractControl#get} instead.</p><p>     * @param {?} controlName</p><p>     * @return {?}</p><p>     */</p><p>    FormGroup.prototype.contains = function (controlName) {</p><p>        return this.controls.hasOwnProperty(controlName) && this.controls[controlName].enabled;</p><p>    };</p><p>    /**</p><p>     *  Sets the value of the {\@link FormGroup}. It accepts an object that matches</p><p>     *  the structure of the group, with control names as keys.</p><p>     *</p><p>     * This method performs strict checks, so it will throw an error if you try</p><p>     * to set the value of a control that doesn't exist or if you exclude the</p><p>     * value of a control.</p><p>     *</p><p>     *  ### Example</p><p>     *</p><p>     *  ```</p><p>     *  const form = new FormGroup({</p><p>     *     first: new FormControl(),</p><p>     *     last: new FormControl()</p><p>     *  });</p><p>     *  console.log(form.value);   // {first: null, last: null}</p><p>     *</p><p>     *  form.setValue({first: 'Nancy', last: 'Drew'});</p><p>     *  console.log(form.value);   // {first: 'Nancy', last: 'Drew'}</p><p>     *</p><p>     *  ```</p><p>     * @param {?} value</p><p>     * @param {?=} options</p><p>     * @return {?}</p><p>     */</p><p>    FormGroup.prototype.setValue = function (value, options) {</p><p>        var _this = this;</p><p>        if (options === void 0) { options = {}; }</p><p>        this._checkAllValuesPresent(value);</p><p>        Object.keys(value).forEach(function (name) {</p><p>            _this._throwIfControlMissing(name);</p><p>            _this.controls[name].setValue(value[name], { onlySelf: true, emitEvent: options.emitEvent });</p><p>        });</p><p>        this.updateValueAndValidity(options);</p><p>    };</p><p>    /**</p><p>     *  Patches the value of the {\@link FormGroup}. It accepts an object with control</p><p>     *  names as keys, and will do its best to match the values to the correct controls</p><p>     *  in the group.</p><p>     *</p><p>     *  It accepts both super-sets and sub-sets of the group without throwing an error.</p><p>     *</p><p>     *  ### Example</p><p>     *</p><p>     *  ```</p><p>     *  const form = new FormGroup({</p><p>     *     first: new FormControl(),</p><p>     *     last: new FormControl()</p><p>     *  });</p><p>     *  console.log(form.value);   // {first: null, last: null}</p><p>     *</p><p>     *  form.patchValue({first: 'Nancy'});</p><p>     *  console.log(form.value);   // {first: 'Nancy', last: null}</p><p>     *</p><p>     *  ```</p><p>     * @param {?} value</p><p>     * @param {?=} options</p><p>     * @return {?}</p><p>     */</p><p>    FormGroup.prototype.patchValue = function (value, options) {</p><p>        var _this = this;</p><p>        if (options === void 0) { options = {}; }</p><p>        Object.keys(value).forEach(function (name) {</p><p>            if (_this.controls[name]) {</p><p>                _this.controls[name].patchValue(value[name], { onlySelf: true, emitEvent: options.emitEvent });</p><p>            }</p><p>        });</p><p>        this.updateValueAndValidity(options);</p><p>    };</p><p>    /**</p><p>     * Resets the {\@link FormGroup}. This means by default:</p><p>     *</p><p>     * * The group and all descendants are marked `pristine`</p><p>     * * The group and all descendants are marked `untouched`</p><p>     * * The value of all descendants will be null or null maps</p><p>     *</p><p>     * You can also reset to a specific form state by passing in a map of states</p><p>     * that matches the structure of your form, with control names as keys. The state</p><p>     * can be a standalone value or a form state object with both a value and a disabled</p><p>     * status.</p><p>     *</p><p>     * ### Example</p><p>     *</p><p>     * ```ts</p><p>     * this.form.reset({first: 'name', last: 'last name'});</p><p>     *</p><p>     * console.log(this.form.value);  // {first: 'name', last: 'last name'}</p><p>     * ```</p><p>     *</p><p>     * - OR -</p><p>     *</p><p>     * ```</p><p>     * this.form.reset({</p><p>     *   first: {value: 'name', disabled: true},</p><p>     *   last: 'last'</p><p>     * });</p><p>     *</p><p>     * console.log(this.form.value);  // {first: 'name', last: 'last name'}</p><p>     * console.log(this.form.get('first').status);  // 'DISABLED'</p><p>     * ```</p><p>     * @param {?=} value</p><p>     * @param {?=} options</p><p>     * @return {?}</p><p>     */</p><p>    FormGroup.prototype.reset = function (value, options) {</p><p>        if (value === void 0) { value = {}; }</p><p>        if (options === void 0) { options = {}; }</p><p>        this._forEachChild(function (control, name) {</p><p>            control.reset(value[name], { onlySelf: true, emitEvent: options.emitEvent });</p><p>        });</p><p>        this.updateValueAndValidity(options);</p><p>        this._updatePristine(options);</p><p>        this._updateTouched(options);</p><p>    };</p><p>    /**</p><p>     * The aggregate value of the {\@link FormGroup}, including any disabled controls.</p><p>     *</p><p>     * If you'd like to include all values regardless of disabled status, use this method.</p><p>     * Otherwise, the `value` property is the best way to get the value of the group.</p><p>     * @return {?}</p><p>     */</p><p>    FormGroup.prototype.getRawValue = function () {</p><p>        return this._reduceChildren({}, function (acc, control, name) {</p><p>            acc[name] = control instanceof FormControl ? control.value : ((control)).getRawValue();</p><p>            return acc;</p><p>        });</p><p>    };</p><p>    /**</p><p>     * \@internal</p><p>     * @param {?} name</p><p>     * @return {?}</p><p>     */</p><p>    FormGroup.prototype._throwIfControlMissing = function (name) {</p><p>        if (!Object.keys(this.controls).length) {</p><p>            throw new Error("\n        There are no form controls registered with this group yet.  If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      ");</p><p>        }</p><p>        if (!this.controls[name]) {</p><p>            throw new Error("Cannot find form control with name: " + name + ".");</p><p>        }</p><p>    };</p><p>    /**</p><p>     * \@internal</p><p>     * @param {?} cb</p><p>     * @return {?}</p><p>     */</p><p>    FormGroup.prototype._forEachChild = function (cb) {</p><p>        var _this = this;</p><p>        Object.keys(this.controls).forEach(function (k) { return cb(_this.controls[k], k); });</p><p>    };</p><p>    /**</p><p>     * \@internal</p><p>     * @return {?}</p><p>     */</p><p>    FormGroup.prototype._setUpControls = function () {</p><p>        var _this = this;</p><p>        this._forEachChild(function (control) {</p><p>            control.setParent(_this);</p><p>            control._registerOnCollectionChange(_this._onCollectionChange);</p><p>        });</p><p>    };</p><p>    /**</p><p>     * \@internal</p><p>     * @return {?}</p><p>     */</p><p>    FormGroup.prototype._updateValue = function () { this._value = this._reduceValue(); };</p><p>    /**</p><p>     * \@internal</p><p>     * @param {?} condition</p><p>     * @return {?}</p><p>     */</p><p>    FormGroup.prototype._anyControls = function (condition) {</p><p>        var _this = this;</p><p>        var /** @type {?} */ res = false;</p><p>        this._forEachChild(function (control, name) {</p><p>            res = res || (_this.contains(name) && condition(control));</p><p>        });</p><p>        return res;</p><p>    };</p><p>    /**</p><p>     * \@internal</p><p>     * @return {?}</p><p>     */</p><p>    FormGroup.prototype._reduceValue = function () {</p><p>        var _this = this;</p><p>        return this._reduceChildren({}, function (acc, control, name) {</p><p>            if (control.enabled || _this.disabled) {</p><p>                acc[name] = control.value;</p><p>            }</p><p>            return acc;</p><p>        });</p><p>    };</p><p>    /**</p><p>     * \@internal</p><p>     * @param {?} initValue</p><p>     * @param {?} fn</p><p>     * @return {?}</p><p>     */</p><p>    FormGroup.prototype._reduceChildren = function (initValue, fn) {</p><p>        var /** @type {?} */ res = initValue;</p><p>        this._forEachChild(function (control, name) { res = fn(res, control, name); });</p><p>        return res;</p><p>    };</p><p>    /**</p><p>     * \@internal</p><p>     * @return {?}</p><p>     */</p><p>    FormGroup.prototype._allControlsDisabled = function () {</p><p>        for (var _i = 0, _a = Object.keys(this.controls); _i < _a.length; _i++) {</p><p>            var controlName = _a[_i];</p><p>            if (this.controls[controlName].enabled) {</p><p>                return false;</p><p>            }</p><p>        }</p><p>        return Object.keys(this.controls).length > 0 || this.disabled;</p><p>    };</p><p>    /**</p><p>     * \@internal</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    FormGroup.prototype._checkAllValuesPresent = function (value) {</p><p>        this._forEachChild(function (control, name) {</p><p>            if (value[name] === undefined) {</p><p>                throw new Error("Must supply a value for form control with name: '" + name + "'.");</p><p>            }</p><p>        });</p><p>    };</p><p>    return FormGroup;</p><p>}(AbstractControl));</p><p>/**</p><p> * \@whatItDoes Tracks the value and validity state of an array of {\@link FormControl},</p><p> * {\@link FormGroup} or {\@link FormArray} instances.</p><p> *</p><p> * A `FormArray` aggregates the values of each child {\@link FormControl} into an array.</p><p> * It calculates its status by reducing the statuses of its children. For example, if one of</p><p> * the controls in a `FormArray` is invalid, the entire array becomes invalid.</p><p> *</p><p> * `FormArray` is one of the three fundamental building blocks used to define forms in Angular,</p><p> * along with {\@link FormControl} and {\@link FormGroup}.</p><p> *</p><p> * \@howToUse</p><p> *</p><p> * When instantiating a {\@link FormArray}, pass in an array of child controls as the first</p><p> * argument.</p><p> *</p><p> * ### Example</p><p> *</p><p> * ```</p><p> * const arr = new FormArray([</p><p> *   new FormControl('Nancy', Validators.minLength(2)),</p><p> *   new FormControl('Drew'),</p><p> * ]);</p><p> *</p><p> * console.log(arr.value);   // ['Nancy', 'Drew']</p><p> * console.log(arr.status);  // 'VALID'</p><p> * ```</p><p> *</p><p> * You can also include array-level validators as the second arg, or array-level async</p><p> * validators as the third arg. These come in handy when you want to perform validation</p><p> * that considers the value of more than one child control.</p><p> *</p><p> * ### Adding or removing controls</p><p> *</p><p> * To change the controls in the array, use the `push`, `insert`, or `removeAt` methods</p><p> * in `FormArray` itself. These methods ensure the controls are properly tracked in the</p><p> * form's hierarchy. Do not modify the array of `AbstractControl`s used to instantiate</p><p> * the `FormArray` directly, as that will result in strange and unexpected behavior such</p><p> * as broken change detection.</p><p> *</p><p> * * **npm package**: `\@angular/forms`</p><p> *</p><p> * \@stable</p><p> */</p><p>var FormArray = (function (_super) {</p><p>    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](FormArray, _super);</p><p>    /**</p><p>     * @param {?} controls</p><p>     * @param {?=} validator</p><p>     * @param {?=} asyncValidator</p><p>     */</p><p>    function FormArray(controls, validator, asyncValidator) {</p><p>        var _this = _super.call(this, validator || null, asyncValidator || null) || this;</p><p>        _this.controls = controls;</p><p>        _this._initObservables();</p><p>        _this._setUpControls();</p><p>        _this.updateValueAndValidity({ onlySelf: true, emitEvent: false });</p><p>        return _this;</p><p>    }</p><p>    /**</p><p>     * Get the {\@link AbstractControl} at the given `index` in the array.</p><p>     * @param {?} index</p><p>     * @return {?}</p><p>     */</p><p>    FormArray.prototype.at = function (index) { return this.controls[index]; };</p><p>    /**</p><p>     * Insert a new {\@link AbstractControl} at the end of the array.</p><p>     * @param {?} control</p><p>     * @return {?}</p><p>     */</p><p>    FormArray.prototype.push = function (control) {</p><p>        this.controls.push(control);</p><p>        this._registerControl(control);</p><p>        this.updateValueAndValidity();</p><p>        this._onCollectionChange();</p><p>    };</p><p>    /**</p><p>     * Insert a new {\@link AbstractControl} at the given `index` in the array.</p><p>     * @param {?} index</p><p>     * @param {?} control</p><p>     * @return {?}</p><p>     */</p><p>    FormArray.prototype.insert = function (index, control) {</p><p>        this.controls.splice(index, 0, control);</p><p>        this._registerControl(control);</p><p>        this.updateValueAndValidity();</p><p>        this._onCollectionChange();</p><p>    };</p><p>    /**</p><p>     * Remove the control at the given `index` in the array.</p><p>     * @param {?} index</p><p>     * @return {?}</p><p>     */</p><p>    FormArray.prototype.removeAt = function (index) {</p><p>        if (this.controls[index])</p><p>            this.controls[index]._registerOnCollectionChange(function () { });</p><p>        this.controls.splice(index, 1);</p><p>        this.updateValueAndValidity();</p><p>        this._onCollectionChange();</p><p>    };</p><p>    /**</p><p>     * Replace an existing control.</p><p>     * @param {?} index</p><p>     * @param {?} control</p><p>     * @return {?}</p><p>     */</p><p>    FormArray.prototype.setControl = function (index, control) {</p><p>        if (this.controls[index])</p><p>            this.controls[index]._registerOnCollectionChange(function () { });</p><p>        this.controls.splice(index, 1);</p><p>        if (control) {</p><p>            this.controls.splice(index, 0, control);</p><p>            this._registerControl(control);</p><p>        }</p><p>        this.updateValueAndValidity();</p><p>        this._onCollectionChange();</p><p>    };</p><p>    Object.defineProperty(FormArray.prototype, "length", {</p><p>        /**</p><p>         * Length of the control array.</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this.controls.length; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    /**</p><p>     *  Sets the value of the {\@link FormArray}. It accepts an array that matches</p><p>     *  the structure of the control.</p><p>     *</p><p>     * This method performs strict checks, so it will throw an error if you try</p><p>     * to set the value of a control that doesn't exist or if you exclude the</p><p>     * value of a control.</p><p>     *</p><p>     *  ### Example</p><p>     *</p><p>     *  ```</p><p>     *  const arr = new FormArray([</p><p>     *     new FormControl(),</p><p>     *     new FormControl()</p><p>     *  ]);</p><p>     *  console.log(arr.value);   // [null, null]</p><p>     *</p><p>     *  arr.setValue(['Nancy', 'Drew']);</p><p>     *  console.log(arr.value);   // ['Nancy', 'Drew']</p><p>     *  ```</p><p>     * @param {?} value</p><p>     * @param {?=} options</p><p>     * @return {?}</p><p>     */</p><p>    FormArray.prototype.setValue = function (value, options) {</p><p>        var _this = this;</p><p>        if (options === void 0) { options = {}; }</p><p>        this._checkAllValuesPresent(value);</p><p>        value.forEach(function (newValue, index) {</p><p>            _this._throwIfControlMissing(index);</p><p>            _this.at(index).setValue(newValue, { onlySelf: true, emitEvent: options.emitEvent });</p><p>        });</p><p>        this.updateValueAndValidity(options);</p><p>    };</p><p>    /**</p><p>     *  Patches the value of the {\@link FormArray}. It accepts an array that matches the</p><p>     *  structure of the control, and will do its best to match the values to the correct</p><p>     *  controls in the group.</p><p>     *</p><p>     *  It accepts both super-sets and sub-sets of the array without throwing an error.</p><p>     *</p><p>     *  ### Example</p><p>     *</p><p>     *  ```</p><p>     *  const arr = new FormArray([</p><p>     *     new FormControl(),</p><p>     *     new FormControl()</p><p>     *  ]);</p><p>     *  console.log(arr.value);   // [null, null]</p><p>     *</p><p>     *  arr.patchValue(['Nancy']);</p><p>     *  console.log(arr.value);   // ['Nancy', null]</p><p>     *  ```</p><p>     * @param {?} value</p><p>     * @param {?=} options</p><p>     * @return {?}</p><p>     */</p><p>    FormArray.prototype.patchValue = function (value, options) {</p><p>        var _this = this;</p><p>        if (options === void 0) { options = {}; }</p><p>        value.forEach(function (newValue, index) {</p><p>            if (_this.at(index)) {</p><p>                _this.at(index).patchValue(newValue, { onlySelf: true, emitEvent: options.emitEvent });</p><p>            }</p><p>        });</p><p>        this.updateValueAndValidity(options);</p><p>    };</p><p>    /**</p><p>     * Resets the {\@link FormArray}. This means by default:</p><p>     *</p><p>     * * The array and all descendants are marked `pristine`</p><p>     * * The array and all descendants are marked `untouched`</p><p>     * * The value of all descendants will be null or null maps</p><p>     *</p><p>     * You can also reset to a specific form state by passing in an array of states</p><p>     * that matches the structure of the control. The state can be a standalone value</p><p>     * or a form state object with both a value and a disabled status.</p><p>     *</p><p>     * ### Example</p><p>     *</p><p>     * ```ts</p><p>     * this.arr.reset(['name', 'last name']);</p><p>     *</p><p>     * console.log(this.arr.value);  // ['name', 'last name']</p><p>     * ```</p><p>     *</p><p>     * - OR -</p><p>     *</p><p>     * ```</p><p>     * this.arr.reset([</p><p>     *   {value: 'name', disabled: true},</p><p>     *   'last'</p><p>     * ]);</p><p>     *</p><p>     * console.log(this.arr.value);  // ['name', 'last name']</p><p>     * console.log(this.arr.get(0).status);  // 'DISABLED'</p><p>     * ```</p><p>     * @param {?=} value</p><p>     * @param {?=} options</p><p>     * @return {?}</p><p>     */</p><p>    FormArray.prototype.reset = function (value, options) {</p><p>        if (value === void 0) { value = []; }</p><p>        if (options === void 0) { options = {}; }</p><p>        this._forEachChild(function (control, index) {</p><p>            control.reset(value[index], { onlySelf: true, emitEvent: options.emitEvent });</p><p>        });</p><p>        this.updateValueAndValidity(options);</p><p>        this._updatePristine(options);</p><p>        this._updateTouched(options);</p><p>    };</p><p>    /**</p><p>     * The aggregate value of the array, including any disabled controls.</p><p>     *</p><p>     * If you'd like to include all values regardless of disabled status, use this method.</p><p>     * Otherwise, the `value` property is the best way to get the value of the array.</p><p>     * @return {?}</p><p>     */</p><p>    FormArray.prototype.getRawValue = function () {</p><p>        return this.controls.map(function (control) {</p><p>            return control instanceof FormControl ? control.value : ((control)).getRawValue();</p><p>        });</p><p>    };</p><p>    /**</p><p>     * \@internal</p><p>     * @param {?} index</p><p>     * @return {?}</p><p>     */</p><p>    FormArray.prototype._throwIfControlMissing = function (index) {</p><p>        if (!this.controls.length) {</p><p>            throw new Error("\n        There are no form controls registered with this array yet.  If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      ");</p><p>        }</p><p>        if (!this.at(index)) {</p><p>            throw new Error("Cannot find form control at index " + index);</p><p>        }</p><p>    };</p><p>    /**</p><p>     * \@internal</p><p>     * @param {?} cb</p><p>     * @return {?}</p><p>     */</p><p>    FormArray.prototype._forEachChild = function (cb) {</p><p>        this.controls.forEach(function (control, index) { cb(control, index); });</p><p>    };</p><p>    /**</p><p>     * \@internal</p><p>     * @return {?}</p><p>     */</p><p>    FormArray.prototype._updateValue = function () {</p><p>        var _this = this;</p><p>        this._value = this.controls.filter(function (control) { return control.enabled || _this.disabled; })</p><p>            .map(function (control) { return control.value; });</p><p>    };</p><p>    /**</p><p>     * \@internal</p><p>     * @param {?} condition</p><p>     * @return {?}</p><p>     */</p><p>    FormArray.prototype._anyControls = function (condition) {</p><p>        return this.controls.some(function (control) { return control.enabled && condition(control); });</p><p>    };</p><p>    /**</p><p>     * \@internal</p><p>     * @return {?}</p><p>     */</p><p>    FormArray.prototype._setUpControls = function () {</p><p>        var _this = this;</p><p>        this._forEachChild(function (control) { return _this._registerControl(control); });</p><p>    };</p><p>    /**</p><p>     * \@internal</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    FormArray.prototype._checkAllValuesPresent = function (value) {</p><p>        this._forEachChild(function (control, i) {</p><p>            if (value[i] === undefined) {</p><p>                throw new Error("Must supply a value for form control at index: " + i + ".");</p><p>            }</p><p>        });</p><p>    };</p><p>    /**</p><p>     * \@internal</p><p>     * @return {?}</p><p>     */</p><p>    FormArray.prototype._allControlsDisabled = function () {</p><p>        for (var _i = 0, _a = this.controls; _i < _a.length; _i++) {</p><p>            var control = _a[_i];</p><p>            if (control.enabled)</p><p>                return false;</p><p>        }</p><p>        return this.controls.length > 0 || this.disabled;</p><p>    };</p><p>    /**</p><p>     * @param {?} control</p><p>     * @return {?}</p><p>     */</p><p>    FormArray.prototype._registerControl = function (control) {</p><p>        control.setParent(this);</p><p>        control._registerOnCollectionChange(this._onCollectionChange);</p><p>    };</p><p>    return FormArray;</p><p>}(AbstractControl));</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>var formDirectiveProvider = {</p><p>    provide: ControlContainer,</p><p>    useExisting: Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["forwardRef"])(function () { return NgForm; })</p><p>};</p><p>var resolvedPromise = Promise.resolve(null);</p><p>/**</p><p> * \@whatItDoes Creates a top-level {\@link FormGroup} instance and binds it to a form</p><p> * to track aggregate form value and validation status.</p><p> *</p><p> * \@howToUse</p><p> *</p><p> * As soon as you import the `FormsModule`, this directive becomes active by default on</p><p> * all `<form>` tags.  You don't need to add a special selector.</p><p> *</p><p> * You can export the directive into a local template variable using `ngForm` as the key</p><p> * (ex: `#myForm="ngForm"`). This is optional, but useful.  Many properties from the underlying</p><p> * {\@link FormGroup} instance are duplicated on the directive itself, so a reference to it</p><p> * will give you access to the aggregate value and validity status of the form, as well as</p><p> * user interaction properties like `dirty` and `touched`.</p><p> *</p><p> * To register child controls with the form, you'll want to use {\@link NgModel} with a</p><p> * `name` attribute.  You can also use {\@link NgModelGroup} if you'd like to create</p><p> * sub-groups within the form.</p><p> *</p><p> * You can listen to the directive's `ngSubmit` event to be notified when the user has</p><p> * triggered a form submission. The `ngSubmit` event will be emitted with the original form</p><p> * submission event.</p><p> *</p><p> * {\@example forms/ts/simpleForm/simple_form_example.ts region='Component'}</p><p> *</p><p> * * **npm package**: `\@angular/forms`</p><p> *</p><p> * * **NgModule**: `FormsModule`</p><p> *</p><p> *  \@stable</p><p> */</p><p>var NgForm = (function (_super) {</p><p>    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](NgForm, _super);</p><p>    /**</p><p>     * @param {?} validators</p><p>     * @param {?} asyncValidators</p><p>     */</p><p>    function NgForm(validators, asyncValidators) {</p><p>        var _this = _super.call(this) || this;</p><p>        _this._submitted = false;</p><p>        _this.ngSubmit = new __WEBPACK_IMPORTED_MODULE_1__angular_core__["EventEmitter"]();</p><p>        _this.form =</p><p>            new FormGroup({}, composeValidators(validators), composeAsyncValidators(asyncValidators));</p><p>        return _this;</p><p>    }</p><p>    Object.defineProperty(NgForm.prototype, "submitted", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this._submitted; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(NgForm.prototype, "formDirective", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(NgForm.prototype, "control", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this.form; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(NgForm.prototype, "path", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return []; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(NgForm.prototype, "controls", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this.form.controls; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    /**</p><p>     * @param {?} dir</p><p>     * @return {?}</p><p>     */</p><p>    NgForm.prototype.addControl = function (dir) {</p><p>        var _this = this;</p><p>        resolvedPromise.then(function () {</p><p>            var /** @type {?} */ container = _this._findContainer(dir.path);</p><p>            dir._control = (container.registerControl(dir.name, dir.control));</p><p>            setUpControl(dir.control, dir);</p><p>            dir.control.updateValueAndValidity({ emitEvent: false });</p><p>        });</p><p>    };</p><p>    /**</p><p>     * @param {?} dir</p><p>     * @return {?}</p><p>     */</p><p>    NgForm.prototype.getControl = function (dir) { return (this.form.get(dir.path)); };</p><p>    /**</p><p>     * @param {?} dir</p><p>     * @return {?}</p><p>     */</p><p>    NgForm.prototype.removeControl = function (dir) {</p><p>        var _this = this;</p><p>        resolvedPromise.then(function () {</p><p>            var /** @type {?} */ container = _this._findContainer(dir.path);</p><p>            if (container) {</p><p>                container.removeControl(dir.name);</p><p>            }</p><p>        });</p><p>    };</p><p>    /**</p><p>     * @param {?} dir</p><p>     * @return {?}</p><p>     */</p><p>    NgForm.prototype.addFormGroup = function (dir) {</p><p>        var _this = this;</p><p>        resolvedPromise.then(function () {</p><p>            var /** @type {?} */ container = _this._findContainer(dir.path);</p><p>            var /** @type {?} */ group = new FormGroup({});</p><p>            setUpFormContainer(group, dir);</p><p>            container.registerControl(dir.name, group);</p><p>            group.updateValueAndValidity({ emitEvent: false });</p><p>        });</p><p>    };</p><p>    /**</p><p>     * @param {?} dir</p><p>     * @return {?}</p><p>     */</p><p>    NgForm.prototype.removeFormGroup = function (dir) {</p><p>        var _this = this;</p><p>        resolvedPromise.then(function () {</p><p>            var /** @type {?} */ container = _this._findContainer(dir.path);</p><p>            if (container) {</p><p>                container.removeControl(dir.name);</p><p>            }</p><p>        });</p><p>    };</p><p>    /**</p><p>     * @param {?} dir</p><p>     * @return {?}</p><p>     */</p><p>    NgForm.prototype.getFormGroup = function (dir) { return (this.form.get(dir.path)); };</p><p>    /**</p><p>     * @param {?} dir</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    NgForm.prototype.updateModel = function (dir, value) {</p><p>        var _this = this;</p><p>        resolvedPromise.then(function () {</p><p>            var /** @type {?} */ ctrl = (_this.form.get(/** @type {?} */ ((dir.path))));</p><p>            ctrl.setValue(value);</p><p>        });</p><p>    };</p><p>    /**</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    NgForm.prototype.setValue = function (value) { this.control.setValue(value); };</p><p>    /**</p><p>     * @param {?} $event</p><p>     * @return {?}</p><p>     */</p><p>    NgForm.prototype.onSubmit = function ($event) {</p><p>        this._submitted = true;</p><p>        this.ngSubmit.emit($event);</p><p>        return false;</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    NgForm.prototype.onReset = function () { this.resetForm(); };</p><p>    /**</p><p>     * @param {?=} value</p><p>     * @return {?}</p><p>     */</p><p>    NgForm.prototype.resetForm = function (value) {</p><p>        if (value === void 0) { value = undefined; }</p><p>        this.form.reset(value);</p><p>        this._submitted = false;</p><p>    };</p><p>    /**</p><p>     * \@internal</p><p>     * @param {?} path</p><p>     * @return {?}</p><p>     */</p><p>    NgForm.prototype._findContainer = function (path) {</p><p>        path.pop();</p><p>        return path.length ? (this.form.get(path)) : this.form;</p><p>    };</p><p>    return NgForm;</p><p>}(ControlContainer));</p><p>NgForm.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Directive"], args: [{</p><p>                selector: 'form:not([ngNoForm]):not([formGroup]),ngForm,[ngForm]',</p><p>                providers: [formDirectiveProvider],</p><p>                host: { '(submit)': 'onSubmit($event)', '(reset)': 'onReset()' },</p><p>                outputs: ['ngSubmit'],</p><p>                exportAs: 'ngForm'</p><p>            },] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>NgForm.ctorParameters = function () { return [</p><p>    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Self"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Inject"], args: [NG_VALIDATORS,] },] },</p><p>    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Self"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Inject"], args: [NG_ASYNC_VALIDATORS,] },] },</p><p>]; };</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>var FormErrorExamples = {</p><p>    formControlName: "\n    <div [formGroup]=\"myGroup\">\n      <input formControlName=\"firstName\">\n    </div>\n\n    In your class:\n\n    this.myGroup = new FormGroup({\n       firstName: new FormControl()\n    });",</p><p>    formGroupName: "\n    <div [formGroup]=\"myGroup\">\n       <div formGroupName=\"person\">\n          <input formControlName=\"firstName\">\n       </div>\n    </div>\n\n    In your class:\n\n    this.myGroup = new FormGroup({\n       person: new FormGroup({ firstName: new FormControl() })\n    });",</p><p>    formArrayName: "\n    <div [formGroup]=\"myGroup\">\n      <div formArrayName=\"cities\">\n        <div *ngFor=\"let city of cityArray.controls; index as i\">\n          <input [formControlName]=\"i\">\n        </div>\n      </div>\n    </div>\n\n    In your class:\n\n    this.cityArray = new FormArray([new FormControl('SF')]);\n    this.myGroup = new FormGroup({\n      cities: this.cityArray\n    });",</p><p>    ngModelGroup: "\n    <form>\n       <div ngModelGroup=\"person\">\n          <input [(ngModel)]=\"person.name\" name=\"firstName\">\n       </div>\n    </form>",</p><p>    ngModelWithFormGroup: "\n    <div [formGroup]=\"myGroup\">\n       <input formControlName=\"firstName\">\n       <input [(ngModel)]=\"showMoreControls\" [ngModelOptions]=\"{standalone: true}\">\n    </div>\n  "</p><p>};</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>var TemplateDrivenErrors = (function () {</p><p>    function TemplateDrivenErrors() {</p><p>    }</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    TemplateDrivenErrors.modelParentException = function () {</p><p>        throw new Error("\n      ngModel cannot be used to register form controls with a parent formGroup directive.  Try using\n      formGroup's partner directive \"formControlName\" instead.  Example:\n\n      " + FormErrorExamples.formControlName + "\n\n      Or, if you'd like to avoid registering this form control, indicate that it's standalone in ngModelOptions:\n\n      Example:\n\n      " + FormErrorExamples.ngModelWithFormGroup);</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    TemplateDrivenErrors.formGroupNameException = function () {</p><p>        throw new Error("\n      ngModel cannot be used to register form controls with a parent formGroupName or formArrayName directive.\n\n      Option 1: Use formControlName instead of ngModel (reactive strategy):\n\n      " + FormErrorExamples.formGroupName + "\n\n      Option 2:  Update ngModel's parent be ngModelGroup (template-driven strategy):\n\n      " + FormErrorExamples.ngModelGroup);</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    TemplateDrivenErrors.missingNameException = function () {</p><p>        throw new Error("If ngModel is used within a form tag, either the name attribute must be set or the form\n      control must be defined as 'standalone' in ngModelOptions.\n\n      Example 1: <input [(ngModel)]=\"person.firstName\" name=\"first\">\n      Example 2: <input [(ngModel)]=\"person.firstName\" [ngModelOptions]=\"{standalone: true}\">");</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    TemplateDrivenErrors.modelGroupParentException = function () {</p><p>        throw new Error("\n      ngModelGroup cannot be used with a parent formGroup directive.\n\n      Option 1: Use formGroupName instead of ngModelGroup (reactive strategy):\n\n      " + FormErrorExamples.formGroupName + "\n\n      Option 2:  Use a regular form tag instead of the formGroup directive (template-driven strategy):\n\n      " + FormErrorExamples.ngModelGroup);</p><p>    };</p><p>    return TemplateDrivenErrors;</p><p>}());</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>var modelGroupProvider = {</p><p>    provide: ControlContainer,</p><p>    useExisting: Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["forwardRef"])(function () { return NgModelGroup; })</p><p>};</p><p>/**</p><p> * \@whatItDoes Creates and binds a {\@link FormGroup} instance to a DOM element.</p><p> *</p><p> * \@howToUse</p><p> *</p><p> * This directive can only be used as a child of {\@link NgForm} (or in other words,</p><p> * within `<form>` tags).</p><p> *</p><p> * Use this directive if you'd like to create a sub-group within a form. This can</p><p> * come in handy if you want to validate a sub-group of your form separately from</p><p> * the rest of your form, or if some values in your domain model make more sense to</p><p> * consume together in a nested object.</p><p> *</p><p> * Pass in the name you'd like this sub-group to have and it will become the key</p><p> * for the sub-group in the form's full value. You can also export the directive into</p><p> * a local template variable using `ngModelGroup` (ex: `#myGroup="ngModelGroup"`).</p><p> *</p><p> * {\@example forms/ts/ngModelGroup/ng_model_group_example.ts region='Component'}</p><p> *</p><p> * * **npm package**: `\@angular/forms`</p><p> *</p><p> * * **NgModule**: `FormsModule`</p><p> *</p><p> * \@stable</p><p> */</p><p>var NgModelGroup = (function (_super) {</p><p>    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](NgModelGroup, _super);</p><p>    /**</p><p>     * @param {?} parent</p><p>     * @param {?} validators</p><p>     * @param {?} asyncValidators</p><p>     */</p><p>    function NgModelGroup(parent, validators, asyncValidators) {</p><p>        var _this = _super.call(this) || this;</p><p>        _this._parent = parent;</p><p>        _this._validators = validators;</p><p>        _this._asyncValidators = asyncValidators;</p><p>        return _this;</p><p>    }</p><p>    /**</p><p>     * \@internal</p><p>     * @return {?}</p><p>     */</p><p>    NgModelGroup.prototype._checkParentType = function () {</p><p>        if (!(this._parent instanceof NgModelGroup) && !(this._parent instanceof NgForm)) {</p><p>            TemplateDrivenErrors.modelGroupParentException();</p><p>        }</p><p>    };</p><p>    return NgModelGroup;</p><p>}(AbstractFormGroupDirective));</p><p>NgModelGroup.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Directive"], args: [{ selector: '[ngModelGroup]', providers: [modelGroupProvider], exportAs: 'ngModelGroup' },] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>NgModelGroup.ctorParameters = function () { return [</p><p>    { type: ControlContainer, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Host"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["SkipSelf"] },] },</p><p>    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Self"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Inject"], args: [NG_VALIDATORS,] },] },</p><p>    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Self"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Inject"], args: [NG_ASYNC_VALIDATORS,] },] },</p><p>]; };</p><p>NgModelGroup.propDecorators = {</p><p>    'name': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"], args: ['ngModelGroup',] },],</p><p>};</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>var formControlBinding = {</p><p>    provide: NgControl,</p><p>    useExisting: Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["forwardRef"])(function () { return NgModel; })</p><p>};</p><p>/**</p><p> * `ngModel` forces an additional change detection run when its inputs change:</p><p> * E.g.:</p><p> * ```</p><p> * <div>{{myModel.valid}}</div></p><p> * <input [(ngModel)]="myValue" #myModel="ngModel"></p><p> * ```</p><p> * I.e. `ngModel` can export itself on the element and then be used in the template.</p><p> * Normally, this would result in expressions before the `input` that use the exported directive</p><p> * to have and old value as they have been</p><p> * dirty checked before. As this is a very common case for `ngModel`, we added this second change</p><p> * detection run.</p><p> *</p><p> * Notes:</p><p> * - this is just one extra run no matter how many `ngModel` have been changed.</p><p> * - this is a general problem when using `exportAs` for directives!</p><p> */</p><p>var resolvedPromise$1 = Promise.resolve(null);</p><p>/**</p><p> * \@whatItDoes Creates a {\@link FormControl} instance from a domain model and binds it</p><p> * to a form control element.</p><p> *</p><p> * The {\@link FormControl} instance will track the value, user interaction, and</p><p> * validation status of the control and keep the view synced with the model. If used</p><p> * within a parent form, the directive will also register itself with the form as a child</p><p> * control.</p><p> *</p><p> * \@howToUse</p><p> *</p><p> * This directive can be used by itself or as part of a larger form. All you need is the</p><p> * `ngModel` selector to activate it.</p><p> *</p><p> * It accepts a domain model as an optional {\@link Input}. If you have a one-way binding</p><p> * to `ngModel` with `[]` syntax, changing the value of the domain model in the component</p><p> * class will set the value in the view. If you have a two-way binding with `[()]` syntax</p><p> * (also known as 'banana-box syntax'), the value in the UI will always be synced back to</p><p> * the domain model in your class as well.</p><p> *</p><p> * If you wish to inspect the properties of the associated {\@link FormControl} (like</p><p> * validity state), you can also export the directive into a local template variable using</p><p> * `ngModel` as the key (ex: `#myVar="ngModel"`). You can then access the control using the</p><p> * directive's `control` property, but most properties you'll need (like `valid` and `dirty`)</p><p> * will fall through to the control anyway, so you can access them directly. You can see a</p><p> * full list of properties directly available in {\@link AbstractControlDirective}.</p><p> *</p><p> * The following is an example of a simple standalone control using `ngModel`:</p><p> *</p><p> * {\@example forms/ts/simpleNgModel/simple_ng_model_example.ts region='Component'}</p><p> *</p><p> * When using the `ngModel` within `<form>` tags, you'll also need to supply a `name` attribute</p><p> * so that the control can be registered with the parent form under that name.</p><p> *</p><p> * It's worth noting that in the context of a parent form, you often can skip one-way or</p><p> * two-way binding because the parent form will sync the value for you. You can access</p><p> * its properties by exporting it into a local template variable using `ngForm` (ex:</p><p> * `#f="ngForm"`). Then you can pass it where it needs to go on submit.</p><p> *</p><p> * If you do need to populate initial values into your form, using a one-way binding for</p><p> * `ngModel` tends to be sufficient as long as you use the exported form's value rather</p><p> * than the domain model's value on submit.</p><p> *</p><p> * Take a look at an example of using `ngModel` within a form:</p><p> *</p><p> * {\@example forms/ts/simpleForm/simple_form_example.ts region='Component'}</p><p> *</p><p> * To see `ngModel` examples with different form control types, see:</p><p> *</p><p> * * Radio buttons: {\@link RadioControlValueAccessor}</p><p> * * Selects: {\@link SelectControlValueAccessor}</p><p> *</p><p> * **npm package**: `\@angular/forms`</p><p> *</p><p> * **NgModule**: `FormsModule`</p><p> *</p><p> *  \@stable</p><p> */</p><p>var NgModel = (function (_super) {</p><p>    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](NgModel, _super);</p><p>    /**</p><p>     * @param {?} parent</p><p>     * @param {?} validators</p><p>     * @param {?} asyncValidators</p><p>     * @param {?} valueAccessors</p><p>     */</p><p>    function NgModel(parent, validators, asyncValidators, valueAccessors) {</p><p>        var _this = _super.call(this) || this;</p><p>        /**</p><p>         * \@internal</p><p>         */</p><p>        _this._control = new FormControl();</p><p>        /**</p><p>         * \@internal</p><p>         */</p><p>        _this._registered = false;</p><p>        _this.update = new __WEBPACK_IMPORTED_MODULE_1__angular_core__["EventEmitter"]();</p><p>        _this._parent = parent;</p><p>        _this._rawValidators = validators || [];</p><p>        _this._rawAsyncValidators = asyncValidators || [];</p><p>        _this.valueAccessor = selectValueAccessor(_this, valueAccessors);</p><p>        return _this;</p><p>    }</p><p>    /**</p><p>     * @param {?} changes</p><p>     * @return {?}</p><p>     */</p><p>    NgModel.prototype.ngOnChanges = function (changes) {</p><p>        this._checkForErrors();</p><p>        if (!this._registered)</p><p>            this._setUpControl();</p><p>        if ('isDisabled' in changes) {</p><p>            this._updateDisabled(changes);</p><p>        }</p><p>        if (isPropertyUpdated(changes, this.viewModel)) {</p><p>            this._updateValue(this.model);</p><p>            this.viewModel = this.model;</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    NgModel.prototype.ngOnDestroy = function () { this.formDirective && this.formDirective.removeControl(this); };</p><p>    Object.defineProperty(NgModel.prototype, "control", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this._control; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(NgModel.prototype, "path", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () {</p><p>            return this._parent ? controlPath(this.name, this._parent) : [this.name];</p><p>        },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(NgModel.prototype, "formDirective", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this._parent ? this._parent.formDirective : null; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(NgModel.prototype, "validator", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return composeValidators(this._rawValidators); },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(NgModel.prototype, "asyncValidator", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () {</p><p>            return composeAsyncValidators(this._rawAsyncValidators);</p><p>        },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    /**</p><p>     * @param {?} newValue</p><p>     * @return {?}</p><p>     */</p><p>    NgModel.prototype.viewToModelUpdate = function (newValue) {</p><p>        this.viewModel = newValue;</p><p>        this.update.emit(newValue);</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    NgModel.prototype._setUpControl = function () {</p><p>        this._isStandalone() ? this._setUpStandalone() :</p><p>            this.formDirective.addControl(this);</p><p>        this._registered = true;</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    NgModel.prototype._isStandalone = function () {</p><p>        return !this._parent || !!(this.options && this.options.standalone);</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    NgModel.prototype._setUpStandalone = function () {</p><p>        setUpControl(this._control, this);</p><p>        this._control.updateValueAndValidity({ emitEvent: false });</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    NgModel.prototype._checkForErrors = function () {</p><p>        if (!this._isStandalone()) {</p><p>            this._checkParentType();</p><p>        }</p><p>        this._checkName();</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    NgModel.prototype._checkParentType = function () {</p><p>        if (!(this._parent instanceof NgModelGroup) &&</p><p>            this._parent instanceof AbstractFormGroupDirective) {</p><p>            TemplateDrivenErrors.formGroupNameException();</p><p>        }</p><p>        else if (!(this._parent instanceof NgModelGroup) && !(this._parent instanceof NgForm)) {</p><p>            TemplateDrivenErrors.modelParentException();</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    NgModel.prototype._checkName = function () {</p><p>        if (this.options && this.options.name)</p><p>            this.name = this.options.name;</p><p>        if (!this._isStandalone() && !this.name) {</p><p>            TemplateDrivenErrors.missingNameException();</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    NgModel.prototype._updateValue = function (value) {</p><p>        var _this = this;</p><p>        resolvedPromise$1.then(function () { _this.control.setValue(value, { emitViewToModelChange: false }); });</p><p>    };</p><p>    /**</p><p>     * @param {?} changes</p><p>     * @return {?}</p><p>     */</p><p>    NgModel.prototype._updateDisabled = function (changes) {</p><p>        var _this = this;</p><p>        var /** @type {?} */ disabledValue = changes['isDisabled'].currentValue;</p><p>        var /** @type {?} */ isDisabled = disabledValue === '' || (disabledValue && disabledValue !== 'false');</p><p>        resolvedPromise$1.then(function () {</p><p>            if (isDisabled && !_this.control.disabled) {</p><p>                _this.control.disable();</p><p>            }</p><p>            else if (!isDisabled && _this.control.disabled) {</p><p>                _this.control.enable();</p><p>            }</p><p>        });</p><p>    };</p><p>    return NgModel;</p><p>}(NgControl));</p><p>NgModel.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Directive"], args: [{</p><p>                selector: '[ngModel]:not([formControlName]):not([formControl])',</p><p>                providers: [formControlBinding],</p><p>                exportAs: 'ngModel'</p><p>            },] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>NgModel.ctorParameters = function () { return [</p><p>    { type: ControlContainer, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Host"] },] },</p><p>    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Self"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Inject"], args: [NG_VALIDATORS,] },] },</p><p>    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Self"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Inject"], args: [NG_ASYNC_VALIDATORS,] },] },</p><p>    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Self"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Inject"], args: [NG_VALUE_ACCESSOR,] },] },</p><p>]; };</p><p>NgModel.propDecorators = {</p><p>    'name': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"] },],</p><p>    'isDisabled': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"], args: ['disabled',] },],</p><p>    'model': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"], args: ['ngModel',] },],</p><p>    'options': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"], args: ['ngModelOptions',] },],</p><p>    'update': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Output"], args: ['ngModelChange',] },],</p><p>};</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>var ReactiveErrors = (function () {</p><p>    function ReactiveErrors() {</p><p>    }</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    ReactiveErrors.controlParentException = function () {</p><p>        throw new Error("formControlName must be used with a parent formGroup directive.  You'll want to add a formGroup\n       directive and pass it an existing FormGroup instance (you can create one in your class).\n\n      Example:\n\n      " + FormErrorExamples.formControlName);</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    ReactiveErrors.ngModelGroupException = function () {</p><p>        throw new Error("formControlName cannot be used with an ngModelGroup parent. It is only compatible with parents\n       that also have a \"form\" prefix: formGroupName, formArrayName, or formGroup.\n\n       Option 1:  Update the parent to be formGroupName (reactive form strategy)\n\n        " + FormErrorExamples.formGroupName + "\n\n        Option 2: Use ngModel instead of formControlName (template-driven strategy)\n\n        " + FormErrorExamples.ngModelGroup);</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    ReactiveErrors.missingFormException = function () {</p><p>        throw new Error("formGroup expects a FormGroup instance. Please pass one in.\n\n       Example:\n\n       " + FormErrorExamples.formControlName);</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    ReactiveErrors.groupParentException = function () {</p><p>        throw new Error("formGroupName must be used with a parent formGroup directive.  You'll want to add a formGroup\n      directive and pass it an existing FormGroup instance (you can create one in your class).\n\n      Example:\n\n      " + FormErrorExamples.formGroupName);</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    ReactiveErrors.arrayParentException = function () {</p><p>        throw new Error("formArrayName must be used with a parent formGroup directive.  You'll want to add a formGroup\n       directive and pass it an existing FormGroup instance (you can create one in your class).\n\n        Example:\n\n        " + FormErrorExamples.formArrayName);</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    ReactiveErrors.disabledAttrWarning = function () {</p><p>        console.warn("\n      It looks like you're using the disabled attribute with a reactive form directive. If you set disabled to true\n      when you set up this control in your component class, the disabled attribute will actually be set in the DOM for\n      you. We recommend using this approach to avoid 'changed after checked' errors.\n       \n      Example: \n      form = new FormGroup({\n        first: new FormControl({value: 'Nancy', disabled: true}, Validators.required),\n        last: new FormControl('Drew', Validators.required)\n      });\n    ");</p><p>    };</p><p>    return ReactiveErrors;</p><p>}());</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>var formControlBinding$1 = {</p><p>    provide: NgControl,</p><p>    useExisting: Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["forwardRef"])(function () { return FormControlDirective; })</p><p>};</p><p>/**</p><p> * \@whatItDoes Syncs a standalone {\@link FormControl} instance to a form control element.</p><p> *</p><p> * In other words, this directive ensures that any values written to the {\@link FormControl}</p><p> * instance programmatically will be written to the DOM element (model -> view). Conversely,</p><p> * any values written to the DOM element through user input will be reflected in the</p><p> * {\@link FormControl} instance (view -> model).</p><p> *</p><p> * \@howToUse</p><p> *</p><p> * Use this directive if you'd like to create and manage a {\@link FormControl} instance directly.</p><p> * Simply create a {\@link FormControl}, save it to your component class, and pass it into the</p><p> * {\@link FormControlDirective}.</p><p> *</p><p> * This directive is designed to be used as a standalone control.  Unlike {\@link FormControlName},</p><p> * it does not require that your {\@link FormControl} instance be part of any parent</p><p> * {\@link FormGroup}, and it won't be registered to any {\@link FormGroupDirective} that</p><p> * exists above it.</p><p> *</p><p> * **Get the value**: the `value` property is always synced and available on the</p><p> * {\@link FormControl} instance. See a full list of available properties in</p><p> * {\@link AbstractControl}.</p><p> *</p><p> * **Set the value**: You can pass in an initial value when instantiating the {\@link FormControl},</p><p> * or you can set it programmatically later using {\@link AbstractControl#setValue} or</p><p> * {\@link AbstractControl#patchValue}.</p><p> *</p><p> * **Listen to value**: If you want to listen to changes in the value of the control, you can</p><p> * subscribe to the {\@link AbstractControl#valueChanges} event.  You can also listen to</p><p> * {\@link AbstractControl#statusChanges} to be notified when the validation status is</p><p> * re-calculated.</p><p> *</p><p> * ### Example</p><p> *</p><p> * {\@example forms/ts/simpleFormControl/simple_form_control_example.ts region='Component'}</p><p> *</p><p> * * **npm package**: `\@angular/forms`</p><p> *</p><p> * * **NgModule**: `ReactiveFormsModule`</p><p> *</p><p> *  \@stable</p><p> */</p><p>var FormControlDirective = (function (_super) {</p><p>    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](FormControlDirective, _super);</p><p>    /**</p><p>     * @param {?} validators</p><p>     * @param {?} asyncValidators</p><p>     * @param {?} valueAccessors</p><p>     */</p><p>    function FormControlDirective(validators, asyncValidators, valueAccessors) {</p><p>        var _this = _super.call(this) || this;</p><p>        _this.update = new __WEBPACK_IMPORTED_MODULE_1__angular_core__["EventEmitter"]();</p><p>        _this._rawValidators = validators || [];</p><p>        _this._rawAsyncValidators = asyncValidators || [];</p><p>        _this.valueAccessor = selectValueAccessor(_this, valueAccessors);</p><p>        return _this;</p><p>    }</p><p>    Object.defineProperty(FormControlDirective.prototype, "isDisabled", {</p><p>        /**</p><p>         * @param {?} isDisabled</p><p>         * @return {?}</p><p>         */</p><p>        set: function (isDisabled) { ReactiveErrors.disabledAttrWarning(); },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    /**</p><p>     * @param {?} changes</p><p>     * @return {?}</p><p>     */</p><p>    FormControlDirective.prototype.ngOnChanges = function (changes) {</p><p>        if (this._isControlChanged(changes)) {</p><p>            setUpControl(this.form, this);</p><p>            if (this.control.disabled && ((this.valueAccessor)).setDisabledState) {</p><p>                ((((this.valueAccessor)).setDisabledState))(true);</p><p>            }</p><p>            this.form.updateValueAndValidity({ emitEvent: false });</p><p>        }</p><p>        if (isPropertyUpdated(changes, this.viewModel)) {</p><p>            this.form.setValue(this.model);</p><p>            this.viewModel = this.model;</p><p>        }</p><p>    };</p><p>    Object.defineProperty(FormControlDirective.prototype, "path", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return []; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(FormControlDirective.prototype, "validator", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return composeValidators(this._rawValidators); },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(FormControlDirective.prototype, "asyncValidator", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () {</p><p>            return composeAsyncValidators(this._rawAsyncValidators);</p><p>        },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(FormControlDirective.prototype, "control", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this.form; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    /**</p><p>     * @param {?} newValue</p><p>     * @return {?}</p><p>     */</p><p>    FormControlDirective.prototype.viewToModelUpdate = function (newValue) {</p><p>        this.viewModel = newValue;</p><p>        this.update.emit(newValue);</p><p>    };</p><p>    /**</p><p>     * @param {?} changes</p><p>     * @return {?}</p><p>     */</p><p>    FormControlDirective.prototype._isControlChanged = function (changes) {</p><p>        return changes.hasOwnProperty('form');</p><p>    };</p><p>    return FormControlDirective;</p><p>}(NgControl));</p><p>FormControlDirective.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Directive"], args: [{ selector: '[formControl]', providers: [formControlBinding$1], exportAs: 'ngForm' },] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>FormControlDirective.ctorParameters = function () { return [</p><p>    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Self"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Inject"], args: [NG_VALIDATORS,] },] },</p><p>    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Self"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Inject"], args: [NG_ASYNC_VALIDATORS,] },] },</p><p>    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Self"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Inject"], args: [NG_VALUE_ACCESSOR,] },] },</p><p>]; };</p><p>FormControlDirective.propDecorators = {</p><p>    'form': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"], args: ['formControl',] },],</p><p>    'model': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"], args: ['ngModel',] },],</p><p>    'update': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Output"], args: ['ngModelChange',] },],</p><p>    'isDisabled': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"], args: ['disabled',] },],</p><p>};</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>var formDirectiveProvider$1 = {</p><p>    provide: ControlContainer,</p><p>    useExisting: Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["forwardRef"])(function () { return FormGroupDirective; })</p><p>};</p><p>/**</p><p> * \@whatItDoes Binds an existing {\@link FormGroup} to a DOM element.</p><p> *</p><p> * \@howToUse</p><p> *</p><p> * This directive accepts an existing {\@link FormGroup} instance. It will then use this</p><p> * {\@link FormGroup} instance to match any child {\@link FormControl}, {\@link FormGroup},</p><p> * and {\@link FormArray} instances to child {\@link FormControlName}, {\@link FormGroupName},</p><p> * and {\@link FormArrayName} directives.</p><p> *</p><p> * **Set value**: You can set the form's initial value when instantiating the</p><p> * {\@link FormGroup}, or you can set it programmatically later using the {\@link FormGroup}'s</p><p> * {\@link AbstractControl#setValue} or {\@link AbstractControl#patchValue} methods.</p><p> *</p><p> * **Listen to value**: If you want to listen to changes in the value of the form, you can subscribe</p><p> * to the {\@link FormGroup}'s {\@link AbstractControl#valueChanges} event.  You can also listen to</p><p> * its {\@link AbstractControl#statusChanges} event to be notified when the validation status is</p><p> * re-calculated.</p><p> *</p><p> * Furthermore, you can listen to the directive's `ngSubmit` event to be notified when the user has</p><p> * triggered a form submission. The `ngSubmit` event will be emitted with the original form</p><p> * submission event.</p><p> *</p><p> * ### Example</p><p> *</p><p> * In this example, we create form controls for first name and last name.</p><p> *</p><p> * {\@example forms/ts/simpleFormGroup/simple_form_group_example.ts region='Component'}</p><p> *</p><p> * **npm package**: `\@angular/forms`</p><p> *</p><p> * **NgModule**: {\@link ReactiveFormsModule}</p><p> *</p><p> *  \@stable</p><p> */</p><p>var FormGroupDirective = (function (_super) {</p><p>    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](FormGroupDirective, _super);</p><p>    /**</p><p>     * @param {?} _validators</p><p>     * @param {?} _asyncValidators</p><p>     */</p><p>    function FormGroupDirective(_validators, _asyncValidators) {</p><p>        var _this = _super.call(this) || this;</p><p>        _this._validators = _validators;</p><p>        _this._asyncValidators = _asyncValidators;</p><p>        _this._submitted = false;</p><p>        _this.directives = [];</p><p>        _this.form = ((null));</p><p>        _this.ngSubmit = new __WEBPACK_IMPORTED_MODULE_1__angular_core__["EventEmitter"]();</p><p>        return _this;</p><p>    }</p><p>    /**</p><p>     * @param {?} changes</p><p>     * @return {?}</p><p>     */</p><p>    FormGroupDirective.prototype.ngOnChanges = function (changes) {</p><p>        this._checkFormPresent();</p><p>        if (changes.hasOwnProperty('form')) {</p><p>            this._updateValidators();</p><p>            this._updateDomValue();</p><p>            this._updateRegistrations();</p><p>        }</p><p>    };</p><p>    Object.defineProperty(FormGroupDirective.prototype, "submitted", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this._submitted; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(FormGroupDirective.prototype, "formDirective", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(FormGroupDirective.prototype, "control", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this.form; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(FormGroupDirective.prototype, "path", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return []; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    /**</p><p>     * @param {?} dir</p><p>     * @return {?}</p><p>     */</p><p>    FormGroupDirective.prototype.addControl = function (dir) {</p><p>        var /** @type {?} */ ctrl = this.form.get(dir.path);</p><p>        setUpControl(ctrl, dir);</p><p>        ctrl.updateValueAndValidity({ emitEvent: false });</p><p>        this.directives.push(dir);</p><p>        return ctrl;</p><p>    };</p><p>    /**</p><p>     * @param {?} dir</p><p>     * @return {?}</p><p>     */</p><p>    FormGroupDirective.prototype.getControl = function (dir) { return (this.form.get(dir.path)); };</p><p>    /**</p><p>     * @param {?} dir</p><p>     * @return {?}</p><p>     */</p><p>    FormGroupDirective.prototype.removeControl = function (dir) { remove(this.directives, dir); };</p><p>    /**</p><p>     * @param {?} dir</p><p>     * @return {?}</p><p>     */</p><p>    FormGroupDirective.prototype.addFormGroup = function (dir) {</p><p>        var /** @type {?} */ ctrl = this.form.get(dir.path);</p><p>        setUpFormContainer(ctrl, dir);</p><p>        ctrl.updateValueAndValidity({ emitEvent: false });</p><p>    };</p><p>    /**</p><p>     * @param {?} dir</p><p>     * @return {?}</p><p>     */</p><p>    FormGroupDirective.prototype.removeFormGroup = function (dir) { };</p><p>    /**</p><p>     * @param {?} dir</p><p>     * @return {?}</p><p>     */</p><p>    FormGroupDirective.prototype.getFormGroup = function (dir) { return (this.form.get(dir.path)); };</p><p>    /**</p><p>     * @param {?} dir</p><p>     * @return {?}</p><p>     */</p><p>    FormGroupDirective.prototype.addFormArray = function (dir) {</p><p>        var /** @type {?} */ ctrl = this.form.get(dir.path);</p><p>        setUpFormContainer(ctrl, dir);</p><p>        ctrl.updateValueAndValidity({ emitEvent: false });</p><p>    };</p><p>    /**</p><p>     * @param {?} dir</p><p>     * @return {?}</p><p>     */</p><p>    FormGroupDirective.prototype.removeFormArray = function (dir) { };</p><p>    /**</p><p>     * @param {?} dir</p><p>     * @return {?}</p><p>     */</p><p>    FormGroupDirective.prototype.getFormArray = function (dir) { return (this.form.get(dir.path)); };</p><p>    /**</p><p>     * @param {?} dir</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    FormGroupDirective.prototype.updateModel = function (dir, value) {</p><p>        var /** @type {?} */ ctrl = (this.form.get(dir.path));</p><p>        ctrl.setValue(value);</p><p>    };</p><p>    /**</p><p>     * @param {?} $event</p><p>     * @return {?}</p><p>     */</p><p>    FormGroupDirective.prototype.onSubmit = function ($event) {</p><p>        this._submitted = true;</p><p>        this.ngSubmit.emit($event);</p><p>        return false;</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    FormGroupDirective.prototype.onReset = function () { this.resetForm(); };</p><p>    /**</p><p>     * @param {?=} value</p><p>     * @return {?}</p><p>     */</p><p>    FormGroupDirective.prototype.resetForm = function (value) {</p><p>        if (value === void 0) { value = undefined; }</p><p>        this.form.reset(value);</p><p>        this._submitted = false;</p><p>    };</p><p>    /**</p><p>     * \@internal</p><p>     * @return {?}</p><p>     */</p><p>    FormGroupDirective.prototype._updateDomValue = function () {</p><p>        var _this = this;</p><p>        this.directives.forEach(function (dir) {</p><p>            var /** @type {?} */ newCtrl = _this.form.get(dir.path);</p><p>            if (dir._control !== newCtrl) {</p><p>                cleanUpControl(dir._control, dir);</p><p>                if (newCtrl)</p><p>                    setUpControl(newCtrl, dir);</p><p>                dir._control = newCtrl;</p><p>            }</p><p>        });</p><p>        this.form._updateTreeValidity({ emitEvent: false });</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    FormGroupDirective.prototype._updateRegistrations = function () {</p><p>        var _this = this;</p><p>        this.form._registerOnCollectionChange(function () { return _this._updateDomValue(); });</p><p>        if (this._oldForm)</p><p>            this._oldForm._registerOnCollectionChange(function () { });</p><p>        this._oldForm = this.form;</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    FormGroupDirective.prototype._updateValidators = function () {</p><p>        var /** @type {?} */ sync = composeValidators(this._validators);</p><p>        this.form.validator = Validators.compose([/** @type {?} */ ((this.form.validator)), /** @type {?} */ ((sync))]);</p><p>        var /** @type {?} */ async = composeAsyncValidators(this._asyncValidators);</p><p>        this.form.asyncValidator = Validators.composeAsync([/** @type {?} */ ((this.form.asyncValidator)), /** @type {?} */ ((async))]);</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    FormGroupDirective.prototype._checkFormPresent = function () {</p><p>        if (!this.form) {</p><p>            ReactiveErrors.missingFormException();</p><p>        }</p><p>    };</p><p>    return FormGroupDirective;</p><p>}(ControlContainer));</p><p>FormGroupDirective.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Directive"], args: [{</p><p>                selector: '[formGroup]',</p><p>                providers: [formDirectiveProvider$1],</p><p>                host: { '(submit)': 'onSubmit($event)', '(reset)': 'onReset()' },</p><p>                exportAs: 'ngForm'</p><p>            },] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>FormGroupDirective.ctorParameters = function () { return [</p><p>    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Self"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Inject"], args: [NG_VALIDATORS,] },] },</p><p>    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Self"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Inject"], args: [NG_ASYNC_VALIDATORS,] },] },</p><p>]; };</p><p>FormGroupDirective.propDecorators = {</p><p>    'form': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"], args: ['formGroup',] },],</p><p>    'ngSubmit': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Output"] },],</p><p>};</p><p>/**</p><p> * @template T</p><p> * @param {?} list</p><p> * @param {?} el</p><p> * @return {?}</p><p> */</p><p>function remove(list, el) {</p><p>    var /** @type {?} */ index = list.indexOf(el);</p><p>    if (index > -1) {</p><p>        list.splice(index, 1);</p><p>    }</p><p>}</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>var formGroupNameProvider = {</p><p>    provide: ControlContainer,</p><p>    useExisting: Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["forwardRef"])(function () { return FormGroupName; })</p><p>};</p><p>/**</p><p> * \@whatItDoes Syncs a nested {\@link FormGroup} to a DOM element.</p><p> *</p><p> * \@howToUse</p><p> *</p><p> * This directive can only be used with a parent {\@link FormGroupDirective} (selector:</p><p> * `[formGroup]`).</p><p> *</p><p> * It accepts the string name of the nested {\@link FormGroup} you want to link, and</p><p> * will look for a {\@link FormGroup} registered with that name in the parent</p><p> * {\@link FormGroup} instance you passed into {\@link FormGroupDirective}.</p><p> *</p><p> * Nested form groups can come in handy when you want to validate a sub-group of a</p><p> * form separately from the rest or when you'd like to group the values of certain</p><p> * controls into their own nested object.</p><p> *</p><p> * **Access the group**: You can access the associated {\@link FormGroup} using the</p><p> * {\@link AbstractControl#get} method. Ex: `this.form.get('name')`.</p><p> *</p><p> * You can also access individual controls within the group using dot syntax.</p><p> * Ex: `this.form.get('name.first')`</p><p> *</p><p> * **Get the value**: the `value` property is always synced and available on the</p><p> * {\@link FormGroup}. See a full list of available properties in {\@link AbstractControl}.</p><p> *</p><p> * **Set the value**: You can set an initial value for each child control when instantiating</p><p> * the {\@link FormGroup}, or you can set it programmatically later using</p><p> * {\@link AbstractControl#setValue} or {\@link AbstractControl#patchValue}.</p><p> *</p><p> * **Listen to value**: If you want to listen to changes in the value of the group, you can</p><p> * subscribe to the {\@link AbstractControl#valueChanges} event.  You can also listen to</p><p> * {\@link AbstractControl#statusChanges} to be notified when the validation status is</p><p> * re-calculated.</p><p> *</p><p> * ### Example</p><p> *</p><p> * {\@example forms/ts/nestedFormGroup/nested_form_group_example.ts region='Component'}</p><p> *</p><p> * * **npm package**: `\@angular/forms`</p><p> *</p><p> * * **NgModule**: `ReactiveFormsModule`</p><p> *</p><p> * \@stable</p><p> */</p><p>var FormGroupName = (function (_super) {</p><p>    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](FormGroupName, _super);</p><p>    /**</p><p>     * @param {?} parent</p><p>     * @param {?} validators</p><p>     * @param {?} asyncValidators</p><p>     */</p><p>    function FormGroupName(parent, validators, asyncValidators) {</p><p>        var _this = _super.call(this) || this;</p><p>        _this._parent = parent;</p><p>        _this._validators = validators;</p><p>        _this._asyncValidators = asyncValidators;</p><p>        return _this;</p><p>    }</p><p>    /**</p><p>     * \@internal</p><p>     * @return {?}</p><p>     */</p><p>    FormGroupName.prototype._checkParentType = function () {</p><p>        if (_hasInvalidParent(this._parent)) {</p><p>            ReactiveErrors.groupParentException();</p><p>        }</p><p>    };</p><p>    return FormGroupName;</p><p>}(AbstractFormGroupDirective));</p><p>FormGroupName.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Directive"], args: [{ selector: '[formGroupName]', providers: [formGroupNameProvider] },] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>FormGroupName.ctorParameters = function () { return [</p><p>    { type: ControlContainer, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Host"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["SkipSelf"] },] },</p><p>    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Self"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Inject"], args: [NG_VALIDATORS,] },] },</p><p>    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Self"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Inject"], args: [NG_ASYNC_VALIDATORS,] },] },</p><p>]; };</p><p>FormGroupName.propDecorators = {</p><p>    'name': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"], args: ['formGroupName',] },],</p><p>};</p><p>var formArrayNameProvider = {</p><p>    provide: ControlContainer,</p><p>    useExisting: Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["forwardRef"])(function () { return FormArrayName; })</p><p>};</p><p>/**</p><p> * \@whatItDoes Syncs a nested {\@link FormArray} to a DOM element.</p><p> *</p><p> * \@howToUse</p><p> *</p><p> * This directive is designed to be used with a parent {\@link FormGroupDirective} (selector:</p><p> * `[formGroup]`).</p><p> *</p><p> * It accepts the string name of the nested {\@link FormArray} you want to link, and</p><p> * will look for a {\@link FormArray} registered with that name in the parent</p><p> * {\@link FormGroup} instance you passed into {\@link FormGroupDirective}.</p><p> *</p><p> * Nested form arrays can come in handy when you have a group of form controls but</p><p> * you're not sure how many there will be. Form arrays allow you to create new</p><p> * form controls dynamically.</p><p> *</p><p> * **Access the array**: You can access the associated {\@link FormArray} using the</p><p> * {\@link AbstractControl#get} method on the parent {\@link FormGroup}.</p><p> * Ex: `this.form.get('cities')`.</p><p> *</p><p> * **Get the value**: the `value` property is always synced and available on the</p><p> * {\@link FormArray}. See a full list of available properties in {\@link AbstractControl}.</p><p> *</p><p> * **Set the value**: You can set an initial value for each child control when instantiating</p><p> * the {\@link FormArray}, or you can set the value programmatically later using the</p><p> * {\@link FormArray}'s {\@link AbstractControl#setValue} or {\@link AbstractControl#patchValue}</p><p> * methods.</p><p> *</p><p> * **Listen to value**: If you want to listen to changes in the value of the array, you can</p><p> * subscribe to the {\@link FormArray}'s {\@link AbstractControl#valueChanges} event.  You can also</p><p> * listen to its {\@link AbstractControl#statusChanges} event to be notified when the validation</p><p> * status is re-calculated.</p><p> *</p><p> * **Add new controls**: You can add new controls to the {\@link FormArray} dynamically by</p><p> * calling its {\@link FormArray#push} method.</p><p> *  Ex: `this.form.get('cities').push(new FormControl());`</p><p> *</p><p> * ### Example</p><p> *</p><p> * {\@example forms/ts/nestedFormArray/nested_form_array_example.ts region='Component'}</p><p> *</p><p> * * **npm package**: `\@angular/forms`</p><p> *</p><p> * * **NgModule**: `ReactiveFormsModule`</p><p> *</p><p> * \@stable</p><p> */</p><p>var FormArrayName = (function (_super) {</p><p>    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](FormArrayName, _super);</p><p>    /**</p><p>     * @param {?} parent</p><p>     * @param {?} validators</p><p>     * @param {?} asyncValidators</p><p>     */</p><p>    function FormArrayName(parent, validators, asyncValidators) {</p><p>        var _this = _super.call(this) || this;</p><p>        _this._parent = parent;</p><p>        _this._validators = validators;</p><p>        _this._asyncValidators = asyncValidators;</p><p>        return _this;</p><p>    }</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    FormArrayName.prototype.ngOnInit = function () {</p><p>        this._checkParentType(); /** @type {?} */</p><p>        ((this.formDirective)).addFormArray(this);</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    FormArrayName.prototype.ngOnDestroy = function () {</p><p>        if (this.formDirective) {</p><p>            this.formDirective.removeFormArray(this);</p><p>        }</p><p>    };</p><p>    Object.defineProperty(FormArrayName.prototype, "control", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return ((this.formDirective)).getFormArray(this); },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(FormArrayName.prototype, "formDirective", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () {</p><p>            return this._parent ? (this._parent.formDirective) : null;</p><p>        },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(FormArrayName.prototype, "path", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return controlPath(this.name, this._parent); },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(FormArrayName.prototype, "validator", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return composeValidators(this._validators); },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(FormArrayName.prototype, "asyncValidator", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () {</p><p>            return composeAsyncValidators(this._asyncValidators);</p><p>        },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    FormArrayName.prototype._checkParentType = function () {</p><p>        if (_hasInvalidParent(this._parent)) {</p><p>            ReactiveErrors.arrayParentException();</p><p>        }</p><p>    };</p><p>    return FormArrayName;</p><p>}(ControlContainer));</p><p>FormArrayName.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Directive"], args: [{ selector: '[formArrayName]', providers: [formArrayNameProvider] },] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>FormArrayName.ctorParameters = function () { return [</p><p>    { type: ControlContainer, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Host"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["SkipSelf"] },] },</p><p>    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Self"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Inject"], args: [NG_VALIDATORS,] },] },</p><p>    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Self"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Inject"], args: [NG_ASYNC_VALIDATORS,] },] },</p><p>]; };</p><p>FormArrayName.propDecorators = {</p><p>    'name': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"], args: ['formArrayName',] },],</p><p>};</p><p>/**</p><p> * @param {?} parent</p><p> * @return {?}</p><p> */</p><p>function _hasInvalidParent(parent) {</p><p>    return !(parent instanceof FormGroupName) && !(parent instanceof FormGroupDirective) &&</p><p>        !(parent instanceof FormArrayName);</p><p>}</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>var controlNameBinding = {</p><p>    provide: NgControl,</p><p>    useExisting: Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["forwardRef"])(function () { return FormControlName; })</p><p>};</p><p>/**</p><p> * \@whatItDoes Syncs a {\@link FormControl} in an existing {\@link FormGroup} to a form control</p><p> * element by name.</p><p> *</p><p> * In other words, this directive ensures that any values written to the {\@link FormControl}</p><p> * instance programmatically will be written to the DOM element (model -> view). Conversely,</p><p> * any values written to the DOM element through user input will be reflected in the</p><p> * {\@link FormControl} instance (view -> model).</p><p> *</p><p> * \@howToUse</p><p> *</p><p> * This directive is designed to be used with a parent {\@link FormGroupDirective} (selector:</p><p> * `[formGroup]`).</p><p> *</p><p> * It accepts the string name of the {\@link FormControl} instance you want to</p><p> * link, and will look for a {\@link FormControl} registered with that name in the</p><p> * closest {\@link FormGroup} or {\@link FormArray} above it.</p><p> *</p><p> * **Access the control**: You can access the {\@link FormControl} associated with</p><p> * this directive by using the {\@link AbstractControl#get} method.</p><p> * Ex: `this.form.get('first');`</p><p> *</p><p> * **Get value**: the `value` property is always synced and available on the {\@link FormControl}.</p><p> * See a full list of available properties in {\@link AbstractControl}.</p><p> *</p><p> *  **Set value**: You can set an initial value for the control when instantiating the</p><p> *  {\@link FormControl}, or you can set it programmatically later using</p><p> *  {\@link AbstractControl#setValue} or {\@link AbstractControl#patchValue}.</p><p> *</p><p> * **Listen to value**: If you want to listen to changes in the value of the control, you can</p><p> * subscribe to the {\@link AbstractControl#valueChanges} event.  You can also listen to</p><p> * {\@link AbstractControl#statusChanges} to be notified when the validation status is</p><p> * re-calculated.</p><p> *</p><p> * ### Example</p><p> *</p><p> * In this example, we create form controls for first name and last name.</p><p> *</p><p> * {\@example forms/ts/simpleFormGroup/simple_form_group_example.ts region='Component'}</p><p> *</p><p> * To see `formControlName` examples with different form control types, see:</p><p> *</p><p> * * Radio buttons: {\@link RadioControlValueAccessor}</p><p> * * Selects: {\@link SelectControlValueAccessor}</p><p> *</p><p> * **npm package**: `\@angular/forms`</p><p> *</p><p> * **NgModule**: {\@link ReactiveFormsModule}</p><p> *</p><p> *  \@stable</p><p> */</p><p>var FormControlName = (function (_super) {</p><p>    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](FormControlName, _super);</p><p>    /**</p><p>     * @param {?} parent</p><p>     * @param {?} validators</p><p>     * @param {?} asyncValidators</p><p>     * @param {?} valueAccessors</p><p>     */</p><p>    function FormControlName(parent, validators, asyncValidators, valueAccessors) {</p><p>        var _this = _super.call(this) || this;</p><p>        _this._added = false;</p><p>        _this.update = new __WEBPACK_IMPORTED_MODULE_1__angular_core__["EventEmitter"]();</p><p>        _this._parent = parent;</p><p>        _this._rawValidators = validators || [];</p><p>        _this._rawAsyncValidators = asyncValidators || [];</p><p>        _this.valueAccessor = selectValueAccessor(_this, valueAccessors);</p><p>        return _this;</p><p>    }</p><p>    Object.defineProperty(FormControlName.prototype, "isDisabled", {</p><p>        /**</p><p>         * @param {?} isDisabled</p><p>         * @return {?}</p><p>         */</p><p>        set: function (isDisabled) { ReactiveErrors.disabledAttrWarning(); },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    /**</p><p>     * @param {?} changes</p><p>     * @return {?}</p><p>     */</p><p>    FormControlName.prototype.ngOnChanges = function (changes) {</p><p>        if (!this._added)</p><p>            this._setUpControl();</p><p>        if (isPropertyUpdated(changes, this.viewModel)) {</p><p>            this.viewModel = this.model;</p><p>            this.formDirective.updateModel(this, this.model);</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    FormControlName.prototype.ngOnDestroy = function () {</p><p>        if (this.formDirective) {</p><p>            this.formDirective.removeControl(this);</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @param {?} newValue</p><p>     * @return {?}</p><p>     */</p><p>    FormControlName.prototype.viewToModelUpdate = function (newValue) {</p><p>        this.viewModel = newValue;</p><p>        this.update.emit(newValue);</p><p>    };</p><p>    Object.defineProperty(FormControlName.prototype, "path", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return controlPath(this.name, /** @type {?} */ ((this._parent))); },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(FormControlName.prototype, "formDirective", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this._parent ? this._parent.formDirective : null; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(FormControlName.prototype, "validator", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return composeValidators(this._rawValidators); },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(FormControlName.prototype, "asyncValidator", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () {</p><p>            return ((composeAsyncValidators(this._rawAsyncValidators)));</p><p>        },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(FormControlName.prototype, "control", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this._control; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    FormControlName.prototype._checkParentType = function () {</p><p>        if (!(this._parent instanceof FormGroupName) &&</p><p>            this._parent instanceof AbstractFormGroupDirective) {</p><p>            ReactiveErrors.ngModelGroupException();</p><p>        }</p><p>        else if (!(this._parent instanceof FormGroupName) && !(this._parent instanceof FormGroupDirective) &&</p><p>            !(this._parent instanceof FormArrayName)) {</p><p>            ReactiveErrors.controlParentException();</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    FormControlName.prototype._setUpControl = function () {</p><p>        this._checkParentType();</p><p>        this._control = this.formDirective.addControl(this);</p><p>        if (this.control.disabled && ((this.valueAccessor)).setDisabledState) {</p><p>            ((((this.valueAccessor)).setDisabledState))(true);</p><p>        }</p><p>        this._added = true;</p><p>    };</p><p>    return FormControlName;</p><p>}(NgControl));</p><p>FormControlName.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Directive"], args: [{ selector: '[formControlName]', providers: [controlNameBinding] },] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>FormControlName.ctorParameters = function () { return [</p><p>    { type: ControlContainer, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Host"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["SkipSelf"] },] },</p><p>    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Self"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Inject"], args: [NG_VALIDATORS,] },] },</p><p>    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Self"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Inject"], args: [NG_ASYNC_VALIDATORS,] },] },</p><p>    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Self"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Inject"], args: [NG_VALUE_ACCESSOR,] },] },</p><p>]; };</p><p>FormControlName.propDecorators = {</p><p>    'name': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"], args: ['formControlName',] },],</p><p>    'model': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"], args: ['ngModel',] },],</p><p>    'update': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Output"], args: ['ngModelChange',] },],</p><p>    'isDisabled': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"], args: ['disabled',] },],</p><p>};</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>var REQUIRED_VALIDATOR = {</p><p>    provide: NG_VALIDATORS,</p><p>    useExisting: Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["forwardRef"])(function () { return RequiredValidator; }),</p><p>    multi: true</p><p>};</p><p>var CHECKBOX_REQUIRED_VALIDATOR = {</p><p>    provide: NG_VALIDATORS,</p><p>    useExisting: Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["forwardRef"])(function () { return CheckboxRequiredValidator; }),</p><p>    multi: true</p><p>};</p><p>/**</p><p> * A Directive that adds the `required` validator to any controls marked with the</p><p> * `required` attribute, via the {\@link NG_VALIDATORS} binding.</p><p> *</p><p> * ### Example</p><p> *</p><p> * ```</p><p> * <input name="fullName" ngModel required></p><p> * ```</p><p> *</p><p> * \@stable</p><p> */</p><p>var RequiredValidator = (function () {</p><p>    function RequiredValidator() {</p><p>    }</p><p>    Object.defineProperty(RequiredValidator.prototype, "required", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this._required; },</p><p>        /**</p><p>         * @param {?} value</p><p>         * @return {?}</p><p>         */</p><p>        set: function (value) {</p><p>            this._required = value != null && value !== false && "" + value !== 'false';</p><p>            if (this._onChange)</p><p>                this._onChange();</p><p>        },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    /**</p><p>     * @param {?} c</p><p>     * @return {?}</p><p>     */</p><p>    RequiredValidator.prototype.validate = function (c) {</p><p>        return this.required ? Validators.required(c) : null;</p><p>    };</p><p>    /**</p><p>     * @param {?} fn</p><p>     * @return {?}</p><p>     */</p><p>    RequiredValidator.prototype.registerOnValidatorChange = function (fn) { this._onChange = fn; };</p><p>    return RequiredValidator;</p><p>}());</p><p>RequiredValidator.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Directive"], args: [{</p><p>                selector: ':not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]',</p><p>                providers: [REQUIRED_VALIDATOR],</p><p>                host: { '[attr.required]': 'required ? "" : null' }</p><p>            },] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>RequiredValidator.ctorParameters = function () { return []; };</p><p>RequiredValidator.propDecorators = {</p><p>    'required': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"] },],</p><p>};</p><p>/**</p><p> * A Directive that adds the `required` validator to checkbox controls marked with the</p><p> * `required` attribute, via the {\@link NG_VALIDATORS} binding.</p><p> *</p><p> * ### Example</p><p> *</p><p> * ```</p><p> * <input type="checkbox" name="active" ngModel required></p><p> * ```</p><p> *</p><p> * \@experimental</p><p> */</p><p>var CheckboxRequiredValidator = (function (_super) {</p><p>    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](CheckboxRequiredValidator, _super);</p><p>    function CheckboxRequiredValidator() {</p><p>        return _super !== null && _super.apply(this, arguments) || this;</p><p>    }</p><p>    /**</p><p>     * @param {?} c</p><p>     * @return {?}</p><p>     */</p><p>    CheckboxRequiredValidator.prototype.validate = function (c) {</p><p>        return this.required ? Validators.requiredTrue(c) : null;</p><p>    };</p><p>    return CheckboxRequiredValidator;</p><p>}(RequiredValidator));</p><p>CheckboxRequiredValidator.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Directive"], args: [{</p><p>                selector: 'input[type=checkbox][required][formControlName],input[type=checkbox][required][formControl],input[type=checkbox][required][ngModel]',</p><p>                providers: [CHECKBOX_REQUIRED_VALIDATOR],</p><p>                host: { '[attr.required]': 'required ? "" : null' }</p><p>            },] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>CheckboxRequiredValidator.ctorParameters = function () { return []; };</p><p>/**</p><p> * Provider which adds {\@link EmailValidator} to {\@link NG_VALIDATORS}.</p><p> */</p><p>var EMAIL_VALIDATOR = {</p><p>    provide: NG_VALIDATORS,</p><p>    useExisting: Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["forwardRef"])(function () { return EmailValidator; }),</p><p>    multi: true</p><p>};</p><p>/**</p><p> * A Directive that adds the `email` validator to controls marked with the</p><p> * `email` attribute, via the {\@link NG_VALIDATORS} binding.</p><p> *</p><p> * ### Example</p><p> *</p><p> * ```</p><p> * <input type="email" name="email" ngModel email></p><p> * <input type="email" name="email" ngModel email="true"></p><p> * <input type="email" name="email" ngModel [email]="true"></p><p> * ```</p><p> *</p><p> * \@experimental</p><p> */</p><p>var EmailValidator = (function () {</p><p>    function EmailValidator() {</p><p>    }</p><p>    Object.defineProperty(EmailValidator.prototype, "email", {</p><p>        /**</p><p>         * @param {?} value</p><p>         * @return {?}</p><p>         */</p><p>        set: function (value) {</p><p>            this._enabled = value === '' || value === true || value === 'true';</p><p>            if (this._onChange)</p><p>                this._onChange();</p><p>        },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    /**</p><p>     * @param {?} c</p><p>     * @return {?}</p><p>     */</p><p>    EmailValidator.prototype.validate = function (c) {</p><p>        return this._enabled ? Validators.email(c) : null;</p><p>    };</p><p>    /**</p><p>     * @param {?} fn</p><p>     * @return {?}</p><p>     */</p><p>    EmailValidator.prototype.registerOnValidatorChange = function (fn) { this._onChange = fn; };</p><p>    return EmailValidator;</p><p>}());</p><p>EmailValidator.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Directive"], args: [{</p><p>                selector: '[email][formControlName],[email][formControl],[email][ngModel]',</p><p>                providers: [EMAIL_VALIDATOR]</p><p>            },] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>EmailValidator.ctorParameters = function () { return []; };</p><p>EmailValidator.propDecorators = {</p><p>    'email': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"] },],</p><p>};</p><p>/**</p><p> * Provider which adds {\@link MinLengthValidator} to {\@link NG_VALIDATORS}.</p><p> *</p><p> * ## Example:</p><p> *</p><p> * {\@example common/forms/ts/validators/validators.ts region='min'}</p><p> */</p><p>var MIN_LENGTH_VALIDATOR = {</p><p>    provide: NG_VALIDATORS,</p><p>    useExisting: Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["forwardRef"])(function () { return MinLengthValidator; }),</p><p>    multi: true</p><p>};</p><p>/**</p><p> * A directive which installs the {\@link MinLengthValidator} for any `formControlName`,</p><p> * `formControl`, or control with `ngModel` that also has a `minlength` attribute.</p><p> *</p><p> * \@stable</p><p> */</p><p>var MinLengthValidator = (function () {</p><p>    function MinLengthValidator() {</p><p>    }</p><p>    /**</p><p>     * @param {?} changes</p><p>     * @return {?}</p><p>     */</p><p>    MinLengthValidator.prototype.ngOnChanges = function (changes) {</p><p>        if ('minlength' in changes) {</p><p>            this._createValidator();</p><p>            if (this._onChange)</p><p>                this._onChange();</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @param {?} c</p><p>     * @return {?}</p><p>     */</p><p>    MinLengthValidator.prototype.validate = function (c) {</p><p>        return this.minlength == null ? null : this._validator(c);</p><p>    };</p><p>    /**</p><p>     * @param {?} fn</p><p>     * @return {?}</p><p>     */</p><p>    MinLengthValidator.prototype.registerOnValidatorChange = function (fn) { this._onChange = fn; };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    MinLengthValidator.prototype._createValidator = function () {</p><p>        this._validator = Validators.minLength(parseInt(this.minlength, 10));</p><p>    };</p><p>    return MinLengthValidator;</p><p>}());</p><p>MinLengthValidator.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Directive"], args: [{</p><p>                selector: '[minlength][formControlName],[minlength][formControl],[minlength][ngModel]',</p><p>                providers: [MIN_LENGTH_VALIDATOR],</p><p>                host: { '[attr.minlength]': 'minlength ? minlength : null' }</p><p>            },] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>MinLengthValidator.ctorParameters = function () { return []; };</p><p>MinLengthValidator.propDecorators = {</p><p>    'minlength': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"] },],</p><p>};</p><p>/**</p><p> * Provider which adds {\@link MaxLengthValidator} to {\@link NG_VALIDATORS}.</p><p> *</p><p> * ## Example:</p><p> *</p><p> * {\@example common/forms/ts/validators/validators.ts region='max'}</p><p> */</p><p>var MAX_LENGTH_VALIDATOR = {</p><p>    provide: NG_VALIDATORS,</p><p>    useExisting: Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["forwardRef"])(function () { return MaxLengthValidator; }),</p><p>    multi: true</p><p>};</p><p>/**</p><p> * A directive which installs the {\@link MaxLengthValidator} for any `formControlName,</p><p> * `formControl`,</p><p> * or control with `ngModel` that also has a `maxlength` attribute.</p><p> *</p><p> * \@stable</p><p> */</p><p>var MaxLengthValidator = (function () {</p><p>    function MaxLengthValidator() {</p><p>    }</p><p>    /**</p><p>     * @param {?} changes</p><p>     * @return {?}</p><p>     */</p><p>    MaxLengthValidator.prototype.ngOnChanges = function (changes) {</p><p>        if ('maxlength' in changes) {</p><p>            this._createValidator();</p><p>            if (this._onChange)</p><p>                this._onChange();</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @param {?} c</p><p>     * @return {?}</p><p>     */</p><p>    MaxLengthValidator.prototype.validate = function (c) {</p><p>        return this.maxlength != null ? this._validator(c) : null;</p><p>    };</p><p>    /**</p><p>     * @param {?} fn</p><p>     * @return {?}</p><p>     */</p><p>    MaxLengthValidator.prototype.registerOnValidatorChange = function (fn) { this._onChange = fn; };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    MaxLengthValidator.prototype._createValidator = function () {</p><p>        this._validator = Validators.maxLength(parseInt(this.maxlength, 10));</p><p>    };</p><p>    return MaxLengthValidator;</p><p>}());</p><p>MaxLengthValidator.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Directive"], args: [{</p><p>                selector: '[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]',</p><p>                providers: [MAX_LENGTH_VALIDATOR],</p><p>                host: { '[attr.maxlength]': 'maxlength ? maxlength : null' }</p><p>            },] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>MaxLengthValidator.ctorParameters = function () { return []; };</p><p>MaxLengthValidator.propDecorators = {</p><p>    'maxlength': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"] },],</p><p>};</p><p>var PATTERN_VALIDATOR = {</p><p>    provide: NG_VALIDATORS,</p><p>    useExisting: Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["forwardRef"])(function () { return PatternValidator; }),</p><p>    multi: true</p><p>};</p><p>/**</p><p> * A Directive that adds the `pattern` validator to any controls marked with the</p><p> * `pattern` attribute, via the {\@link NG_VALIDATORS} binding. Uses attribute value</p><p> * as the regex to validate Control value against.  Follows pattern attribute</p><p> * semantics; i.e. regex must match entire Control value.</p><p> *</p><p> * ### Example</p><p> *</p><p> * ```</p><p> * <input [name]="fullName" pattern="[a-zA-Z ]*" ngModel></p><p> * ```</p><p> * \@stable</p><p> */</p><p>var PatternValidator = (function () {</p><p>    function PatternValidator() {</p><p>    }</p><p>    /**</p><p>     * @param {?} changes</p><p>     * @return {?}</p><p>     */</p><p>    PatternValidator.prototype.ngOnChanges = function (changes) {</p><p>        if ('pattern' in changes) {</p><p>            this._createValidator();</p><p>            if (this._onChange)</p><p>                this._onChange();</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @param {?} c</p><p>     * @return {?}</p><p>     */</p><p>    PatternValidator.prototype.validate = function (c) { return this._validator(c); };</p><p>    /**</p><p>     * @param {?} fn</p><p>     * @return {?}</p><p>     */</p><p>    PatternValidator.prototype.registerOnValidatorChange = function (fn) { this._onChange = fn; };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    PatternValidator.prototype._createValidator = function () { this._validator = Validators.pattern(this.pattern); };</p><p>    return PatternValidator;</p><p>}());</p><p>PatternValidator.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Directive"], args: [{</p><p>                selector: '[pattern][formControlName],[pattern][formControl],[pattern][ngModel]',</p><p>                providers: [PATTERN_VALIDATOR],</p><p>                host: { '[attr.pattern]': 'pattern ? pattern : null' }</p><p>            },] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>PatternValidator.ctorParameters = function () { return []; };</p><p>PatternValidator.propDecorators = {</p><p>    'pattern': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"] },],</p><p>};</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * \@whatItDoes Creates an {\@link AbstractControl} from a user-specified configuration.</p><p> *</p><p> * It is essentially syntactic sugar that shortens the `new FormGroup()`,</p><p> * `new FormControl()`, and `new FormArray()` boilerplate that can build up in larger</p><p> * forms.</p><p> *</p><p> * \@howToUse</p><p> *</p><p> * To use, inject `FormBuilder` into your component class. You can then call its methods</p><p> * directly.</p><p> *</p><p> * {\@example forms/ts/formBuilder/form_builder_example.ts region='Component'}</p><p> *</p><p> *  * **npm package**: `\@angular/forms`</p><p> *</p><p> *  * **NgModule**: {\@link ReactiveFormsModule}</p><p> *</p><p> * \@stable</p><p> */</p><p>var FormBuilder = (function () {</p><p>    function FormBuilder() {</p><p>    }</p><p>    /**</p><p>     * Construct a new {\@link FormGroup} with the given map of configuration.</p><p>     * Valid keys for the `extra` parameter map are `validator` and `asyncValidator`.</p><p>     *</p><p>     * See the {\@link FormGroup} constructor for more details.</p><p>     * @param {?} controlsConfig</p><p>     * @param {?=} extra</p><p>     * @return {?}</p><p>     */</p><p>    FormBuilder.prototype.group = function (controlsConfig, extra) {</p><p>        if (extra === void 0) { extra = null; }</p><p>        var /** @type {?} */ controls = this._reduceControls(controlsConfig);</p><p>        var /** @type {?} */ validator = extra != null ? extra['validator'] : null;</p><p>        var /** @type {?} */ asyncValidator = extra != null ? extra['asyncValidator'] : null;</p><p>        return new FormGroup(controls, validator, asyncValidator);</p><p>    };</p><p>    /**</p><p>     * Construct a new {\@link FormControl} with the given `formState`,`validator`, and</p><p>     * `asyncValidator`.</p><p>     *</p><p>     * `formState` can either be a standalone value for the form control or an object</p><p>     * that contains both a value and a disabled status.</p><p>     *</p><p>     * @param {?} formState</p><p>     * @param {?=} validator</p><p>     * @param {?=} asyncValidator</p><p>     * @return {?}</p><p>     */</p><p>    FormBuilder.prototype.control = function (formState, validator, asyncValidator) {</p><p>        return new FormControl(formState, validator, asyncValidator);</p><p>    };</p><p>    /**</p><p>     * Construct a {\@link FormArray} from the given `controlsConfig` array of</p><p>     * configuration, with the given optional `validator` and `asyncValidator`.</p><p>     * @param {?} controlsConfig</p><p>     * @param {?=} validator</p><p>     * @param {?=} asyncValidator</p><p>     * @return {?}</p><p>     */</p><p>    FormBuilder.prototype.array = function (controlsConfig, validator, asyncValidator) {</p><p>        var _this = this;</p><p>        var /** @type {?} */ controls = controlsConfig.map(function (c) { return _this._createControl(c); });</p><p>        return new FormArray(controls, validator, asyncValidator);</p><p>    };</p><p>    /**</p><p>     * \@internal</p><p>     * @param {?} controlsConfig</p><p>     * @return {?}</p><p>     */</p><p>    FormBuilder.prototype._reduceControls = function (controlsConfig) {</p><p>        var _this = this;</p><p>        var /** @type {?} */ controls = {};</p><p>        Object.keys(controlsConfig).forEach(function (controlName) {</p><p>            controls[controlName] = _this._createControl(controlsConfig[controlName]);</p><p>        });</p><p>        return controls;</p><p>    };</p><p>    /**</p><p>     * \@internal</p><p>     * @param {?} controlConfig</p><p>     * @return {?}</p><p>     */</p><p>    FormBuilder.prototype._createControl = function (controlConfig) {</p><p>        if (controlConfig instanceof FormControl || controlConfig instanceof FormGroup ||</p><p>            controlConfig instanceof FormArray) {</p><p>            return controlConfig;</p><p>        }</p><p>        else if (Array.isArray(controlConfig)) {</p><p>            var /** @type {?} */ value = controlConfig[0];</p><p>            var /** @type {?} */ validator = controlConfig.length > 1 ? controlConfig[1] : null;</p><p>            var /** @type {?} */ asyncValidator = controlConfig.length > 2 ? controlConfig[2] : null;</p><p>            return this.control(value, validator, asyncValidator);</p><p>        }</p><p>        else {</p><p>            return this.control(controlConfig);</p><p>        }</p><p>    };</p><p>    return FormBuilder;</p><p>}());</p><p>FormBuilder.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>FormBuilder.ctorParameters = function () { return []; };</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * @module</p><p> * @description</p><p> * Entry point for all public APIs of the common package.</p><p> */</p><p>/**</p><p> * \@stable</p><p> */</p><p>var VERSION = new __WEBPACK_IMPORTED_MODULE_1__angular_core__["Version"]('4.3.5');</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * \@whatItDoes Adds `novalidate` attribute to all forms by default.</p><p> *</p><p> * `novalidate` is used to disable browser's native form validation.</p><p> *</p><p> * If you want to use native validation with Angular forms, just add `ngNativeValidate` attribute:</p><p> *</p><p> * ```</p><p> * <form ngNativeValidate></form></p><p> * ```</p><p> *</p><p> * \@experimental</p><p> */</p><p>var NgNoValidate = (function () {</p><p>    function NgNoValidate() {</p><p>    }</p><p>    return NgNoValidate;</p><p>}());</p><p>NgNoValidate.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Directive"], args: [{</p><p>                selector: 'form:not([ngNoForm]):not([ngNativeValidate])',</p><p>                host: { 'novalidate': '' },</p><p>            },] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>NgNoValidate.ctorParameters = function () { return []; };</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>var SHARED_FORM_DIRECTIVES = [</p><p>    NgNoValidate,</p><p>    NgSelectOption,</p><p>    NgSelectMultipleOption,</p><p>    DefaultValueAccessor,</p><p>    NumberValueAccessor,</p><p>    RangeValueAccessor,</p><p>    CheckboxControlValueAccessor,</p><p>    SelectControlValueAccessor,</p><p>    SelectMultipleControlValueAccessor,</p><p>    RadioControlValueAccessor,</p><p>    NgControlStatus,</p><p>    NgControlStatusGroup,</p><p>    RequiredValidator,</p><p>    MinLengthValidator,</p><p>    MaxLengthValidator,</p><p>    PatternValidator,</p><p>    CheckboxRequiredValidator,</p><p>    EmailValidator,</p><p>];</p><p>var TEMPLATE_DRIVEN_DIRECTIVES = [NgModel, NgModelGroup, NgForm];</p><p>var REACTIVE_DRIVEN_DIRECTIVES = [FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName];</p><p>/**</p><p> * Internal module used for sharing directives between FormsModule and ReactiveFormsModule</p><p> */</p><p>var InternalFormsSharedModule = (function () {</p><p>    function InternalFormsSharedModule() {</p><p>    }</p><p>    return InternalFormsSharedModule;</p><p>}());</p><p>InternalFormsSharedModule.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["NgModule"], args: [{</p><p>                declarations: SHARED_FORM_DIRECTIVES,</p><p>                exports: SHARED_FORM_DIRECTIVES,</p><p>            },] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>InternalFormsSharedModule.ctorParameters = function () { return []; };</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * The ng module for forms.</p><p> * \@stable</p><p> */</p><p>var FormsModule = (function () {</p><p>    function FormsModule() {</p><p>    }</p><p>    return FormsModule;</p><p>}());</p><p>FormsModule.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["NgModule"], args: [{</p><p>                declarations: TEMPLATE_DRIVEN_DIRECTIVES,</p><p>                providers: [RadioControlRegistry],</p><p>                exports: [InternalFormsSharedModule, TEMPLATE_DRIVEN_DIRECTIVES]</p><p>            },] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>FormsModule.ctorParameters = function () { return []; };</p><p>/**</p><p> * The ng module for reactive forms.</p><p> * \@stable</p><p> */</p><p>var ReactiveFormsModule = (function () {</p><p>    function ReactiveFormsModule() {</p><p>    }</p><p>    return ReactiveFormsModule;</p><p>}());</p><p>ReactiveFormsModule.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["NgModule"], args: [{</p><p>                declarations: [REACTIVE_DRIVEN_DIRECTIVES],</p><p>                providers: [FormBuilder, RadioControlRegistry],</p><p>                exports: [InternalFormsSharedModule, REACTIVE_DRIVEN_DIRECTIVES]</p><p>            },] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>ReactiveFormsModule.ctorParameters = function () { return []; };</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * @module</p><p> * @description</p><p> * This module is used for handling user input, by defining and building a {@link FormGroup} that</p><p> * consists of {@link FormControl} objects, and mapping them onto the DOM. {@link FormControl}</p><p> * objects can then be used to read information from the form DOM elements.</p><p> *</p><p> * Forms providers are not included in default providers; you must import these providers</p><p> * explicitly.</p><p> */</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * @module</p><p> * @description</p><p> * Entry point for all public APIs of the forms package.</p><p> */</p><p>// This file only reexports content of the `src` folder. Keep it that way.</p><p>/**</p><p> * Generated bundle index. Do not edit.</p><p> */</p><p></p><p>//# sourceMappingURL=forms.es5.js.map</p><p></p><p></p><p>/***/ }),</p><p></p><p>/***/ "../../../http/@angular/http.es5.js":</p><p>/***/ (function(module, __webpack_exports__, __webpack_require__) {</p><p></p><p>"use strict";</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return BrowserXhr; });</p><p>/* unused harmony export JSONPBackend */</p><p>/* unused harmony export JSONPConnection */</p><p>/* unused harmony export CookieXSRFStrategy */</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return XHRBackend; });</p><p>/* unused harmony export XHRConnection */</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BaseRequestOptions; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return RequestOptions; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return BaseResponseOptions; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return ResponseOptions; });</p><p>/* unused harmony export ReadyState */</p><p>/* unused harmony export RequestMethod */</p><p>/* unused harmony export ResponseContentType */</p><p>/* unused harmony export ResponseType */</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return Headers; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return Http; });</p><p>/* unused harmony export Jsonp */</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return HttpModule; });</p><p>/* unused harmony export JsonpModule */</p><p>/* unused harmony export Connection */</p><p>/* unused harmony export ConnectionBackend */</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return XSRFStrategy; });</p><p>/* unused harmony export Request */</p><p>/* unused harmony export Response */</p><p>/* unused harmony export QueryEncoder */</p><p>/* unused harmony export URLSearchParams */</p><p>/* unused harmony export VERSION */</p><p>/* unused harmony export ɵg */</p><p>/* unused harmony export ɵa */</p><p>/* unused harmony export ɵf */</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return _createDefaultCookieXSRFStrategy; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return httpFactory; });</p><p>/* unused harmony export ɵd */</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__("../../../../tslib/tslib.es6.js");</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__("../../../core/@angular/core.es5.js");</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs_Observable__ = __webpack_require__("../../../../rxjs/Observable.js");</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_rxjs_Observable__);</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__angular_platform_browser__ = __webpack_require__("../../../platform-browser/@angular/platform-browser.es5.js");</p><p></p><p>/**</p><p> * @license Angular v4.3.5</p><p> * (c) 2010-2017 Google, Inc. https://angular.io/</p><p> * License: MIT</p><p> */</p><p></p><p></p><p></p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * A backend for http that uses the `XMLHttpRequest` browser API.</p><p> *</p><p> * Take care not to evaluate this in non-browser contexts.</p><p> *</p><p> * \@experimental</p><p> */</p><p>var BrowserXhr = (function () {</p><p>    function BrowserXhr() {</p><p>    }</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    BrowserXhr.prototype.build = function () { return ((new XMLHttpRequest())); };</p><p>    return BrowserXhr;</p><p>}());</p><p>BrowserXhr.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>BrowserXhr.ctorParameters = function () { return []; };</p><p>var RequestMethod = {};</p><p>RequestMethod.Get = 0;</p><p>RequestMethod.Post = 1;</p><p>RequestMethod.Put = 2;</p><p>RequestMethod.Delete = 3;</p><p>RequestMethod.Options = 4;</p><p>RequestMethod.Head = 5;</p><p>RequestMethod.Patch = 6;</p><p>RequestMethod[RequestMethod.Get] = "Get";</p><p>RequestMethod[RequestMethod.Post] = "Post";</p><p>RequestMethod[RequestMethod.Put] = "Put";</p><p>RequestMethod[RequestMethod.Delete] = "Delete";</p><p>RequestMethod[RequestMethod.Options] = "Options";</p><p>RequestMethod[RequestMethod.Head] = "Head";</p><p>RequestMethod[RequestMethod.Patch] = "Patch";</p><p>var ReadyState = {};</p><p>ReadyState.Unsent = 0;</p><p>ReadyState.Open = 1;</p><p>ReadyState.HeadersReceived = 2;</p><p>ReadyState.Loading = 3;</p><p>ReadyState.Done = 4;</p><p>ReadyState.Cancelled = 5;</p><p>ReadyState[ReadyState.Unsent] = "Unsent";</p><p>ReadyState[ReadyState.Open] = "Open";</p><p>ReadyState[ReadyState.HeadersReceived] = "HeadersReceived";</p><p>ReadyState[ReadyState.Loading] = "Loading";</p><p>ReadyState[ReadyState.Done] = "Done";</p><p>ReadyState[ReadyState.Cancelled] = "Cancelled";</p><p>var ResponseType = {};</p><p>ResponseType.Basic = 0;</p><p>ResponseType.Cors = 1;</p><p>ResponseType.Default = 2;</p><p>ResponseType.Error = 3;</p><p>ResponseType.Opaque = 4;</p><p>ResponseType[ResponseType.Basic] = "Basic";</p><p>ResponseType[ResponseType.Cors] = "Cors";</p><p>ResponseType[ResponseType.Default] = "Default";</p><p>ResponseType[ResponseType.Error] = "Error";</p><p>ResponseType[ResponseType.Opaque] = "Opaque";</p><p>var ContentType = {};</p><p>ContentType.NONE = 0;</p><p>ContentType.JSON = 1;</p><p>ContentType.FORM = 2;</p><p>ContentType.FORM_DATA = 3;</p><p>ContentType.TEXT = 4;</p><p>ContentType.BLOB = 5;</p><p>ContentType.ARRAY_BUFFER = 6;</p><p>ContentType[ContentType.NONE] = "NONE";</p><p>ContentType[ContentType.JSON] = "JSON";</p><p>ContentType[ContentType.FORM] = "FORM";</p><p>ContentType[ContentType.FORM_DATA] = "FORM_DATA";</p><p>ContentType[ContentType.TEXT] = "TEXT";</p><p>ContentType[ContentType.BLOB] = "BLOB";</p><p>ContentType[ContentType.ARRAY_BUFFER] = "ARRAY_BUFFER";</p><p>var ResponseContentType = {};</p><p>ResponseContentType.Text = 0;</p><p>ResponseContentType.Json = 1;</p><p>ResponseContentType.ArrayBuffer = 2;</p><p>ResponseContentType.Blob = 3;</p><p>ResponseContentType[ResponseContentType.Text] = "Text";</p><p>ResponseContentType[ResponseContentType.Json] = "Json";</p><p>ResponseContentType[ResponseContentType.ArrayBuffer] = "ArrayBuffer";</p><p>ResponseContentType[ResponseContentType.Blob] = "Blob";</p><p>/**</p><p> * Polyfill for [Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers/Headers), as</p><p> * specified in the [Fetch Spec](https://fetch.spec.whatwg.org/#headers-class).</p><p> *</p><p> * The only known difference between this `Headers` implementation and the spec is the</p><p> * lack of an `entries` method.</p><p> *</p><p> * ### Example</p><p> *</p><p> * ```</p><p> * import {Headers} from '\@angular/http';</p><p> *</p><p> * var firstHeaders = new Headers();</p><p> * firstHeaders.append('Content-Type', 'image/jpeg');</p><p> * console.log(firstHeaders.get('Content-Type')) //'image/jpeg'</p><p> *</p><p> * // Create headers from Plain Old JavaScript Object</p><p> * var secondHeaders = new Headers({</p><p> *   'X-My-Custom-Header': 'Angular'</p><p> * });</p><p> * console.log(secondHeaders.get('X-My-Custom-Header')); //'Angular'</p><p> *</p><p> * var thirdHeaders = new Headers(secondHeaders);</p><p> * console.log(thirdHeaders.get('X-My-Custom-Header')); //'Angular'</p><p> * ```</p><p> *</p><p> * \@experimental</p><p> */</p><p>var Headers = (function () {</p><p>    /**</p><p>     * @param {?=} headers</p><p>     */</p><p>    function Headers(headers) {</p><p>        var _this = this;</p><p>        /**</p><p>         * \@internal header names are lower case</p><p>         */</p><p>        this._headers = new Map();</p><p>        /**</p><p>         * \@internal map lower case names to actual names</p><p>         */</p><p>        this._normalizedNames = new Map();</p><p>        if (!headers) {</p><p>            return;</p><p>        }</p><p>        if (headers instanceof Headers) {</p><p>            headers.forEach(function (values, name) {</p><p>                values.forEach(function (value) { return _this.append(name, value); });</p><p>            });</p><p>            return;</p><p>        }</p><p>        Object.keys(headers).forEach(function (name) {</p><p>            var values = Array.isArray(headers[name]) ? headers[name] : [headers[name]];</p><p>            _this.delete(name);</p><p>            values.forEach(function (value) { return _this.append(name, value); });</p><p>        });</p><p>    }</p><p>    /**</p><p>     * Returns a new Headers instance from the given DOMString of Response Headers</p><p>     * @param {?} headersString</p><p>     * @return {?}</p><p>     */</p><p>    Headers.fromResponseHeaderString = function (headersString) {</p><p>        var /** @type {?} */ headers = new Headers();</p><p>        headersString.split('\n').forEach(function (line) {</p><p>            var /** @type {?} */ index = line.indexOf(':');</p><p>            if (index > 0) {</p><p>                var /** @type {?} */ name = line.slice(0, index);</p><p>                var /** @type {?} */ value = line.slice(index + 1).trim();</p><p>                headers.set(name, value);</p><p>            }</p><p>        });</p><p>        return headers;</p><p>    };</p><p>    /**</p><p>     * Appends a header to existing list of header values for a given header name.</p><p>     * @param {?} name</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    Headers.prototype.append = function (name, value) {</p><p>        var /** @type {?} */ values = this.getAll(name);</p><p>        if (values === null) {</p><p>            this.set(name, value);</p><p>        }</p><p>        else {</p><p>            values.push(value);</p><p>        }</p><p>    };</p><p>    /**</p><p>     * Deletes all header values for the given name.</p><p>     * @param {?} name</p><p>     * @return {?}</p><p>     */</p><p>    Headers.prototype.delete = function (name) {</p><p>        var /** @type {?} */ lcName = name.toLowerCase();</p><p>        this._normalizedNames.delete(lcName);</p><p>        this._headers.delete(lcName);</p><p>    };</p><p>    /**</p><p>     * @param {?} fn</p><p>     * @return {?}</p><p>     */</p><p>    Headers.prototype.forEach = function (fn) {</p><p>        var _this = this;</p><p>        this._headers.forEach(function (values, lcName) { return fn(values, _this._normalizedNames.get(lcName), _this._headers); });</p><p>    };</p><p>    /**</p><p>     * Returns first header that matches given name.</p><p>     * @param {?} name</p><p>     * @return {?}</p><p>     */</p><p>    Headers.prototype.get = function (name) {</p><p>        var /** @type {?} */ values = this.getAll(name);</p><p>        if (values === null) {</p><p>            return null;</p><p>        }</p><p>        return values.length > 0 ? values[0] : null;</p><p>    };</p><p>    /**</p><p>     * Checks for existence of header by given name.</p><p>     * @param {?} name</p><p>     * @return {?}</p><p>     */</p><p>    Headers.prototype.has = function (name) { return this._headers.has(name.toLowerCase()); };</p><p>    /**</p><p>     * Returns the names of the headers</p><p>     * @return {?}</p><p>     */</p><p>    Headers.prototype.keys = function () { return Array.from(this._normalizedNames.values()); };</p><p>    /**</p><p>     * Sets or overrides header value for given name.</p><p>     * @param {?} name</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    Headers.prototype.set = function (name, value) {</p><p>        if (Array.isArray(value)) {</p><p>            if (value.length) {</p><p>                this._headers.set(name.toLowerCase(), [value.join(',')]);</p><p>            }</p><p>        }</p><p>        else {</p><p>            this._headers.set(name.toLowerCase(), [value]);</p><p>        }</p><p>        this.mayBeSetNormalizedName(name);</p><p>    };</p><p>    /**</p><p>     * Returns values of all headers.</p><p>     * @return {?}</p><p>     */</p><p>    Headers.prototype.values = function () { return Array.from(this._headers.values()); };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    Headers.prototype.toJSON = function () {</p><p>        var _this = this;</p><p>        var /** @type {?} */ serialized = {};</p><p>        this._headers.forEach(function (values, name) {</p><p>            var /** @type {?} */ split = [];</p><p>            values.forEach(function (v) { return split.push.apply(split, v.split(',')); });</p><p>            serialized[((_this._normalizedNames.get(name)))] = split;</p><p>        });</p><p>        return serialized;</p><p>    };</p><p>    /**</p><p>     * Returns list of header values for a given name.</p><p>     * @param {?} name</p><p>     * @return {?}</p><p>     */</p><p>    Headers.prototype.getAll = function (name) {</p><p>        return this.has(name) ? this._headers.get(name.toLowerCase()) || null : null;</p><p>    };</p><p>    /**</p><p>     * This method is not implemented.</p><p>     * @return {?}</p><p>     */</p><p>    Headers.prototype.entries = function () { throw new Error('"entries" method is not implemented on Headers class'); };</p><p>    /**</p><p>     * @param {?} name</p><p>     * @return {?}</p><p>     */</p><p>    Headers.prototype.mayBeSetNormalizedName = function (name) {</p><p>        var /** @type {?} */ lcName = name.toLowerCase();</p><p>        if (!this._normalizedNames.has(lcName)) {</p><p>            this._normalizedNames.set(lcName, name);</p><p>        }</p><p>    };</p><p>    return Headers;</p><p>}());</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * Creates a response options object to be optionally provided when instantiating a</p><p> * {\@link Response}.</p><p> *</p><p> * This class is based on the `ResponseInit` description in the [Fetch</p><p> * Spec](https://fetch.spec.whatwg.org/#responseinit).</p><p> *</p><p> * All values are null by default. Typical defaults can be found in the</p><p> * {\@link BaseResponseOptions} class, which sub-classes `ResponseOptions`.</p><p> *</p><p> * This class may be used in tests to build {\@link Response Responses} for</p><p> * mock responses (see {\@link MockBackend}).</p><p> *</p><p> * ### Example ([live demo](http://plnkr.co/edit/P9Jkk8e8cz6NVzbcxEsD?p=preview))</p><p> *</p><p> * ```typescript</p><p> * import {ResponseOptions, Response} from '\@angular/http';</p><p> *</p><p> * var options = new ResponseOptions({</p><p> *   body: '{"name":"Jeff"}'</p><p> * });</p><p> * var res = new Response(options);</p><p> *</p><p> * console.log('res.json():', res.json()); // Object {name: "Jeff"}</p><p> * ```</p><p> *</p><p> * \@experimental</p><p> */</p><p>var ResponseOptions = (function () {</p><p>    /**</p><p>     * @param {?=} opts</p><p>     */</p><p>    function ResponseOptions(opts) {</p><p>        if (opts === void 0) { opts = {}; }</p><p>        var body = opts.body, status = opts.status, headers = opts.headers, statusText = opts.statusText, type = opts.type, url = opts.url;</p><p>        this.body = body != null ? body : null;</p><p>        this.status = status != null ? status : null;</p><p>        this.headers = headers != null ? headers : null;</p><p>        this.statusText = statusText != null ? statusText : null;</p><p>        this.type = type != null ? type : null;</p><p>        this.url = url != null ? url : null;</p><p>    }</p><p>    /**</p><p>     * Creates a copy of the `ResponseOptions` instance, using the optional input as values to</p><p>     * override</p><p>     * existing values. This method will not change the values of the instance on which it is being</p><p>     * called.</p><p>     *</p><p>     * This may be useful when sharing a base `ResponseOptions` object inside tests,</p><p>     * where certain properties may change from test to test.</p><p>     *</p><p>     * ### Example ([live demo](http://plnkr.co/edit/1lXquqFfgduTFBWjNoRE?p=preview))</p><p>     *</p><p>     * ```typescript</p><p>     * import {ResponseOptions, Response} from '\@angular/http';</p><p>     *</p><p>     * var options = new ResponseOptions({</p><p>     *   body: {name: 'Jeff'}</p><p>     * });</p><p>     * var res = new Response(options.merge({</p><p>     *   url: 'https://google.com'</p><p>     * }));</p><p>     * console.log('options.url:', options.url); // null</p><p>     * console.log('res.json():', res.json()); // Object {name: "Jeff"}</p><p>     * console.log('res.url:', res.url); // https://google.com</p><p>     * ```</p><p>     * @param {?=} options</p><p>     * @return {?}</p><p>     */</p><p>    ResponseOptions.prototype.merge = function (options) {</p><p>        return new ResponseOptions({</p><p>            body: options && options.body != null ? options.body : this.body,</p><p>            status: options && options.status != null ? options.status : this.status,</p><p>            headers: options && options.headers != null ? options.headers : this.headers,</p><p>            statusText: options && options.statusText != null ? options.statusText : this.statusText,</p><p>            type: options && options.type != null ? options.type : this.type,</p><p>            url: options && options.url != null ? options.url : this.url,</p><p>        });</p><p>    };</p><p>    return ResponseOptions;</p><p>}());</p><p>/**</p><p> * Subclass of {\@link ResponseOptions}, with default values.</p><p> *</p><p> * Default values:</p><p> *  * status: 200</p><p> *  * headers: empty {\@link Headers} object</p><p> *</p><p> * This class could be extended and bound to the {\@link ResponseOptions} class</p><p> * when configuring an {\@link Injector}, in order to override the default options</p><p> * used by {\@link Http} to create {\@link Response Responses}.</p><p> *</p><p> * ### Example ([live demo](http://plnkr.co/edit/qv8DLT?p=preview))</p><p> *</p><p> * ```typescript</p><p> * import {provide} from '\@angular/core';</p><p> * import {bootstrap} from '\@angular/platform-browser/browser';</p><p> * import {HTTP_PROVIDERS, Headers, Http, BaseResponseOptions, ResponseOptions} from</p><p> * '\@angular/http';</p><p> * import {App} from './myapp';</p><p> *</p><p> * class MyOptions extends BaseResponseOptions {</p><p> *   headers:Headers = new Headers({network: 'github'});</p><p> * }</p><p> *</p><p> * bootstrap(App, [HTTP_PROVIDERS, {provide: ResponseOptions, useClass: MyOptions}]);</p><p> * ```</p><p> *</p><p> * The options could also be extended when manually creating a {\@link Response}</p><p> * object.</p><p> *</p><p> * ### Example ([live demo](http://plnkr.co/edit/VngosOWiaExEtbstDoix?p=preview))</p><p> *</p><p> * ```</p><p> * import {BaseResponseOptions, Response} from '\@angular/http';</p><p> *</p><p> * var options = new BaseResponseOptions();</p><p> * var res = new Response(options.merge({</p><p> *   body: 'Angular',</p><p> *   headers: new Headers({framework: 'angular'})</p><p> * }));</p><p> * console.log('res.headers.get("framework"):', res.headers.get('framework')); // angular</p><p> * console.log('res.text():', res.text()); // Angular;</p><p> * ```</p><p> *</p><p> * \@experimental</p><p> */</p><p>var BaseResponseOptions = (function (_super) {</p><p>    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](BaseResponseOptions, _super);</p><p>    function BaseResponseOptions() {</p><p>        return _super.call(this, { status: 200, statusText: 'Ok', type: ResponseType.Default, headers: new Headers() }) || this;</p><p>    }</p><p>    return BaseResponseOptions;</p><p>}(ResponseOptions));</p><p>BaseResponseOptions.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>BaseResponseOptions.ctorParameters = function () { return []; };</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * Abstract class from which real backends are derived.</p><p> *</p><p> * The primary purpose of a `ConnectionBackend` is to create new connections to fulfill a given</p><p> * {\@link Request}.</p><p> *</p><p> * \@experimental</p><p> * @abstract</p><p> */</p><p>var ConnectionBackend = (function () {</p><p>    function ConnectionBackend() {</p><p>    }</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} request</p><p>     * @return {?}</p><p>     */</p><p>    ConnectionBackend.prototype.createConnection = function (request) { };</p><p>    return ConnectionBackend;</p><p>}());</p><p>/**</p><p> * Abstract class from which real connections are derived.</p><p> *</p><p> * \@experimental</p><p> * @abstract</p><p> */</p><p>var Connection = (function () {</p><p>    function Connection() {</p><p>    }</p><p>    return Connection;</p><p>}());</p><p>/**</p><p> * An XSRFStrategy configures XSRF protection (e.g. via headers) on an HTTP request.</p><p> *</p><p> * \@experimental</p><p> * @abstract</p><p> */</p><p>var XSRFStrategy = (function () {</p><p>    function XSRFStrategy() {</p><p>    }</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} req</p><p>     * @return {?}</p><p>     */</p><p>    XSRFStrategy.prototype.configureRequest = function (req) { };</p><p>    return XSRFStrategy;</p><p>}());</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * @param {?} method</p><p> * @return {?}</p><p> */</p><p>function normalizeMethodName(method) {</p><p>    if (typeof method !== 'string')</p><p>        return method;</p><p>    switch (method.toUpperCase()) {</p><p>        case 'GET':</p><p>            return RequestMethod.Get;</p><p>        case 'POST':</p><p>            return RequestMethod.Post;</p><p>        case 'PUT':</p><p>            return RequestMethod.Put;</p><p>        case 'DELETE':</p><p>            return RequestMethod.Delete;</p><p>        case 'OPTIONS':</p><p>            return RequestMethod.Options;</p><p>        case 'HEAD':</p><p>            return RequestMethod.Head;</p><p>        case 'PATCH':</p><p>            return RequestMethod.Patch;</p><p>    }</p><p>    throw new Error("Invalid request method. The method \"" + method + "\" is not supported.");</p><p>}</p><p>var isSuccess = function (status) { return (status >= 200 && status < 300); };</p><p>/**</p><p> * @param {?} xhr</p><p> * @return {?}</p><p> */</p><p>function getResponseURL(xhr) {</p><p>    if ('responseURL' in xhr) {</p><p>        return xhr.responseURL;</p><p>    }</p><p>    if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {</p><p>        return xhr.getResponseHeader('X-Request-URL');</p><p>    }</p><p>    return null;</p><p>}</p><p>/**</p><p> * @param {?} input</p><p> * @return {?}</p><p> */</p><p>/**</p><p> * @param {?} input</p><p> * @return {?}</p><p> */</p><p>function stringToArrayBuffer(input) {</p><p>    var /** @type {?} */ view = new Uint16Array(input.length);</p><p>    for (var /** @type {?} */ i = 0, /** @type {?} */ strLen = input.length; i < strLen; i++) {</p><p>        view[i] = input.charCodeAt(i);</p><p>    }</p><p>    return view.buffer;</p><p>}</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> * @param {?=} rawParams</p><p> * @return {?}</p><p> */</p><p>function paramParser(rawParams) {</p><p>    if (rawParams === void 0) { rawParams = ''; }</p><p>    var /** @type {?} */ map = new Map();</p><p>    if (rawParams.length > 0) {</p><p>        var /** @type {?} */ params = rawParams.split('&');</p><p>        params.forEach(function (param) {</p><p>            var /** @type {?} */ eqIdx = param.indexOf('=');</p><p>            var _a = eqIdx == -1 ? [param, ''] : [param.slice(0, eqIdx), param.slice(eqIdx + 1)], key = _a[0], val = _a[1];</p><p>            var /** @type {?} */ list = map.get(key) || [];</p><p>            list.push(val);</p><p>            map.set(key, list);</p><p>        });</p><p>    }</p><p>    return map;</p><p>}</p><p>/**</p><p> * \@experimental</p><p> *</p><p> */</p><p>var QueryEncoder = (function () {</p><p>    function QueryEncoder() {</p><p>    }</p><p>    /**</p><p>     * @param {?} k</p><p>     * @return {?}</p><p>     */</p><p>    QueryEncoder.prototype.encodeKey = function (k) { return standardEncoding(k); };</p><p>    /**</p><p>     * @param {?} v</p><p>     * @return {?}</p><p>     */</p><p>    QueryEncoder.prototype.encodeValue = function (v) { return standardEncoding(v); };</p><p>    return QueryEncoder;</p><p>}());</p><p>/**</p><p> * @param {?} v</p><p> * @return {?}</p><p> */</p><p>function standardEncoding(v) {</p><p>    return encodeURIComponent(v)</p><p>        .replace(/%40/gi, '@')</p><p>        .replace(/%3A/gi, ':')</p><p>        .replace(/%24/gi, '$')</p><p>        .replace(/%2C/gi, ',')</p><p>        .replace(/%3B/gi, ';')</p><p>        .replace(/%2B/gi, '+')</p><p>        .replace(/%3D/gi, '=')</p><p>        .replace(/%3F/gi, '?')</p><p>        .replace(/%2F/gi, '/');</p><p>}</p><p>/**</p><p> * Map-like representation of url search parameters, based on</p><p> * [URLSearchParams](https://url.spec.whatwg.org/#urlsearchparams) in the url living standard,</p><p> * with several extensions for merging URLSearchParams objects:</p><p> *   - setAll()</p><p> *   - appendAll()</p><p> *   - replaceAll()</p><p> *</p><p> * This class accepts an optional second parameter of ${\@link QueryEncoder},</p><p> * which is used to serialize parameters before making a request. By default,</p><p> * `QueryEncoder` encodes keys and values of parameters using `encodeURIComponent`,</p><p> * and then un-encodes certain characters that are allowed to be part of the query</p><p> * according to IETF RFC 3986: https://tools.ietf.org/html/rfc3986.</p><p> *</p><p> * These are the characters that are not encoded: `! $ \' ( ) * + , ; A 9 - . _ ~ ? /`</p><p> *</p><p> * If the set of allowed query characters is not acceptable for a particular backend,</p><p> * `QueryEncoder` can be subclassed and provided as the 2nd argument to URLSearchParams.</p><p> *</p><p> * ```</p><p> * import {URLSearchParams, QueryEncoder} from '\@angular/http';</p><p> * class MyQueryEncoder extends QueryEncoder {</p><p> *   encodeKey(k: string): string {</p><p> *     return myEncodingFunction(k);</p><p> *   }</p><p> *</p><p> *   encodeValue(v: string): string {</p><p> *     return myEncodingFunction(v);</p><p> *   }</p><p> * }</p><p> *</p><p> * let params = new URLSearchParams('', new MyQueryEncoder());</p><p> * ```</p><p> * \@experimental</p><p> */</p><p>var URLSearchParams = (function () {</p><p>    /**</p><p>     * @param {?=} rawParams</p><p>     * @param {?=} queryEncoder</p><p>     */</p><p>    function URLSearchParams(rawParams, queryEncoder) {</p><p>        if (rawParams === void 0) { rawParams = ''; }</p><p>        if (queryEncoder === void 0) { queryEncoder = new QueryEncoder(); }</p><p>        this.rawParams = rawParams;</p><p>        this.queryEncoder = queryEncoder;</p><p>        this.paramsMap = paramParser(rawParams);</p><p>    }</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    URLSearchParams.prototype.clone = function () {</p><p>        var /** @type {?} */ clone = new URLSearchParams('', this.queryEncoder);</p><p>        clone.appendAll(this);</p><p>        return clone;</p><p>    };</p><p>    /**</p><p>     * @param {?} param</p><p>     * @return {?}</p><p>     */</p><p>    URLSearchParams.prototype.has = function (param) { return this.paramsMap.has(param); };</p><p>    /**</p><p>     * @param {?} param</p><p>     * @return {?}</p><p>     */</p><p>    URLSearchParams.prototype.get = function (param) {</p><p>        var /** @type {?} */ storedParam = this.paramsMap.get(param);</p><p>        return Array.isArray(storedParam) ? storedParam[0] : null;</p><p>    };</p><p>    /**</p><p>     * @param {?} param</p><p>     * @return {?}</p><p>     */</p><p>    URLSearchParams.prototype.getAll = function (param) { return this.paramsMap.get(param) || []; };</p><p>    /**</p><p>     * @param {?} param</p><p>     * @param {?} val</p><p>     * @return {?}</p><p>     */</p><p>    URLSearchParams.prototype.set = function (param, val) {</p><p>        if (val === void 0 || val === null) {</p><p>            this.delete(param);</p><p>            return;</p><p>        }</p><p>        var /** @type {?} */ list = this.paramsMap.get(param) || [];</p><p>        list.length = 0;</p><p>        list.push(val);</p><p>        this.paramsMap.set(param, list);</p><p>    };</p><p>    /**</p><p>     * @param {?} searchParams</p><p>     * @return {?}</p><p>     */</p><p>    URLSearchParams.prototype.setAll = function (searchParams) {</p><p>        var _this = this;</p><p>        searchParams.paramsMap.forEach(function (value, param) {</p><p>            var /** @type {?} */ list = _this.paramsMap.get(param) || [];</p><p>            list.length = 0;</p><p>            list.push(value[0]);</p><p>            _this.paramsMap.set(param, list);</p><p>        });</p><p>    };</p><p>    /**</p><p>     * @param {?} param</p><p>     * @param {?} val</p><p>     * @return {?}</p><p>     */</p><p>    URLSearchParams.prototype.append = function (param, val) {</p><p>        if (val === void 0 || val === null)</p><p>            return;</p><p>        var /** @type {?} */ list = this.paramsMap.get(param) || [];</p><p>        list.push(val);</p><p>        this.paramsMap.set(param, list);</p><p>    };</p><p>    /**</p><p>     * @param {?} searchParams</p><p>     * @return {?}</p><p>     */</p><p>    URLSearchParams.prototype.appendAll = function (searchParams) {</p><p>        var _this = this;</p><p>        searchParams.paramsMap.forEach(function (value, param) {</p><p>            var /** @type {?} */ list = _this.paramsMap.get(param) || [];</p><p>            for (var /** @type {?} */ i = 0; i < value.length; ++i) {</p><p>                list.push(value[i]);</p><p>            }</p><p>            _this.paramsMap.set(param, list);</p><p>        });</p><p>    };</p><p>    /**</p><p>     * @param {?} searchParams</p><p>     * @return {?}</p><p>     */</p><p>    URLSearchParams.prototype.replaceAll = function (searchParams) {</p><p>        var _this = this;</p><p>        searchParams.paramsMap.forEach(function (value, param) {</p><p>            var /** @type {?} */ list = _this.paramsMap.get(param) || [];</p><p>            list.length = 0;</p><p>            for (var /** @type {?} */ i = 0; i < value.length; ++i) {</p><p>                list.push(value[i]);</p><p>            }</p><p>            _this.paramsMap.set(param, list);</p><p>        });</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    URLSearchParams.prototype.toString = function () {</p><p>        var _this = this;</p><p>        var /** @type {?} */ paramsList = [];</p><p>        this.paramsMap.forEach(function (values, k) {</p><p>            values.forEach(function (v) { return paramsList.push(_this.queryEncoder.encodeKey(k) + '=' + _this.queryEncoder.encodeValue(v)); });</p><p>        });</p><p>        return paramsList.join('&');</p><p>    };</p><p>    /**</p><p>     * @param {?} param</p><p>     * @return {?}</p><p>     */</p><p>    URLSearchParams.prototype.delete = function (param) { this.paramsMap.delete(param); };</p><p>    return URLSearchParams;</p><p>}());</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * HTTP request body used by both {\@link Request} and {\@link Response}</p><p> * https://fetch.spec.whatwg.org/#body</p><p> * @abstract</p><p> */</p><p>var Body = (function () {</p><p>    function Body() {</p><p>    }</p><p>    /**</p><p>     * Attempts to return body as parsed `JSON` object, or raises an exception.</p><p>     * @return {?}</p><p>     */</p><p>    Body.prototype.json = function () {</p><p>        if (typeof this._body === 'string') {</p><p>            return JSON.parse(/** @type {?} */ (this._body));</p><p>        }</p><p>        if (this._body instanceof ArrayBuffer) {</p><p>            return JSON.parse(this.text());</p><p>        }</p><p>        return this._body;</p><p>    };</p><p>    /**</p><p>     * Returns the body as a string, presuming `toString()` can be called on the response body.</p><p>     *</p><p>     * When decoding an `ArrayBuffer`, the optional `encodingHint` parameter determines how the</p><p>     * bytes in the buffer will be interpreted. Valid values are:</p><p>     *</p><p>     * - `legacy` - incorrectly interpret the bytes as UTF-16 (technically, UCS-2). Only characters</p><p>     *   in the Basic Multilingual Plane are supported, surrogate pairs are not handled correctly.</p><p>     *   In addition, the endianness of the 16-bit octet pairs in the `ArrayBuffer` is not taken</p><p>     *   into consideration. This is the default behavior to avoid breaking apps, but should be</p><p>     *   considered deprecated.</p><p>     *</p><p>     * - `iso-8859` - interpret the bytes as ISO-8859 (which can be used for ASCII encoded text).</p><p>     * @param {?=} encodingHint</p><p>     * @return {?}</p><p>     */</p><p>    Body.prototype.text = function (encodingHint) {</p><p>        if (encodingHint === void 0) { encodingHint = 'legacy'; }</p><p>        if (this._body instanceof URLSearchParams) {</p><p>            return this._body.toString();</p><p>        }</p><p>        if (this._body instanceof ArrayBuffer) {</p><p>            switch (encodingHint) {</p><p>                case 'legacy':</p><p>                    return String.fromCharCode.apply(null, new Uint16Array(/** @type {?} */ (this._body)));</p><p>                case 'iso-8859':</p><p>                    return String.fromCharCode.apply(null, new Uint8Array(/** @type {?} */ (this._body)));</p><p>                default:</p><p>                    throw new Error("Invalid value for encodingHint: " + encodingHint);</p><p>            }</p><p>        }</p><p>        if (this._body == null) {</p><p>            return '';</p><p>        }</p><p>        if (typeof this._body === 'object') {</p><p>            return JSON.stringify(this._body, null, 2);</p><p>        }</p><p>        return this._body.toString();</p><p>    };</p><p>    /**</p><p>     * Return the body as an ArrayBuffer</p><p>     * @return {?}</p><p>     */</p><p>    Body.prototype.arrayBuffer = function () {</p><p>        if (this._body instanceof ArrayBuffer) {</p><p>            return (this._body);</p><p>        }</p><p>        return stringToArrayBuffer(this.text());</p><p>    };</p><p>    /**</p><p>     * Returns the request's body as a Blob, assuming that body exists.</p><p>     * @return {?}</p><p>     */</p><p>    Body.prototype.blob = function () {</p><p>        if (this._body instanceof Blob) {</p><p>            return (this._body);</p><p>        }</p><p>        if (this._body instanceof ArrayBuffer) {</p><p>            return new Blob([this._body]);</p><p>        }</p><p>        throw new Error('The request body isn\'t either a blob or an array buffer');</p><p>    };</p><p>    return Body;</p><p>}());</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * Creates `Response` instances from provided values.</p><p> *</p><p> * Though this object isn't</p><p> * usually instantiated by end-users, it is the primary object interacted with when it comes time to</p><p> * add data to a view.</p><p> *</p><p> * ### Example</p><p> *</p><p> * ```</p><p> * http.request('my-friends.txt').subscribe(response => this.friends = response.text());</p><p> * ```</p><p> *</p><p> * The Response's interface is inspired by the Response constructor defined in the [Fetch</p><p> * Spec](https://fetch.spec.whatwg.org/#response-class), but is considered a static value whose body</p><p> * can be accessed many times. There are other differences in the implementation, but this is the</p><p> * most significant.</p><p> *</p><p> * \@experimental</p><p> */</p><p>var Response = (function (_super) {</p><p>    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](Response, _super);</p><p>    /**</p><p>     * @param {?} responseOptions</p><p>     */</p><p>    function Response(responseOptions) {</p><p>        var _this = _super.call(this) || this;</p><p>        _this._body = responseOptions.body;</p><p>        _this.status = responseOptions.status;</p><p>        _this.ok = (_this.status >= 200 && _this.status <= 299);</p><p>        _this.statusText = responseOptions.statusText;</p><p>        _this.headers = responseOptions.headers;</p><p>        _this.type = responseOptions.type;</p><p>        _this.url = responseOptions.url;</p><p>        return _this;</p><p>    }</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    Response.prototype.toString = function () {</p><p>        return "Response with status: " + this.status + " " + this.statusText + " for URL: " + this.url;</p><p>    };</p><p>    return Response;</p><p>}(Body));</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>var _nextRequestId = 0;</p><p>var JSONP_HOME = '__ng_jsonp__';</p><p>var _jsonpConnections = null;</p><p>/**</p><p> * @return {?}</p><p> */</p><p>function _getJsonpConnections() {</p><p>    var /** @type {?} */ w = typeof window == 'object' ? window : {};</p><p>    if (_jsonpConnections === null) {</p><p>        _jsonpConnections = w[JSONP_HOME] = {};</p><p>    }</p><p>    return _jsonpConnections;</p><p>}</p><p>var BrowserJsonp = (function () {</p><p>    function BrowserJsonp() {</p><p>    }</p><p>    /**</p><p>     * @param {?} url</p><p>     * @return {?}</p><p>     */</p><p>    BrowserJsonp.prototype.build = function (url) {</p><p>        var /** @type {?} */ node = document.createElement('script');</p><p>        node.src = url;</p><p>        return node;</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    BrowserJsonp.prototype.nextRequestID = function () { return "__req" + _nextRequestId++; };</p><p>    /**</p><p>     * @param {?} id</p><p>     * @return {?}</p><p>     */</p><p>    BrowserJsonp.prototype.requestCallback = function (id) { return JSONP_HOME + "." + id + ".finished"; };</p><p>    /**</p><p>     * @param {?} id</p><p>     * @param {?} connection</p><p>     * @return {?}</p><p>     */</p><p>    BrowserJsonp.prototype.exposeConnection = function (id, connection) {</p><p>        var /** @type {?} */ connections = _getJsonpConnections();</p><p>        connections[id] = connection;</p><p>    };</p><p>    /**</p><p>     * @param {?} id</p><p>     * @return {?}</p><p>     */</p><p>    BrowserJsonp.prototype.removeConnection = function (id) {</p><p>        var /** @type {?} */ connections = _getJsonpConnections();</p><p>        connections[id] = null;</p><p>    };</p><p>    /**</p><p>     * @param {?} node</p><p>     * @return {?}</p><p>     */</p><p>    BrowserJsonp.prototype.send = function (node) { document.body.appendChild(/** @type {?} */ ((node))); };</p><p>    /**</p><p>     * @param {?} node</p><p>     * @return {?}</p><p>     */</p><p>    BrowserJsonp.prototype.cleanup = function (node) {</p><p>        if (node.parentNode) {</p><p>            node.parentNode.removeChild(/** @type {?} */ ((node)));</p><p>        }</p><p>    };</p><p>    return BrowserJsonp;</p><p>}());</p><p>BrowserJsonp.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>BrowserJsonp.ctorParameters = function () { return []; };</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>var JSONP_ERR_NO_CALLBACK = 'JSONP injected script did not invoke callback.';</p><p>var JSONP_ERR_WRONG_METHOD = 'JSONP requests must use GET request method.';</p><p>/**</p><p> * Abstract base class for an in-flight JSONP request.</p><p> *</p><p> * \@experimental</p><p> * @abstract</p><p> */</p><p>var JSONPConnection = (function () {</p><p>    function JSONPConnection() {</p><p>    }</p><p>    /**</p><p>     * Callback called when the JSONP request completes, to notify the application</p><p>     * of the new data.</p><p>     * @abstract</p><p>     * @param {?=} data</p><p>     * @return {?}</p><p>     */</p><p>    JSONPConnection.prototype.finished = function (data) { };</p><p>    return JSONPConnection;</p><p>}());</p><p>var JSONPConnection_ = (function (_super) {</p><p>    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](JSONPConnection_, _super);</p><p>    /**</p><p>     * @param {?} req</p><p>     * @param {?} _dom</p><p>     * @param {?=} baseResponseOptions</p><p>     */</p><p>    function JSONPConnection_(req, _dom, baseResponseOptions) {</p><p>        var _this = _super.call(this) || this;</p><p>        _this._dom = _dom;</p><p>        _this.baseResponseOptions = baseResponseOptions;</p><p>        _this._finished = false;</p><p>        if (req.method !== RequestMethod.Get) {</p><p>            throw new TypeError(JSONP_ERR_WRONG_METHOD);</p><p>        }</p><p>        _this.request = req;</p><p>        _this.response = new __WEBPACK_IMPORTED_MODULE_2_rxjs_Observable__["Observable"](function (responseObserver) {</p><p>            _this.readyState = ReadyState.Loading;</p><p>            var id = _this._id = _dom.nextRequestID();</p><p>            _dom.exposeConnection(id, _this);</p><p>            // Workaround Dart</p><p>            // url = url.replace(/=JSONP_CALLBACK(&|$)/, `generated method`);</p><p>            var callback = _dom.requestCallback(_this._id);</p><p>            var url = req.url;</p><p>            if (url.indexOf('=JSONP_CALLBACK&') > -1) {</p><p>                url = url.replace('=JSONP_CALLBACK&', "=" + callback + "&");</p><p>            }</p><p>            else if (url.lastIndexOf('=JSONP_CALLBACK') === url.length - '=JSONP_CALLBACK'.length) {</p><p>                url = url.substring(0, url.length - '=JSONP_CALLBACK'.length) + ("=" + callback);</p><p>            }</p><p>            var script = _this._script = _dom.build(url);</p><p>            var onLoad = function (event) {</p><p>                if (_this.readyState === ReadyState.Cancelled)</p><p>                    return;</p><p>                _this.readyState = ReadyState.Done;</p><p>                _dom.cleanup(script);</p><p>                if (!_this._finished) {</p><p>                    var responseOptions_1 = new ResponseOptions({ body: JSONP_ERR_NO_CALLBACK, type: ResponseType.Error, url: url });</p><p>                    if (baseResponseOptions) {</p><p>                        responseOptions_1 = baseResponseOptions.merge(responseOptions_1);</p><p>                    }</p><p>                    responseObserver.error(new Response(responseOptions_1));</p><p>                    return;</p><p>                }</p><p>                var responseOptions = new ResponseOptions({ body: _this._responseData, url: url });</p><p>                if (_this.baseResponseOptions) {</p><p>                    responseOptions = _this.baseResponseOptions.merge(responseOptions);</p><p>                }</p><p>                responseObserver.next(new Response(responseOptions));</p><p>                responseObserver.complete();</p><p>            };</p><p>            var onError = function (error) {</p><p>                if (_this.readyState === ReadyState.Cancelled)</p><p>                    return;</p><p>                _this.readyState = ReadyState.Done;</p><p>                _dom.cleanup(script);</p><p>                var responseOptions = new ResponseOptions({ body: error.message, type: ResponseType.Error });</p><p>                if (baseResponseOptions) {</p><p>                    responseOptions = baseResponseOptions.merge(responseOptions);</p><p>                }</p><p>                responseObserver.error(new Response(responseOptions));</p><p>            };</p><p>            script.addEventListener('load', onLoad);</p><p>            script.addEventListener('error', onError);</p><p>            _dom.send(script);</p><p>            return function () {</p><p>                _this.readyState = ReadyState.Cancelled;</p><p>                script.removeEventListener('load', onLoad);</p><p>                script.removeEventListener('error', onError);</p><p>                _this._dom.cleanup(script);</p><p>            };</p><p>        });</p><p>        return _this;</p><p>    }</p><p>    /**</p><p>     * @param {?=} data</p><p>     * @return {?}</p><p>     */</p><p>    JSONPConnection_.prototype.finished = function (data) {</p><p>        // Don't leak connections</p><p>        this._finished = true;</p><p>        this._dom.removeConnection(this._id);</p><p>        if (this.readyState === ReadyState.Cancelled)</p><p>            return;</p><p>        this._responseData = data;</p><p>    };</p><p>    return JSONPConnection_;</p><p>}(JSONPConnection));</p><p>/**</p><p> * A {\@link ConnectionBackend} that uses the JSONP strategy of making requests.</p><p> *</p><p> * \@experimental</p><p> * @abstract</p><p> */</p><p>var JSONPBackend = (function (_super) {</p><p>    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](JSONPBackend, _super);</p><p>    function JSONPBackend() {</p><p>        return _super !== null && _super.apply(this, arguments) || this;</p><p>    }</p><p>    return JSONPBackend;</p><p>}(ConnectionBackend));</p><p>var JSONPBackend_ = (function (_super) {</p><p>    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](JSONPBackend_, _super);</p><p>    /**</p><p>     * @param {?} _browserJSONP</p><p>     * @param {?} _baseResponseOptions</p><p>     */</p><p>    function JSONPBackend_(_browserJSONP, _baseResponseOptions) {</p><p>        var _this = _super.call(this) || this;</p><p>        _this._browserJSONP = _browserJSONP;</p><p>        _this._baseResponseOptions = _baseResponseOptions;</p><p>        return _this;</p><p>    }</p><p>    /**</p><p>     * @param {?} request</p><p>     * @return {?}</p><p>     */</p><p>    JSONPBackend_.prototype.createConnection = function (request) {</p><p>        return new JSONPConnection_(request, this._browserJSONP, this._baseResponseOptions);</p><p>    };</p><p>    return JSONPBackend_;</p><p>}(JSONPBackend));</p><p>JSONPBackend_.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>JSONPBackend_.ctorParameters = function () { return [</p><p>    { type: BrowserJsonp, },</p><p>    { type: ResponseOptions, },</p><p>]; };</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>var XSSI_PREFIX = /^\)\]\}',?\n/;</p><p>/**</p><p> * Creates connections using `XMLHttpRequest`. Given a fully-qualified</p><p> * request, an `XHRConnection` will immediately create an `XMLHttpRequest` object and send the</p><p> * request.</p><p> *</p><p> * This class would typically not be created or interacted with directly inside applications, though</p><p> * the {\@link MockConnection} may be interacted with in tests.</p><p> *</p><p> * \@experimental</p><p> */</p><p>var XHRConnection = (function () {</p><p>    /**</p><p>     * @param {?} req</p><p>     * @param {?} browserXHR</p><p>     * @param {?=} baseResponseOptions</p><p>     */</p><p>    function XHRConnection(req, browserXHR, baseResponseOptions) {</p><p>        var _this = this;</p><p>        this.request = req;</p><p>        this.response = new __WEBPACK_IMPORTED_MODULE_2_rxjs_Observable__["Observable"](function (responseObserver) {</p><p>            var _xhr = browserXHR.build();</p><p>            _xhr.open(RequestMethod[req.method].toUpperCase(), req.url);</p><p>            if (req.withCredentials != null) {</p><p>                _xhr.withCredentials = req.withCredentials;</p><p>            }</p><p>            // load event handler</p><p>            var onLoad = function () {</p><p>                // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)</p><p>                var status = _xhr.status === 1223 ? 204 : _xhr.status;</p><p>                var body = null;</p><p>                // HTTP 204 means no content</p><p>                if (status !== 204) {</p><p>                    // responseText is the old-school way of retrieving response (supported by IE8 & 9)</p><p>                    // response/responseType properties were introduced in ResourceLoader Level2 spec</p><p>                    // (supported by IE10)</p><p>                    body = (typeof _xhr.response === 'undefined') ? _xhr.responseText : _xhr.response;</p><p>                    // Implicitly strip a potential XSSI prefix.</p><p>                    if (typeof body === 'string') {</p><p>                        body = body.replace(XSSI_PREFIX, '');</p><p>                    }</p><p>                }</p><p>                // fix status code when it is 0 (0 status is undocumented).</p><p>                // Occurs when accessing file resources or on Android 4.1 stock browser</p><p>                // while retrieving files from application cache.</p><p>                if (status === 0) {</p><p>                    status = body ? 200 : 0;</p><p>                }</p><p>                var headers = Headers.fromResponseHeaderString(_xhr.getAllResponseHeaders());</p><p>                // IE 9 does not provide the way to get URL of response</p><p>                var url = getResponseURL(_xhr) || req.url;</p><p>                var statusText = _xhr.statusText || 'OK';</p><p>                var responseOptions = new ResponseOptions({ body: body, status: status, headers: headers, statusText: statusText, url: url });</p><p>                if (baseResponseOptions != null) {</p><p>                    responseOptions = baseResponseOptions.merge(responseOptions);</p><p>                }</p><p>                var response = new Response(responseOptions);</p><p>                response.ok = isSuccess(status);</p><p>                if (response.ok) {</p><p>                    responseObserver.next(response);</p><p>                    // TODO(gdi2290): defer complete if array buffer until done</p><p>                    responseObserver.complete();</p><p>                    return;</p><p>                }</p><p>                responseObserver.error(response);</p><p>            };</p><p>            // error event handler</p><p>            var onError = function (err) {</p><p>                var responseOptions = new ResponseOptions({</p><p>                    body: err,</p><p>                    type: ResponseType.Error,</p><p>                    status: _xhr.status,</p><p>                    statusText: _xhr.statusText,</p><p>                });</p><p>                if (baseResponseOptions != null) {</p><p>                    responseOptions = baseResponseOptions.merge(responseOptions);</p><p>                }</p><p>                responseObserver.error(new Response(responseOptions));</p><p>            };</p><p>            _this.setDetectedContentType(req, _xhr);</p><p>            if (req.headers == null) {</p><p>                req.headers = new Headers();</p><p>            }</p><p>            if (!req.headers.has('Accept')) {</p><p>                req.headers.append('Accept', 'application/json, text/plain, */*');</p><p>            }</p><p>            req.headers.forEach(function (values, name) { return _xhr.setRequestHeader(name, values.join(',')); });</p><p>            // Select the correct buffer type to store the response</p><p>            if (req.responseType != null && _xhr.responseType != null) {</p><p>                switch (req.responseType) {</p><p>                    case ResponseContentType.ArrayBuffer:</p><p>                        _xhr.responseType = 'arraybuffer';</p><p>                        break;</p><p>                    case ResponseContentType.Json:</p><p>                        _xhr.responseType = 'json';</p><p>                        break;</p><p>                    case ResponseContentType.Text:</p><p>                        _xhr.responseType = 'text';</p><p>                        break;</p><p>                    case ResponseContentType.Blob:</p><p>                        _xhr.responseType = 'blob';</p><p>                        break;</p><p>                    default:</p><p>                        throw new Error('The selected responseType is not supported');</p><p>                }</p><p>            }</p><p>            _xhr.addEventListener('load', onLoad);</p><p>            _xhr.addEventListener('error', onError);</p><p>            _xhr.send(_this.request.getBody());</p><p>            return function () {</p><p>                _xhr.removeEventListener('load', onLoad);</p><p>                _xhr.removeEventListener('error', onError);</p><p>                _xhr.abort();</p><p>            };</p><p>        });</p><p>    }</p><p>    /**</p><p>     * @param {?} req</p><p>     * @param {?} _xhr</p><p>     * @return {?}</p><p>     */</p><p>    XHRConnection.prototype.setDetectedContentType = function (req /** TODO Request */, _xhr /** XMLHttpRequest */) {</p><p>        // Skip if a custom Content-Type header is provided</p><p>        if (req.headers != null && req.headers.get('Content-Type') != null) {</p><p>            return;</p><p>        }</p><p>        // Set the detected content type</p><p>        switch (req.contentType) {</p><p>            case ContentType.NONE:</p><p>                break;</p><p>            case ContentType.JSON:</p><p>                _xhr.setRequestHeader('content-type', 'application/json');</p><p>                break;</p><p>            case ContentType.FORM:</p><p>                _xhr.setRequestHeader('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');</p><p>                break;</p><p>            case ContentType.TEXT:</p><p>                _xhr.setRequestHeader('content-type', 'text/plain');</p><p>                break;</p><p>            case ContentType.BLOB:</p><p>                var /** @type {?} */ blob = req.blob();</p><p>                if (blob.type) {</p><p>                    _xhr.setRequestHeader('content-type', blob.type);</p><p>                }</p><p>                break;</p><p>        }</p><p>    };</p><p>    return XHRConnection;</p><p>}());</p><p>/**</p><p> * `XSRFConfiguration` sets up Cross Site Request Forgery (XSRF) protection for the application</p><p> * using a cookie. See https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)</p><p> * for more information on XSRF.</p><p> *</p><p> * Applications can configure custom cookie and header names by binding an instance of this class</p><p> * with different `cookieName` and `headerName` values. See the main HTTP documentation for more</p><p> * details.</p><p> *</p><p> * \@experimental</p><p> */</p><p>var CookieXSRFStrategy = (function () {</p><p>    /**</p><p>     * @param {?=} _cookieName</p><p>     * @param {?=} _headerName</p><p>     */</p><p>    function CookieXSRFStrategy(_cookieName, _headerName) {</p><p>        if (_cookieName === void 0) { _cookieName = 'XSRF-TOKEN'; }</p><p>        if (_headerName === void 0) { _headerName = 'X-XSRF-TOKEN'; }</p><p>        this._cookieName = _cookieName;</p><p>        this._headerName = _headerName;</p><p>    }</p><p>    /**</p><p>     * @param {?} req</p><p>     * @return {?}</p><p>     */</p><p>    CookieXSRFStrategy.prototype.configureRequest = function (req) {</p><p>        var /** @type {?} */ xsrfToken = Object(__WEBPACK_IMPORTED_MODULE_3__angular_platform_browser__["ɵgetDOM"])().getCookie(this._cookieName);</p><p>        if (xsrfToken) {</p><p>            req.headers.set(this._headerName, xsrfToken);</p><p>        }</p><p>    };</p><p>    return CookieXSRFStrategy;</p><p>}());</p><p>/**</p><p> * Creates {\@link XHRConnection} instances.</p><p> *</p><p> * This class would typically not be used by end users, but could be</p><p> * overridden if a different backend implementation should be used,</p><p> * such as in a node backend.</p><p> *</p><p> * ### Example</p><p> *</p><p> * ```</p><p> * import {Http, MyNodeBackend, HTTP_PROVIDERS, BaseRequestOptions} from '\@angular/http';</p><p> * \@Component({</p><p> *   viewProviders: [</p><p> *     HTTP_PROVIDERS,</p><p> *     {provide: Http, useFactory: (backend, options) => {</p><p> *       return new Http(backend, options);</p><p> *     }, deps: [MyNodeBackend, BaseRequestOptions]}]</p><p> * })</p><p> * class MyComponent {</p><p> *   constructor(http:Http) {</p><p> *     http.request('people.json').subscribe(res => this.people = res.json());</p><p> *   }</p><p> * }</p><p> * ```</p><p> * \@experimental</p><p> */</p><p>var XHRBackend = (function () {</p><p>    /**</p><p>     * @param {?} _browserXHR</p><p>     * @param {?} _baseResponseOptions</p><p>     * @param {?} _xsrfStrategy</p><p>     */</p><p>    function XHRBackend(_browserXHR, _baseResponseOptions, _xsrfStrategy) {</p><p>        this._browserXHR = _browserXHR;</p><p>        this._baseResponseOptions = _baseResponseOptions;</p><p>        this._xsrfStrategy = _xsrfStrategy;</p><p>    }</p><p>    /**</p><p>     * @param {?} request</p><p>     * @return {?}</p><p>     */</p><p>    XHRBackend.prototype.createConnection = function (request) {</p><p>        this._xsrfStrategy.configureRequest(request);</p><p>        return new XHRConnection(request, this._browserXHR, this._baseResponseOptions);</p><p>    };</p><p>    return XHRBackend;</p><p>}());</p><p>XHRBackend.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>XHRBackend.ctorParameters = function () { return [</p><p>    { type: BrowserXhr, },</p><p>    { type: ResponseOptions, },</p><p>    { type: XSRFStrategy, },</p><p>]; };</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * Creates a request options object to be optionally provided when instantiating a</p><p> * {\@link Request}.</p><p> *</p><p> * This class is based on the `RequestInit` description in the [Fetch</p><p> * Spec](https://fetch.spec.whatwg.org/#requestinit).</p><p> *</p><p> * All values are null by default. Typical defaults can be found in the {\@link BaseRequestOptions}</p><p> * class, which sub-classes `RequestOptions`.</p><p> *</p><p> * ```typescript</p><p> * import {RequestOptions, Request, RequestMethod} from '\@angular/http';</p><p> *</p><p> * const options = new RequestOptions({</p><p> *   method: RequestMethod.Post,</p><p> *   url: 'https://google.com'</p><p> * });</p><p> * const req = new Request(options);</p><p> * console.log('req.method:', RequestMethod[req.method]); // Post</p><p> * console.log('options.url:', options.url); // https://google.com</p><p> * ```</p><p> *</p><p> * \@experimental</p><p> */</p><p>var RequestOptions = (function () {</p><p>    /**</p><p>     * @param {?=} opts</p><p>     */</p><p>    function RequestOptions(opts) {</p><p>        if (opts === void 0) { opts = {}; }</p><p>        var method = opts.method, headers = opts.headers, body = opts.body, url = opts.url, search = opts.search, params = opts.params, withCredentials = opts.withCredentials, responseType = opts.responseType;</p><p>        this.method = method != null ? normalizeMethodName(method) : null;</p><p>        this.headers = headers != null ? headers : null;</p><p>        this.body = body != null ? body : null;</p><p>        this.url = url != null ? url : null;</p><p>        this.params = this._mergeSearchParams(params || search);</p><p>        this.withCredentials = withCredentials != null ? withCredentials : null;</p><p>        this.responseType = responseType != null ? responseType : null;</p><p>    }</p><p>    Object.defineProperty(RequestOptions.prototype, "search", {</p><p>        /**</p><p>         * @deprecated from 4.0.0. Use params instead.</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this.params; },</p><p>        /**</p><p>         * @deprecated from 4.0.0. Use params instead.</p><p>         * @param {?} params</p><p>         * @return {?}</p><p>         */</p><p>        set: function (params) { this.params = params; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    /**</p><p>     * Creates a copy of the `RequestOptions` instance, using the optional input as values to override</p><p>     * existing values. This method will not change the values of the instance on which it is being</p><p>     * called.</p><p>     *</p><p>     * Note that `headers` and `search` will override existing values completely if present in</p><p>     * the `options` object. If these values should be merged, it should be done prior to calling</p><p>     * `merge` on the `RequestOptions` instance.</p><p>     *</p><p>     * ```typescript</p><p>     * import {RequestOptions, Request, RequestMethod} from '\@angular/http';</p><p>     *</p><p>     * const options = new RequestOptions({</p><p>     *   method: RequestMethod.Post</p><p>     * });</p><p>     * const req = new Request(options.merge({</p><p>     *   url: 'https://google.com'</p><p>     * }));</p><p>     * console.log('req.method:', RequestMethod[req.method]); // Post</p><p>     * console.log('options.url:', options.url); // null</p><p>     * console.log('req.url:', req.url); // https://google.com</p><p>     * ```</p><p>     * @param {?=} options</p><p>     * @return {?}</p><p>     */</p><p>    RequestOptions.prototype.merge = function (options) {</p><p>        return new RequestOptions({</p><p>            method: options && options.method != null ? options.method : this.method,</p><p>            headers: options && options.headers != null ? options.headers : new Headers(this.headers),</p><p>            body: options && options.body != null ? options.body : this.body,</p><p>            url: options && options.url != null ? options.url : this.url,</p><p>            params: options && this._mergeSearchParams(options.params || options.search),</p><p>            withCredentials: options && options.withCredentials != null ? options.withCredentials :</p><p>                this.withCredentials,</p><p>            responseType: options && options.responseType != null ? options.responseType :</p><p>                this.responseType</p><p>        });</p><p>    };</p><p>    /**</p><p>     * @param {?=} params</p><p>     * @return {?}</p><p>     */</p><p>    RequestOptions.prototype._mergeSearchParams = function (params) {</p><p>        if (!params)</p><p>            return this.params;</p><p>        if (params instanceof URLSearchParams) {</p><p>            return params.clone();</p><p>        }</p><p>        if (typeof params === 'string') {</p><p>            return new URLSearchParams(params);</p><p>        }</p><p>        return this._parseParams(params);</p><p>    };</p><p>    /**</p><p>     * @param {?=} objParams</p><p>     * @return {?}</p><p>     */</p><p>    RequestOptions.prototype._parseParams = function (objParams) {</p><p>        var _this = this;</p><p>        if (objParams === void 0) { objParams = {}; }</p><p>        var /** @type {?} */ params = new URLSearchParams();</p><p>        Object.keys(objParams).forEach(function (key) {</p><p>            var /** @type {?} */ value = objParams[key];</p><p>            if (Array.isArray(value)) {</p><p>                value.forEach(function (item) { return _this._appendParam(key, item, params); });</p><p>            }</p><p>            else {</p><p>                _this._appendParam(key, value, params);</p><p>            }</p><p>        });</p><p>        return params;</p><p>    };</p><p>    /**</p><p>     * @param {?} key</p><p>     * @param {?} value</p><p>     * @param {?} params</p><p>     * @return {?}</p><p>     */</p><p>    RequestOptions.prototype._appendParam = function (key, value, params) {</p><p>        if (typeof value !== 'string') {</p><p>            value = JSON.stringify(value);</p><p>        }</p><p>        params.append(key, value);</p><p>    };</p><p>    return RequestOptions;</p><p>}());</p><p>/**</p><p> * Subclass of {\@link RequestOptions}, with default values.</p><p> *</p><p> * Default values:</p><p> *  * method: {\@link RequestMethod RequestMethod.Get}</p><p> *  * headers: empty {\@link Headers} object</p><p> *</p><p> * This class could be extended and bound to the {\@link RequestOptions} class</p><p> * when configuring an {\@link Injector}, in order to override the default options</p><p> * used by {\@link Http} to create and send {\@link Request Requests}.</p><p> *</p><p> * ```typescript</p><p> * import {BaseRequestOptions, RequestOptions} from '\@angular/http';</p><p> *</p><p> * class MyOptions extends BaseRequestOptions {</p><p> *   search: string = 'coreTeam=true';</p><p> * }</p><p> *</p><p> * {provide: RequestOptions, useClass: MyOptions};</p><p> * ```</p><p> *</p><p> * The options could also be extended when manually creating a {\@link Request}</p><p> * object.</p><p> *</p><p> * ```</p><p> * import {BaseRequestOptions, Request, RequestMethod} from '\@angular/http';</p><p> *</p><p> * const options = new BaseRequestOptions();</p><p> * const req = new Request(options.merge({</p><p> *   method: RequestMethod.Post,</p><p> *   url: 'https://google.com'</p><p> * }));</p><p> * console.log('req.method:', RequestMethod[req.method]); // Post</p><p> * console.log('options.url:', options.url); // null</p><p> * console.log('req.url:', req.url); // https://google.com</p><p> * ```</p><p> *</p><p> * \@experimental</p><p> */</p><p>var BaseRequestOptions = (function (_super) {</p><p>    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](BaseRequestOptions, _super);</p><p>    function BaseRequestOptions() {</p><p>        return _super.call(this, { method: RequestMethod.Get, headers: new Headers() }) || this;</p><p>    }</p><p>    return BaseRequestOptions;</p><p>}(RequestOptions));</p><p>BaseRequestOptions.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>BaseRequestOptions.ctorParameters = function () { return []; };</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * Creates `Request` instances from provided values.</p><p> *</p><p> * The Request's interface is inspired by the Request constructor defined in the [Fetch</p><p> * Spec](https://fetch.spec.whatwg.org/#request-class),</p><p> * but is considered a static value whose body can be accessed many times. There are other</p><p> * differences in the implementation, but this is the most significant.</p><p> *</p><p> * `Request` instances are typically created by higher-level classes, like {\@link Http} and</p><p> * {\@link Jsonp}, but it may occasionally be useful to explicitly create `Request` instances.</p><p> * One such example is when creating services that wrap higher-level services, like {\@link Http},</p><p> * where it may be useful to generate a `Request` with arbitrary headers and search params.</p><p> *</p><p> * ```typescript</p><p> * import {Injectable, Injector} from '\@angular/core';</p><p> * import {HTTP_PROVIDERS, Http, Request, RequestMethod} from '\@angular/http';</p><p> *</p><p> * \@Injectable()</p><p> * class AutoAuthenticator {</p><p> *   constructor(public http:Http) {}</p><p> *   request(url:string) {</p><p> *     return this.http.request(new Request({</p><p> *       method: RequestMethod.Get,</p><p> *       url: url,</p><p> *       search: 'password=123'</p><p> *     }));</p><p> *   }</p><p> * }</p><p> *</p><p> * var injector = Injector.resolveAndCreate([HTTP_PROVIDERS, AutoAuthenticator]);</p><p> * var authenticator = injector.get(AutoAuthenticator);</p><p> * authenticator.request('people.json').subscribe(res => {</p><p> *   //URL should have included '?password=123'</p><p> *   console.log('people', res.json());</p><p> * });</p><p> * ```</p><p> *</p><p> * \@experimental</p><p> */</p><p>var Request = (function (_super) {</p><p>    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](Request, _super);</p><p>    /**</p><p>     * @param {?} requestOptions</p><p>     */</p><p>    function Request(requestOptions) {</p><p>        var _this = _super.call(this) || this;</p><p>        // TODO: assert that url is present</p><p>        var url = requestOptions.url;</p><p>        _this.url = requestOptions.url;</p><p>        var paramsArg = requestOptions.params || requestOptions.search;</p><p>        if (paramsArg) {</p><p>            var params = void 0;</p><p>            if (typeof paramsArg === 'object' && !(paramsArg instanceof URLSearchParams)) {</p><p>                params = urlEncodeParams(paramsArg).toString();</p><p>            }</p><p>            else {</p><p>                params = paramsArg.toString();</p><p>            }</p><p>            if (params.length > 0) {</p><p>                var prefix = '?';</p><p>                if (_this.url.indexOf('?') != -1) {</p><p>                    prefix = (_this.url[_this.url.length - 1] == '&') ? '' : '&';</p><p>                }</p><p>                // TODO: just delete search-query-looking string in url?</p><p>                _this.url = url + prefix + params;</p><p>            }</p><p>        }</p><p>        _this._body = requestOptions.body;</p><p>        _this.method = normalizeMethodName(requestOptions.method);</p><p>        // TODO(jeffbcross): implement behavior</p><p>        // Defaults to 'omit', consistent with browser</p><p>        _this.headers = new Headers(requestOptions.headers);</p><p>        _this.contentType = _this.detectContentType();</p><p>        _this.withCredentials = requestOptions.withCredentials;</p><p>        _this.responseType = requestOptions.responseType;</p><p>        return _this;</p><p>    }</p><p>    /**</p><p>     * Returns the content type enum based on header options.</p><p>     * @return {?}</p><p>     */</p><p>    Request.prototype.detectContentType = function () {</p><p>        switch (this.headers.get('content-type')) {</p><p>            case 'application/json':</p><p>                return ContentType.JSON;</p><p>            case 'application/x-www-form-urlencoded':</p><p>                return ContentType.FORM;</p><p>            case 'multipart/form-data':</p><p>                return ContentType.FORM_DATA;</p><p>            case 'text/plain':</p><p>            case 'text/html':</p><p>                return ContentType.TEXT;</p><p>            case 'application/octet-stream':</p><p>                return this._body instanceof ArrayBuffer$1 ? ContentType.ARRAY_BUFFER : ContentType.BLOB;</p><p>            default:</p><p>                return this.detectContentTypeFromBody();</p><p>        }</p><p>    };</p><p>    /**</p><p>     * Returns the content type of request's body based on its type.</p><p>     * @return {?}</p><p>     */</p><p>    Request.prototype.detectContentTypeFromBody = function () {</p><p>        if (this._body == null) {</p><p>            return ContentType.NONE;</p><p>        }</p><p>        else if (this._body instanceof URLSearchParams) {</p><p>            return ContentType.FORM;</p><p>        }</p><p>        else if (this._body instanceof FormData) {</p><p>            return ContentType.FORM_DATA;</p><p>        }</p><p>        else if (this._body instanceof Blob$1) {</p><p>            return ContentType.BLOB;</p><p>        }</p><p>        else if (this._body instanceof ArrayBuffer$1) {</p><p>            return ContentType.ARRAY_BUFFER;</p><p>        }</p><p>        else if (this._body && typeof this._body === 'object') {</p><p>            return ContentType.JSON;</p><p>        }</p><p>        else {</p><p>            return ContentType.TEXT;</p><p>        }</p><p>    };</p><p>    /**</p><p>     * Returns the request's body according to its type. If body is undefined, return</p><p>     * null.</p><p>     * @return {?}</p><p>     */</p><p>    Request.prototype.getBody = function () {</p><p>        switch (this.contentType) {</p><p>            case ContentType.JSON:</p><p>                return this.text();</p><p>            case ContentType.FORM:</p><p>                return this.text();</p><p>            case ContentType.FORM_DATA:</p><p>                return this._body;</p><p>            case ContentType.TEXT:</p><p>                return this.text();</p><p>            case ContentType.BLOB:</p><p>                return this.blob();</p><p>            case ContentType.ARRAY_BUFFER:</p><p>                return this.arrayBuffer();</p><p>            default:</p><p>                return null;</p><p>        }</p><p>    };</p><p>    return Request;</p><p>}(Body));</p><p>/**</p><p> * @param {?} params</p><p> * @return {?}</p><p> */</p><p>function urlEncodeParams(params) {</p><p>    var /** @type {?} */ searchParams = new URLSearchParams();</p><p>    Object.keys(params).forEach(function (key) {</p><p>        var /** @type {?} */ value = params[key];</p><p>        if (value && Array.isArray(value)) {</p><p>            value.forEach(function (element) { return searchParams.append(key, element.toString()); });</p><p>        }</p><p>        else {</p><p>            searchParams.append(key, value.toString());</p><p>        }</p><p>    });</p><p>    return searchParams;</p><p>}</p><p>var noop = function () { };</p><p>var w = typeof window == 'object' ? window : noop;</p><p>var FormData = ((w) /** TODO #9100 */)['FormData'] || noop;</p><p>var Blob$1 = ((w) /** TODO #9100 */)['Blob'] || noop;</p><p>var ArrayBuffer$1 = ((w) /** TODO #9100 */)['ArrayBuffer'] || noop;</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * @param {?} backend</p><p> * @param {?} request</p><p> * @return {?}</p><p> */</p><p>function httpRequest(backend, request) {</p><p>    return backend.createConnection(request).response;</p><p>}</p><p>/**</p><p> * @param {?} defaultOpts</p><p> * @param {?} providedOpts</p><p> * @param {?} method</p><p> * @param {?} url</p><p> * @return {?}</p><p> */</p><p>function mergeOptions(defaultOpts, providedOpts, method, url) {</p><p>    var /** @type {?} */ newOptions = defaultOpts;</p><p>    if (providedOpts) {</p><p>        // Hack so Dart can used named parameters</p><p>        return (newOptions.merge(new RequestOptions({</p><p>            method: providedOpts.method || method,</p><p>            url: providedOpts.url || url,</p><p>            search: providedOpts.search,</p><p>            params: providedOpts.params,</p><p>            headers: providedOpts.headers,</p><p>            body: providedOpts.body,</p><p>            withCredentials: providedOpts.withCredentials,</p><p>            responseType: providedOpts.responseType</p><p>        })));</p><p>    }</p><p>    return (newOptions.merge(new RequestOptions({ method: method, url: url })));</p><p>}</p><p>/**</p><p> * Performs http requests using `XMLHttpRequest` as the default backend.</p><p> *</p><p> * `Http` is available as an injectable class, with methods to perform http requests. Calling</p><p> * `request` returns an `Observable` which will emit a single {\@link Response} when a</p><p> * response is received.</p><p> *</p><p> * ### Example</p><p> *</p><p> * ```typescript</p><p> * import {Http, HTTP_PROVIDERS} from '\@angular/http';</p><p> * import 'rxjs/add/operator/map'</p><p> * \@Component({</p><p> *   selector: 'http-app',</p><p> *   viewProviders: [HTTP_PROVIDERS],</p><p> *   templateUrl: 'people.html'</p><p> * })</p><p> * class PeopleComponent {</p><p> *   constructor(http: Http) {</p><p> *     http.get('people.json')</p><p> *       // Call map on the response observable to get the parsed people object</p><p> *       .map(res => res.json())</p><p> *       // Subscribe to the observable to get the parsed people object and attach it to the</p><p> *       // component</p><p> *       .subscribe(people => this.people = people);</p><p> *   }</p><p> * }</p><p> * ```</p><p> *</p><p> *</p><p> * ### Example</p><p> *</p><p> * ```</p><p> * http.get('people.json').subscribe((res:Response) => this.people = res.json());</p><p> * ```</p><p> *</p><p> * The default construct used to perform requests, `XMLHttpRequest`, is abstracted as a "Backend" (</p><p> * {\@link XHRBackend} in this case), which could be mocked with dependency injection by replacing</p><p> * the {\@link XHRBackend} provider, as in the following example:</p><p> *</p><p> * ### Example</p><p> *</p><p> * ```typescript</p><p> * import {BaseRequestOptions, Http} from '\@angular/http';</p><p> * import {MockBackend} from '\@angular/http/testing';</p><p> * var injector = Injector.resolveAndCreate([</p><p> *   BaseRequestOptions,</p><p> *   MockBackend,</p><p> *   {provide: Http, useFactory:</p><p> *       function(backend, defaultOptions) {</p><p> *         return new Http(backend, defaultOptions);</p><p> *       },</p><p> *       deps: [MockBackend, BaseRequestOptions]}</p><p> * ]);</p><p> * var http = injector.get(Http);</p><p> * http.get('request-from-mock-backend.json').subscribe((res:Response) => doSomething(res));</p><p> * ```</p><p> *</p><p> * \@experimental</p><p> */</p><p>var Http = (function () {</p><p>    /**</p><p>     * @param {?} _backend</p><p>     * @param {?} _defaultOptions</p><p>     */</p><p>    function Http(_backend, _defaultOptions) {</p><p>        this._backend = _backend;</p><p>        this._defaultOptions = _defaultOptions;</p><p>    }</p><p>    /**</p><p>     * Performs any type of http request. First argument is required, and can either be a url or</p><p>     * a {\@link Request} instance. If the first argument is a url, an optional {\@link RequestOptions}</p><p>     * object can be provided as the 2nd argument. The options object will be merged with the values</p><p>     * of {\@link BaseRequestOptions} before performing the request.</p><p>     * @param {?} url</p><p>     * @param {?=} options</p><p>     * @return {?}</p><p>     */</p><p>    Http.prototype.request = function (url, options) {</p><p>        var /** @type {?} */ responseObservable;</p><p>        if (typeof url === 'string') {</p><p>            responseObservable = httpRequest(this._backend, new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Get, /** @type {?} */ (url))));</p><p>        }</p><p>        else if (url instanceof Request) {</p><p>            responseObservable = httpRequest(this._backend, url);</p><p>        }</p><p>        else {</p><p>            throw new Error('First argument must be a url string or Request instance.');</p><p>        }</p><p>        return responseObservable;</p><p>    };</p><p>    /**</p><p>     * Performs a request with `get` http method.</p><p>     * @param {?} url</p><p>     * @param {?=} options</p><p>     * @return {?}</p><p>     */</p><p>    Http.prototype.get = function (url, options) {</p><p>        return this.request(new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Get, url)));</p><p>    };</p><p>    /**</p><p>     * Performs a request with `post` http method.</p><p>     * @param {?} url</p><p>     * @param {?} body</p><p>     * @param {?=} options</p><p>     * @return {?}</p><p>     */</p><p>    Http.prototype.post = function (url, body, options) {</p><p>        return this.request(new Request(mergeOptions(this._defaultOptions.merge(new RequestOptions({ body: body })), options, RequestMethod.Post, url)));</p><p>    };</p><p>    /**</p><p>     * Performs a request with `put` http method.</p><p>     * @param {?} url</p><p>     * @param {?} body</p><p>     * @param {?=} options</p><p>     * @return {?}</p><p>     */</p><p>    Http.prototype.put = function (url, body, options) {</p><p>        return this.request(new Request(mergeOptions(this._defaultOptions.merge(new RequestOptions({ body: body })), options, RequestMethod.Put, url)));</p><p>    };</p><p>    /**</p><p>     * Performs a request with `delete` http method.</p><p>     * @param {?} url</p><p>     * @param {?=} options</p><p>     * @return {?}</p><p>     */</p><p>    Http.prototype.delete = function (url, options) {</p><p>        return this.request(new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Delete, url)));</p><p>    };</p><p>    /**</p><p>     * Performs a request with `patch` http method.</p><p>     * @param {?} url</p><p>     * @param {?} body</p><p>     * @param {?=} options</p><p>     * @return {?}</p><p>     */</p><p>    Http.prototype.patch = function (url, body, options) {</p><p>        return this.request(new Request(mergeOptions(this._defaultOptions.merge(new RequestOptions({ body: body })), options, RequestMethod.Patch, url)));</p><p>    };</p><p>    /**</p><p>     * Performs a request with `head` http method.</p><p>     * @param {?} url</p><p>     * @param {?=} options</p><p>     * @return {?}</p><p>     */</p><p>    Http.prototype.head = function (url, options) {</p><p>        return this.request(new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Head, url)));</p><p>    };</p><p>    /**</p><p>     * Performs a request with `options` http method.</p><p>     * @param {?} url</p><p>     * @param {?=} options</p><p>     * @return {?}</p><p>     */</p><p>    Http.prototype.options = function (url, options) {</p><p>        return this.request(new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Options, url)));</p><p>    };</p><p>    return Http;</p><p>}());</p><p>Http.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>Http.ctorParameters = function () { return [</p><p>    { type: ConnectionBackend, },</p><p>    { type: RequestOptions, },</p><p>]; };</p><p>/**</p><p> * \@experimental</p><p> */</p><p>var Jsonp = (function (_super) {</p><p>    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](Jsonp, _super);</p><p>    /**</p><p>     * @param {?} backend</p><p>     * @param {?} defaultOptions</p><p>     */</p><p>    function Jsonp(backend, defaultOptions) {</p><p>        return _super.call(this, backend, defaultOptions) || this;</p><p>    }</p><p>    /**</p><p>     * Performs any type of http request. First argument is required, and can either be a url or</p><p>     * a {\@link Request} instance. If the first argument is a url, an optional {\@link RequestOptions}</p><p>     * object can be provided as the 2nd argument. The options object will be merged with the values</p><p>     * of {\@link BaseRequestOptions} before performing the request.</p><p>     *</p><p>     * \@security Regular XHR is the safest alternative to JSONP for most applications, and is</p><p>     * supported by all current browsers. Because JSONP creates a `<script>` element with</p><p>     * contents retrieved from a remote source, attacker-controlled data introduced by an untrusted</p><p>     * source could expose your application to XSS risks. Data exposed by JSONP may also be</p><p>     * readable by malicious third-party websites. In addition, JSONP introduces potential risk for</p><p>     * future security issues (e.g. content sniffing).  For more detail, see the</p><p>     * [Security Guide](http://g.co/ng/security).</p><p>     * @param {?} url</p><p>     * @param {?=} options</p><p>     * @return {?}</p><p>     */</p><p>    Jsonp.prototype.request = function (url, options) {</p><p>        var /** @type {?} */ responseObservable;</p><p>        if (typeof url === 'string') {</p><p>            url =</p><p>                new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Get, /** @type {?} */ (url)));</p><p>        }</p><p>        if (url instanceof Request) {</p><p>            if (url.method !== RequestMethod.Get) {</p><p>                throw new Error('JSONP requests must use GET request method.');</p><p>            }</p><p>            responseObservable = httpRequest(this._backend, url);</p><p>        }</p><p>        else {</p><p>            throw new Error('First argument must be a url string or Request instance.');</p><p>        }</p><p>        return responseObservable;</p><p>    };</p><p>    return Jsonp;</p><p>}(Http));</p><p>Jsonp.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>Jsonp.ctorParameters = function () { return [</p><p>    { type: ConnectionBackend, },</p><p>    { type: RequestOptions, },</p><p>]; };</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * @module</p><p> * @description</p><p> * The http module provides services to perform http requests. To get started, see the {@link Http}</p><p> * class.</p><p> */</p><p>/**</p><p> * @return {?}</p><p> */</p><p>function _createDefaultCookieXSRFStrategy() {</p><p>    return new CookieXSRFStrategy();</p><p>}</p><p>/**</p><p> * @param {?} xhrBackend</p><p> * @param {?} requestOptions</p><p> * @return {?}</p><p> */</p><p>function httpFactory(xhrBackend, requestOptions) {</p><p>    return new Http(xhrBackend, requestOptions);</p><p>}</p><p>/**</p><p> * @param {?} jsonpBackend</p><p> * @param {?} requestOptions</p><p> * @return {?}</p><p> */</p><p>function jsonpFactory(jsonpBackend, requestOptions) {</p><p>    return new Jsonp(jsonpBackend, requestOptions);</p><p>}</p><p>/**</p><p> * The module that includes http's providers</p><p> *</p><p> * \@experimental</p><p> */</p><p>var HttpModule = (function () {</p><p>    function HttpModule() {</p><p>    }</p><p>    return HttpModule;</p><p>}());</p><p>HttpModule.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["NgModule"], args: [{</p><p>                providers: [</p><p>                    // TODO(pascal): use factory type annotations once supported in DI</p><p>                    // issue: https://github.com/angular/angular/issues/3183</p><p>                    { provide: Http, useFactory: httpFactory, deps: [XHRBackend, RequestOptions] },</p><p>                    BrowserXhr,</p><p>                    { provide: RequestOptions, useClass: BaseRequestOptions },</p><p>                    { provide: ResponseOptions, useClass: BaseResponseOptions },</p><p>                    XHRBackend,</p><p>                    { provide: XSRFStrategy, useFactory: _createDefaultCookieXSRFStrategy },</p><p>                ],</p><p>            },] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>HttpModule.ctorParameters = function () { return []; };</p><p>/**</p><p> * The module that includes jsonp's providers</p><p> *</p><p> * \@experimental</p><p> */</p><p>var JsonpModule = (function () {</p><p>    function JsonpModule() {</p><p>    }</p><p>    return JsonpModule;</p><p>}());</p><p>JsonpModule.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["NgModule"], args: [{</p><p>                providers: [</p><p>                    // TODO(pascal): use factory type annotations once supported in DI</p><p>                    // issue: https://github.com/angular/angular/issues/3183</p><p>                    { provide: Jsonp, useFactory: jsonpFactory, deps: [JSONPBackend, RequestOptions] },</p><p>                    BrowserJsonp,</p><p>                    { provide: RequestOptions, useClass: BaseRequestOptions },</p><p>                    { provide: ResponseOptions, useClass: BaseResponseOptions },</p><p>                    { provide: JSONPBackend, useClass: JSONPBackend_ },</p><p>                ],</p><p>            },] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>JsonpModule.ctorParameters = function () { return []; };</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * @module</p><p> * @description</p><p> * Entry point for all public APIs of the common package.</p><p> */</p><p>/**</p><p> * \@stable</p><p> */</p><p>var VERSION = new __WEBPACK_IMPORTED_MODULE_1__angular_core__["Version"]('4.3.5');</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * @module</p><p> * @description</p><p> * Entry point for all public APIs of the http package.</p><p> */</p><p>// This file only reexports content of the `src` folder. Keep it that way.</p><p>/**</p><p> * Generated bundle index. Do not edit.</p><p> */</p><p></p><p>//# sourceMappingURL=http.es5.js.map</p><p></p><p></p><p>/***/ }),</p><p></p><p>/***/ "../../../platform-browser/@angular/platform-browser.es5.js":</p><p>/***/ (function(module, __webpack_exports__, __webpack_require__) {</p><p></p><p>"use strict";</p><p>Object.defineProperty(__webpack_exports__, "__esModule", { value: true });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BrowserModule", function() { return BrowserModule; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "platformBrowser", function() { return platformBrowser; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Meta", function() { return Meta; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Title", function() { return Title; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "disableDebugTools", function() { return disableDebugTools; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enableDebugTools", function() { return enableDebugTools; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "By", function() { return By; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NgProbeToken", function() { return NgProbeToken$1; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DOCUMENT", function() { return DOCUMENT$1; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EVENT_MANAGER_PLUGINS", function() { return EVENT_MANAGER_PLUGINS; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EventManager", function() { return EventManager; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HAMMER_GESTURE_CONFIG", function() { return HAMMER_GESTURE_CONFIG; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HammerGestureConfig", function() { return HammerGestureConfig; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DomSanitizer", function() { return DomSanitizer; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return VERSION; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵBROWSER_SANITIZATION_PROVIDERS", function() { return BROWSER_SANITIZATION_PROVIDERS; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵINTERNAL_BROWSER_PLATFORM_PROVIDERS", function() { return INTERNAL_BROWSER_PLATFORM_PROVIDERS; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵinitDomAdapter", function() { return initDomAdapter; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵBrowserDomAdapter", function() { return BrowserDomAdapter; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵBrowserPlatformLocation", function() { return BrowserPlatformLocation; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵTRANSITION_ID", function() { return TRANSITION_ID; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵBrowserGetTestability", function() { return BrowserGetTestability; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵELEMENT_PROBE_PROVIDERS", function() { return ELEMENT_PROBE_PROVIDERS; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵDomAdapter", function() { return DomAdapter; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵgetDOM", function() { return getDOM; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵsetRootDomAdapter", function() { return setRootDomAdapter; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵDomRendererFactory2", function() { return DomRendererFactory2; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵNAMESPACE_URIS", function() { return NAMESPACE_URIS; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵflattenStyles", function() { return flattenStyles; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵshimContentAttribute", function() { return shimContentAttribute; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵshimHostAttribute", function() { return shimHostAttribute; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵDomEventsPlugin", function() { return DomEventsPlugin; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵHammerGesturesPlugin", function() { return HammerGesturesPlugin; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵKeyEventsPlugin", function() { return KeyEventsPlugin; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵDomSharedStylesHost", function() { return DomSharedStylesHost; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵSharedStylesHost", function() { return SharedStylesHost; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵb", function() { return _document; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵa", function() { return errorHandler; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵh", function() { return GenericBrowserDomAdapter; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵg", function() { return SERVER_TRANSITION_PROVIDERS; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵf", function() { return appInitializerFactory; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵc", function() { return _createNgProbe; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵd", function() { return EventManagerPlugin; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵe", function() { return DomSanitizerImpl; });</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__("../../../../tslib/tslib.es6.js");</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common__ = __webpack_require__("../../../common/@angular/common.es5.js");</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__("../../../core/@angular/core.es5.js");</p><p></p><p>/**</p><p> * @license Angular v4.3.5</p><p> * (c) 2010-2017 Google, Inc. https://angular.io/</p><p> * License: MIT</p><p> */</p><p></p><p></p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>var _DOM = ((null));</p><p>/**</p><p> * @return {?}</p><p> */</p><p>function getDOM() {</p><p>    return _DOM;</p><p>}</p><p>/**</p><p> * @param {?} adapter</p><p> * @return {?}</p><p> */</p><p>/**</p><p> * @param {?} adapter</p><p> * @return {?}</p><p> */</p><p>function setRootDomAdapter(adapter) {</p><p>    if (!_DOM) {</p><p>        _DOM = adapter;</p><p>    }</p><p>}</p><p>/**</p><p> * Provides DOM operations in an environment-agnostic way.</p><p> *</p><p> * \@security Tread carefully! Interacting with the DOM directly is dangerous and</p><p> * can introduce XSS risks.</p><p> * @abstract</p><p> */</p><p>var DomAdapter = (function () {</p><p>    function DomAdapter() {</p><p>        this.resourceLoaderType = ((null));</p><p>    }</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} element</p><p>     * @param {?} name</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.hasProperty = function (element, name) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} el</p><p>     * @param {?} name</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.setProperty = function (el, name, value) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} el</p><p>     * @param {?} name</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.getProperty = function (el, name) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} el</p><p>     * @param {?} methodName</p><p>     * @param {?} args</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.invoke = function (el, methodName, args) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} error</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.logError = function (error) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} error</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.log = function (error) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} error</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.logGroup = function (error) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.logGroupEnd = function () { };</p><p>    Object.defineProperty(DomAdapter.prototype, "attrToPropMap", {</p><p>        /**</p><p>         * Maps attribute names to their corresponding property names for cases</p><p>         * where attribute name doesn't match property name.</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this._attrToPropMap; },</p><p>        /**</p><p>         * @param {?} value</p><p>         * @return {?}</p><p>         */</p><p>        set: function (value) { this._attrToPropMap = value; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    ;</p><p>    ;</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} nodeA</p><p>     * @param {?} nodeB</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.contains = function (nodeA, nodeB) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} templateHtml</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.parse = function (templateHtml) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} el</p><p>     * @param {?} selector</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.querySelector = function (el, selector) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} el</p><p>     * @param {?} selector</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.querySelectorAll = function (el, selector) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} el</p><p>     * @param {?} evt</p><p>     * @param {?} listener</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.on = function (el, evt, listener) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} el</p><p>     * @param {?} evt</p><p>     * @param {?} listener</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.onAndCancel = function (el, evt, listener) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} el</p><p>     * @param {?} evt</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.dispatchEvent = function (el, evt) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} eventType</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.createMouseEvent = function (eventType) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} eventType</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.createEvent = function (eventType) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} evt</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.preventDefault = function (evt) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} evt</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.isPrevented = function (evt) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} el</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.getInnerHTML = function (el) { };</p><p>    /**</p><p>     * Returns content if el is a <template> element, null otherwise.</p><p>     * @abstract</p><p>     * @param {?} el</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.getTemplateContent = function (el) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} el</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.getOuterHTML = function (el) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} node</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.nodeName = function (node) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} node</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.nodeValue = function (node) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} node</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.type = function (node) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} node</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.content = function (node) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} el</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.firstChild = function (el) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} el</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.nextSibling = function (el) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} el</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.parentElement = function (el) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} el</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.childNodes = function (el) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} el</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.childNodesAsList = function (el) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} el</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.clearNodes = function (el) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} el</p><p>     * @param {?} node</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.appendChild = function (el, node) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} el</p><p>     * @param {?} node</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.removeChild = function (el, node) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} el</p><p>     * @param {?} newNode</p><p>     * @param {?} oldNode</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.replaceChild = function (el, newNode, oldNode) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} el</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.remove = function (el) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} parent</p><p>     * @param {?} ref</p><p>     * @param {?} node</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.insertBefore = function (parent, ref, node) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} parent</p><p>     * @param {?} ref</p><p>     * @param {?} nodes</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.insertAllBefore = function (parent, ref, nodes) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} parent</p><p>     * @param {?} el</p><p>     * @param {?} node</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.insertAfter = function (parent, el, node) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} el</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.setInnerHTML = function (el, value) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} el</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.getText = function (el) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} el</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.setText = function (el, value) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} el</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.getValue = function (el) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} el</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.setValue = function (el, value) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} el</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.getChecked = function (el) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} el</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.setChecked = function (el, value) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} text</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.createComment = function (text) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} html</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.createTemplate = function (html) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} tagName</p><p>     * @param {?=} doc</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.createElement = function (tagName, doc) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} ns</p><p>     * @param {?} tagName</p><p>     * @param {?=} doc</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.createElementNS = function (ns, tagName, doc) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} text</p><p>     * @param {?=} doc</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.createTextNode = function (text, doc) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} attrName</p><p>     * @param {?} attrValue</p><p>     * @param {?=} doc</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.createScriptTag = function (attrName, attrValue, doc) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} css</p><p>     * @param {?=} doc</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.createStyleElement = function (css, doc) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} el</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.createShadowRoot = function (el) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} el</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.getShadowRoot = function (el) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} el</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.getHost = function (el) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} el</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.getDistributedNodes = function (el) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} node</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.clone /*<T extends Node>*/ = function (node) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} element</p><p>     * @param {?} name</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.getElementsByClassName = function (element, name) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} element</p><p>     * @param {?} name</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.getElementsByTagName = function (element, name) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} element</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.classList = function (element) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} element</p><p>     * @param {?} className</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.addClass = function (element, className) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} element</p><p>     * @param {?} className</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.removeClass = function (element, className) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} element</p><p>     * @param {?} className</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.hasClass = function (element, className) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} element</p><p>     * @param {?} styleName</p><p>     * @param {?} styleValue</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.setStyle = function (element, styleName, styleValue) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} element</p><p>     * @param {?} styleName</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.removeStyle = function (element, styleName) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} element</p><p>     * @param {?} styleName</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.getStyle = function (element, styleName) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} element</p><p>     * @param {?} styleName</p><p>     * @param {?=} styleValue</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.hasStyle = function (element, styleName, styleValue) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} element</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.tagName = function (element) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} element</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.attributeMap = function (element) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} element</p><p>     * @param {?} attribute</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.hasAttribute = function (element, attribute) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} element</p><p>     * @param {?} ns</p><p>     * @param {?} attribute</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.hasAttributeNS = function (element, ns, attribute) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} element</p><p>     * @param {?} attribute</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.getAttribute = function (element, attribute) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} element</p><p>     * @param {?} ns</p><p>     * @param {?} attribute</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.getAttributeNS = function (element, ns, attribute) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} element</p><p>     * @param {?} name</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.setAttribute = function (element, name, value) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} element</p><p>     * @param {?} ns</p><p>     * @param {?} name</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.setAttributeNS = function (element, ns, name, value) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} element</p><p>     * @param {?} attribute</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.removeAttribute = function (element, attribute) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} element</p><p>     * @param {?} ns</p><p>     * @param {?} attribute</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.removeAttributeNS = function (element, ns, attribute) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} el</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.templateAwareRoot = function (el) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.createHtmlDocument = function () { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} el</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.getBoundingClientRect = function (el) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} doc</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.getTitle = function (doc) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} doc</p><p>     * @param {?} newTitle</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.setTitle = function (doc, newTitle) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} n</p><p>     * @param {?} selector</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.elementMatches = function (n, selector) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} el</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.isTemplateElement = function (el) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} node</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.isTextNode = function (node) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} node</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.isCommentNode = function (node) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} node</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.isElementNode = function (node) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} node</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.hasShadowRoot = function (node) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} node</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.isShadowRoot = function (node) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} node</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.importIntoDoc /*<T extends Node>*/ = function (node) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} node</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.adoptNode /*<T extends Node>*/ = function (node) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} element</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.getHref = function (element) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} event</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.getEventKey = function (event) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} element</p><p>     * @param {?} baseUrl</p><p>     * @param {?} href</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.resolveAndSetHref = function (element, baseUrl, href) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.supportsDOMEvents = function () { };</p><p>    /**</p><p>     * @abstract</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.supportsNativeShadowDOM = function () { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} doc</p><p>     * @param {?} target</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.getGlobalEventTarget = function (doc, target) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.getHistory = function () { };</p><p>    /**</p><p>     * @abstract</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.getLocation = function () { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} doc</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.getBaseHref = function (doc) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.resetBaseElement = function () { };</p><p>    /**</p><p>     * @abstract</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.getUserAgent = function () { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} element</p><p>     * @param {?} name</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.setData = function (element, name, value) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} element</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.getComputedStyle = function (element) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} element</p><p>     * @param {?} name</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.getData = function (element, name) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.supportsWebAnimation = function () { };</p><p>    /**</p><p>     * @abstract</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.performanceNow = function () { };</p><p>    /**</p><p>     * @abstract</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.getAnimationPrefix = function () { };</p><p>    /**</p><p>     * @abstract</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.getTransitionEnd = function () { };</p><p>    /**</p><p>     * @abstract</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.supportsAnimation = function () { };</p><p>    /**</p><p>     * @abstract</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.supportsCookies = function () { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} name</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.getCookie = function (name) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} name</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    DomAdapter.prototype.setCookie = function (name, value) { };</p><p>    return DomAdapter;</p><p>}());</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * Provides DOM operations in any browser environment.</p><p> *</p><p> * \@security Tread carefully! Interacting with the DOM directly is dangerous and</p><p> * can introduce XSS risks.</p><p> * @abstract</p><p> */</p><p>var GenericBrowserDomAdapter = (function (_super) {</p><p>    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](GenericBrowserDomAdapter, _super);</p><p>    function GenericBrowserDomAdapter() {</p><p>        var _this = _super.call(this) || this;</p><p>        _this._animationPrefix = null;</p><p>        _this._transitionEnd = null;</p><p>        try {</p><p>            var element_1 = _this.createElement('div', document);</p><p>            if (_this.getStyle(element_1, 'animationName') != null) {</p><p>                _this._animationPrefix = '';</p><p>            }</p><p>            else {</p><p>                var domPrefixes = ['Webkit', 'Moz', 'O', 'ms'];</p><p>                for (var i = 0; i < domPrefixes.length; i++) {</p><p>                    if (_this.getStyle(element_1, domPrefixes[i] + 'AnimationName') != null) {</p><p>                        _this._animationPrefix = '-' + domPrefixes[i].toLowerCase() + '-';</p><p>                        break;</p><p>                    }</p><p>                }</p><p>            }</p><p>            var transEndEventNames_1 = {</p><p>                WebkitTransition: 'webkitTransitionEnd',</p><p>                MozTransition: 'transitionend',</p><p>                OTransition: 'oTransitionEnd otransitionend',</p><p>                transition: 'transitionend'</p><p>            };</p><p>            Object.keys(transEndEventNames_1).forEach(function (key) {</p><p>                if (_this.getStyle(element_1, key) != null) {</p><p>                    _this._transitionEnd = transEndEventNames_1[key];</p><p>                }</p><p>            });</p><p>        }</p><p>        catch (e) {</p><p>            _this._animationPrefix = null;</p><p>            _this._transitionEnd = null;</p><p>        }</p><p>        return _this;</p><p>    }</p><p>    /**</p><p>     * @param {?} el</p><p>     * @return {?}</p><p>     */</p><p>    GenericBrowserDomAdapter.prototype.getDistributedNodes = function (el) { return ((el)).getDistributedNodes(); };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @param {?} baseUrl</p><p>     * @param {?} href</p><p>     * @return {?}</p><p>     */</p><p>    GenericBrowserDomAdapter.prototype.resolveAndSetHref = function (el, baseUrl, href) {</p><p>        el.href = href == null ? baseUrl : baseUrl + '/../' + href;</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    GenericBrowserDomAdapter.prototype.supportsDOMEvents = function () { return true; };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    GenericBrowserDomAdapter.prototype.supportsNativeShadowDOM = function () {</p><p>        return typeof ((document.body)).createShadowRoot === 'function';</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    GenericBrowserDomAdapter.prototype.getAnimationPrefix = function () { return this._animationPrefix ? this._animationPrefix : ''; };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    GenericBrowserDomAdapter.prototype.getTransitionEnd = function () { return this._transitionEnd ? this._transitionEnd : ''; };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    GenericBrowserDomAdapter.prototype.supportsAnimation = function () {</p><p>        return this._animationPrefix != null && this._transitionEnd != null;</p><p>    };</p><p>    return GenericBrowserDomAdapter;</p><p>}(DomAdapter));</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>var _attrToPropMap = {</p><p>    'class': 'className',</p><p>    'innerHtml': 'innerHTML',</p><p>    'readonly': 'readOnly',</p><p>    'tabindex': 'tabIndex',</p><p>};</p><p>var DOM_KEY_LOCATION_NUMPAD = 3;</p><p>// Map to convert some key or keyIdentifier values to what will be returned by getEventKey</p><p>var _keyMap = {</p><p>    // The following values are here for cross-browser compatibility and to match the W3C standard</p><p>    // cf http://www.w3.org/TR/DOM-Level-3-Events-key/</p><p>    '\b': 'Backspace',</p><p>    '\t': 'Tab',</p><p>    '\x7F': 'Delete',</p><p>    '\x1B': 'Escape',</p><p>    'Del': 'Delete',</p><p>    'Esc': 'Escape',</p><p>    'Left': 'ArrowLeft',</p><p>    'Right': 'ArrowRight',</p><p>    'Up': 'ArrowUp',</p><p>    'Down': 'ArrowDown',</p><p>    'Menu': 'ContextMenu',</p><p>    'Scroll': 'ScrollLock',</p><p>    'Win': 'OS'</p><p>};</p><p>// There is a bug in Chrome for numeric keypad keys:</p><p>// https://code.google.com/p/chromium/issues/detail?id=155654</p><p>// 1, 2, 3 ... are reported as A, B, C ...</p><p>var _chromeNumKeyPadMap = {</p><p>    'A': '1',</p><p>    'B': '2',</p><p>    'C': '3',</p><p>    'D': '4',</p><p>    'E': '5',</p><p>    'F': '6',</p><p>    'G': '7',</p><p>    'H': '8',</p><p>    'I': '9',</p><p>    'J': '*',</p><p>    'K': '+',</p><p>    'M': '-',</p><p>    'N': '.',</p><p>    'O': '/',</p><p>    '\x60': '0',</p><p>    '\x90': 'NumLock'</p><p>};</p><p>var nodeContains;</p><p>if (__WEBPACK_IMPORTED_MODULE_2__angular_core__["ɵglobal"]['Node']) {</p><p>    nodeContains = __WEBPACK_IMPORTED_MODULE_2__angular_core__["ɵglobal"]['Node'].prototype.contains || function (node) {</p><p>        return !!(this.compareDocumentPosition(node) & 16);</p><p>    };</p><p>}</p><p>var BrowserDomAdapter = (function (_super) {</p><p>    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](BrowserDomAdapter, _super);</p><p>    function BrowserDomAdapter() {</p><p>        return _super !== null && _super.apply(this, arguments) || this;</p><p>    }</p><p>    /**</p><p>     * @param {?} templateHtml</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.parse = function (templateHtml) { throw new Error('parse not implemented'); };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.makeCurrent = function () { setRootDomAdapter(new BrowserDomAdapter()); };</p><p>    /**</p><p>     * @param {?} element</p><p>     * @param {?} name</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.hasProperty = function (element, name) { return name in element; };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @param {?} name</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.setProperty = function (el, name, value) { ((el))[name] = value; };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @param {?} name</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.getProperty = function (el, name) { return ((el))[name]; };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @param {?} methodName</p><p>     * @param {?} args</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.invoke = function (el, methodName, args) { ((el))[methodName].apply(((el)), args); };</p><p>    /**</p><p>     * @param {?} error</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.logError = function (error) {</p><p>        if (window.console) {</p><p>            if (console.error) {</p><p>                console.error(error);</p><p>            }</p><p>            else {</p><p>                console.log(error);</p><p>            }</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @param {?} error</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.log = function (error) {</p><p>        if (window.console) {</p><p>            window.console.log && window.console.log(error);</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @param {?} error</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.logGroup = function (error) {</p><p>        if (window.console) {</p><p>            window.console.group && window.console.group(error);</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.logGroupEnd = function () {</p><p>        if (window.console) {</p><p>            window.console.groupEnd && window.console.groupEnd();</p><p>        }</p><p>    };</p><p>    Object.defineProperty(BrowserDomAdapter.prototype, "attrToPropMap", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return _attrToPropMap; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    /**</p><p>     * @param {?} nodeA</p><p>     * @param {?} nodeB</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.contains = function (nodeA, nodeB) { return nodeContains.call(nodeA, nodeB); };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @param {?} selector</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.querySelector = function (el, selector) { return el.querySelector(selector); };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @param {?} selector</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.querySelectorAll = function (el, selector) { return el.querySelectorAll(selector); };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @param {?} evt</p><p>     * @param {?} listener</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.on = function (el, evt, listener) { el.addEventListener(evt, listener, false); };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @param {?} evt</p><p>     * @param {?} listener</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.onAndCancel = function (el, evt, listener) {</p><p>        el.addEventListener(evt, listener, false);</p><p>        // Needed to follow Dart's subscription semantic, until fix of</p><p>        // https://code.google.com/p/dart/issues/detail?id=17406</p><p>        return function () { el.removeEventListener(evt, listener, false); };</p><p>    };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @param {?} evt</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.dispatchEvent = function (el, evt) { el.dispatchEvent(evt); };</p><p>    /**</p><p>     * @param {?} eventType</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.createMouseEvent = function (eventType) {</p><p>        var /** @type {?} */ evt = document.createEvent('MouseEvent');</p><p>        evt.initEvent(eventType, true, true);</p><p>        return evt;</p><p>    };</p><p>    /**</p><p>     * @param {?} eventType</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.createEvent = function (eventType) {</p><p>        var /** @type {?} */ evt = document.createEvent('Event');</p><p>        evt.initEvent(eventType, true, true);</p><p>        return evt;</p><p>    };</p><p>    /**</p><p>     * @param {?} evt</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.preventDefault = function (evt) {</p><p>        evt.preventDefault();</p><p>        evt.returnValue = false;</p><p>    };</p><p>    /**</p><p>     * @param {?} evt</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.isPrevented = function (evt) {</p><p>        return evt.defaultPrevented || evt.returnValue != null && !evt.returnValue;</p><p>    };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.getInnerHTML = function (el) { return el.innerHTML; };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.getTemplateContent = function (el) {</p><p>        return 'content' in el && el instanceof HTMLTemplateElement ? el.content : null;</p><p>    };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.getOuterHTML = function (el) { return el.outerHTML; };</p><p>    /**</p><p>     * @param {?} node</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.nodeName = function (node) { return node.nodeName; };</p><p>    /**</p><p>     * @param {?} node</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.nodeValue = function (node) { return node.nodeValue; };</p><p>    /**</p><p>     * @param {?} node</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.type = function (node) { return node.type; };</p><p>    /**</p><p>     * @param {?} node</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.content = function (node) {</p><p>        if (this.hasProperty(node, 'content')) {</p><p>            return ((node)).content;</p><p>        }</p><p>        else {</p><p>            return node;</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.firstChild = function (el) { return el.firstChild; };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.nextSibling = function (el) { return el.nextSibling; };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.parentElement = function (el) { return el.parentNode; };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.childNodes = function (el) { return el.childNodes; };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.childNodesAsList = function (el) {</p><p>        var /** @type {?} */ childNodes = el.childNodes;</p><p>        var /** @type {?} */ res = new Array(childNodes.length);</p><p>        for (var /** @type {?} */ i = 0; i < childNodes.length; i++) {</p><p>            res[i] = childNodes[i];</p><p>        }</p><p>        return res;</p><p>    };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.clearNodes = function (el) {</p><p>        while (el.firstChild) {</p><p>            el.removeChild(el.firstChild);</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @param {?} node</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.appendChild = function (el, node) { el.appendChild(node); };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @param {?} node</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.removeChild = function (el, node) { el.removeChild(node); };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @param {?} newChild</p><p>     * @param {?} oldChild</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.replaceChild = function (el, newChild, oldChild) { el.replaceChild(newChild, oldChild); };</p><p>    /**</p><p>     * @param {?} node</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.remove = function (node) {</p><p>        if (node.parentNode) {</p><p>            node.parentNode.removeChild(node);</p><p>        }</p><p>        return node;</p><p>    };</p><p>    /**</p><p>     * @param {?} parent</p><p>     * @param {?} ref</p><p>     * @param {?} node</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.insertBefore = function (parent, ref, node) { parent.insertBefore(node, ref); };</p><p>    /**</p><p>     * @param {?} parent</p><p>     * @param {?} ref</p><p>     * @param {?} nodes</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.insertAllBefore = function (parent, ref, nodes) {</p><p>        nodes.forEach(function (n) { return parent.insertBefore(n, ref); });</p><p>    };</p><p>    /**</p><p>     * @param {?} parent</p><p>     * @param {?} ref</p><p>     * @param {?} node</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.insertAfter = function (parent, ref, node) { parent.insertBefore(node, ref.nextSibling); };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.setInnerHTML = function (el, value) { el.innerHTML = value; };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.getText = function (el) { return el.textContent; };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.setText = function (el, value) { el.textContent = value; };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.getValue = function (el) { return el.value; };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.setValue = function (el, value) { el.value = value; };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.getChecked = function (el) { return el.checked; };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.setChecked = function (el, value) { el.checked = value; };</p><p>    /**</p><p>     * @param {?} text</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.createComment = function (text) { return document.createComment(text); };</p><p>    /**</p><p>     * @param {?} html</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.createTemplate = function (html) {</p><p>        var /** @type {?} */ t = document.createElement('template');</p><p>        t.innerHTML = html;</p><p>        return t;</p><p>    };</p><p>    /**</p><p>     * @param {?} tagName</p><p>     * @param {?=} doc</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.createElement = function (tagName, doc) {</p><p>        if (doc === void 0) { doc = document; }</p><p>        return doc.createElement(tagName);</p><p>    };</p><p>    /**</p><p>     * @param {?} ns</p><p>     * @param {?} tagName</p><p>     * @param {?=} doc</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.createElementNS = function (ns, tagName, doc) {</p><p>        if (doc === void 0) { doc = document; }</p><p>        return doc.createElementNS(ns, tagName);</p><p>    };</p><p>    /**</p><p>     * @param {?} text</p><p>     * @param {?=} doc</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.createTextNode = function (text, doc) {</p><p>        if (doc === void 0) { doc = document; }</p><p>        return doc.createTextNode(text);</p><p>    };</p><p>    /**</p><p>     * @param {?} attrName</p><p>     * @param {?} attrValue</p><p>     * @param {?=} doc</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.createScriptTag = function (attrName, attrValue, doc) {</p><p>        if (doc === void 0) { doc = document; }</p><p>        var /** @type {?} */ el = (doc.createElement('SCRIPT'));</p><p>        el.setAttribute(attrName, attrValue);</p><p>        return el;</p><p>    };</p><p>    /**</p><p>     * @param {?} css</p><p>     * @param {?=} doc</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.createStyleElement = function (css, doc) {</p><p>        if (doc === void 0) { doc = document; }</p><p>        var /** @type {?} */ style = (doc.createElement('style'));</p><p>        this.appendChild(style, this.createTextNode(css));</p><p>        return style;</p><p>    };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.createShadowRoot = function (el) { return ((el)).createShadowRoot(); };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.getShadowRoot = function (el) { return ((el)).shadowRoot; };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.getHost = function (el) { return ((el)).host; };</p><p>    /**</p><p>     * @param {?} node</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.clone = function (node) { return node.cloneNode(true); };</p><p>    /**</p><p>     * @param {?} element</p><p>     * @param {?} name</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.getElementsByClassName = function (element, name) {</p><p>        return element.getElementsByClassName(name);</p><p>    };</p><p>    /**</p><p>     * @param {?} element</p><p>     * @param {?} name</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.getElementsByTagName = function (element, name) {</p><p>        return element.getElementsByTagName(name);</p><p>    };</p><p>    /**</p><p>     * @param {?} element</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.classList = function (element) { return Array.prototype.slice.call(element.classList, 0); };</p><p>    /**</p><p>     * @param {?} element</p><p>     * @param {?} className</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.addClass = function (element, className) { element.classList.add(className); };</p><p>    /**</p><p>     * @param {?} element</p><p>     * @param {?} className</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.removeClass = function (element, className) { element.classList.remove(className); };</p><p>    /**</p><p>     * @param {?} element</p><p>     * @param {?} className</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.hasClass = function (element, className) {</p><p>        return element.classList.contains(className);</p><p>    };</p><p>    /**</p><p>     * @param {?} element</p><p>     * @param {?} styleName</p><p>     * @param {?} styleValue</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.setStyle = function (element, styleName, styleValue) {</p><p>        element.style[styleName] = styleValue;</p><p>    };</p><p>    /**</p><p>     * @param {?} element</p><p>     * @param {?} stylename</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.removeStyle = function (element, stylename) {</p><p>        // IE requires '' instead of null</p><p>        // see https://github.com/angular/angular/issues/7916</p><p>        element.style[stylename] = '';</p><p>    };</p><p>    /**</p><p>     * @param {?} element</p><p>     * @param {?} stylename</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.getStyle = function (element, stylename) { return element.style[stylename]; };</p><p>    /**</p><p>     * @param {?} element</p><p>     * @param {?} styleName</p><p>     * @param {?=} styleValue</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.hasStyle = function (element, styleName, styleValue) {</p><p>        var /** @type {?} */ value = this.getStyle(element, styleName) || '';</p><p>        return styleValue ? value == styleValue : value.length > 0;</p><p>    };</p><p>    /**</p><p>     * @param {?} element</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.tagName = function (element) { return element.tagName; };</p><p>    /**</p><p>     * @param {?} element</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.attributeMap = function (element) {</p><p>        var /** @type {?} */ res = new Map();</p><p>        var /** @type {?} */ elAttrs = element.attributes;</p><p>        for (var /** @type {?} */ i = 0; i < elAttrs.length; i++) {</p><p>            var /** @type {?} */ attrib = elAttrs[i];</p><p>            res.set(attrib.name, attrib.value);</p><p>        }</p><p>        return res;</p><p>    };</p><p>    /**</p><p>     * @param {?} element</p><p>     * @param {?} attribute</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.hasAttribute = function (element, attribute) {</p><p>        return element.hasAttribute(attribute);</p><p>    };</p><p>    /**</p><p>     * @param {?} element</p><p>     * @param {?} ns</p><p>     * @param {?} attribute</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.hasAttributeNS = function (element, ns, attribute) {</p><p>        return element.hasAttributeNS(ns, attribute);</p><p>    };</p><p>    /**</p><p>     * @param {?} element</p><p>     * @param {?} attribute</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.getAttribute = function (element, attribute) {</p><p>        return element.getAttribute(attribute);</p><p>    };</p><p>    /**</p><p>     * @param {?} element</p><p>     * @param {?} ns</p><p>     * @param {?} name</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.getAttributeNS = function (element, ns, name) {</p><p>        return element.getAttributeNS(ns, name);</p><p>    };</p><p>    /**</p><p>     * @param {?} element</p><p>     * @param {?} name</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.setAttribute = function (element, name, value) { element.setAttribute(name, value); };</p><p>    /**</p><p>     * @param {?} element</p><p>     * @param {?} ns</p><p>     * @param {?} name</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.setAttributeNS = function (element, ns, name, value) {</p><p>        element.setAttributeNS(ns, name, value);</p><p>    };</p><p>    /**</p><p>     * @param {?} element</p><p>     * @param {?} attribute</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.removeAttribute = function (element, attribute) { element.removeAttribute(attribute); };</p><p>    /**</p><p>     * @param {?} element</p><p>     * @param {?} ns</p><p>     * @param {?} name</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.removeAttributeNS = function (element, ns, name) {</p><p>        element.removeAttributeNS(ns, name);</p><p>    };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.templateAwareRoot = function (el) { return this.isTemplateElement(el) ? this.content(el) : el; };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.createHtmlDocument = function () {</p><p>        return document.implementation.createHTMLDocument('fakeTitle');</p><p>    };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.getBoundingClientRect = function (el) {</p><p>        try {</p><p>            return el.getBoundingClientRect();</p><p>        }</p><p>        catch (e) {</p><p>            return { top: 0, bottom: 0, left: 0, right: 0, width: 0, height: 0 };</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @param {?} doc</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.getTitle = function (doc) { return document.title; };</p><p>    /**</p><p>     * @param {?} doc</p><p>     * @param {?} newTitle</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.setTitle = function (doc, newTitle) { document.title = newTitle || ''; };</p><p>    /**</p><p>     * @param {?} n</p><p>     * @param {?} selector</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.elementMatches = function (n, selector) {</p><p>        if (n instanceof HTMLElement) {</p><p>            return n.matches && n.matches(selector) ||</p><p>                n.msMatchesSelector && n.msMatchesSelector(selector) ||</p><p>                n.webkitMatchesSelector && n.webkitMatchesSelector(selector);</p><p>        }</p><p>        return false;</p><p>    };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.isTemplateElement = function (el) {</p><p>        return el instanceof HTMLElement && el.nodeName == 'TEMPLATE';</p><p>    };</p><p>    /**</p><p>     * @param {?} node</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.isTextNode = function (node) { return node.nodeType === Node.TEXT_NODE; };</p><p>    /**</p><p>     * @param {?} node</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.isCommentNode = function (node) { return node.nodeType === Node.COMMENT_NODE; };</p><p>    /**</p><p>     * @param {?} node</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.isElementNode = function (node) { return node.nodeType === Node.ELEMENT_NODE; };</p><p>    /**</p><p>     * @param {?} node</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.hasShadowRoot = function (node) {</p><p>        return node.shadowRoot != null && node instanceof HTMLElement;</p><p>    };</p><p>    /**</p><p>     * @param {?} node</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.isShadowRoot = function (node) { return node instanceof DocumentFragment; };</p><p>    /**</p><p>     * @param {?} node</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.importIntoDoc = function (node) { return document.importNode(this.templateAwareRoot(node), true); };</p><p>    /**</p><p>     * @param {?} node</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.adoptNode = function (node) { return document.adoptNode(node); };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.getHref = function (el) { return ((el)).href; };</p><p>    /**</p><p>     * @param {?} event</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.getEventKey = function (event) {</p><p>        var /** @type {?} */ key = event.key;</p><p>        if (key == null) {</p><p>            key = event.keyIdentifier;</p><p>            // keyIdentifier is defined in the old draft of DOM Level 3 Events implemented by Chrome and</p><p>            // Safari cf</p><p>            // http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/events.html#Events-KeyboardEvents-Interfaces</p><p>            if (key == null) {</p><p>                return 'Unidentified';</p><p>            }</p><p>            if (key.startsWith('U+')) {</p><p>                key = String.fromCharCode(parseInt(key.substring(2), 16));</p><p>                if (event.location === DOM_KEY_LOCATION_NUMPAD && _chromeNumKeyPadMap.hasOwnProperty(key)) {</p><p>                    // There is a bug in Chrome for numeric keypad keys:</p><p>                    // https://code.google.com/p/chromium/issues/detail?id=155654</p><p>                    // 1, 2, 3 ... are reported as A, B, C ...</p><p>                    key = ((_chromeNumKeyPadMap))[key];</p><p>                }</p><p>            }</p><p>        }</p><p>        return _keyMap[key] || key;</p><p>    };</p><p>    /**</p><p>     * @param {?} doc</p><p>     * @param {?} target</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.getGlobalEventTarget = function (doc, target) {</p><p>        if (target === 'window') {</p><p>            return window;</p><p>        }</p><p>        if (target === 'document') {</p><p>            return document;</p><p>        }</p><p>        if (target === 'body') {</p><p>            return document.body;</p><p>        }</p><p>        return null;</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.getHistory = function () { return window.history; };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.getLocation = function () { return window.location; };</p><p>    /**</p><p>     * @param {?} doc</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.getBaseHref = function (doc) {</p><p>        var /** @type {?} */ href = getBaseElementHref();</p><p>        return href == null ? null : relativePath(href);</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.resetBaseElement = function () { baseElement = null; };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.getUserAgent = function () { return window.navigator.userAgent; };</p><p>    /**</p><p>     * @param {?} element</p><p>     * @param {?} name</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.setData = function (element, name, value) {</p><p>        this.setAttribute(element, 'data-' + name, value);</p><p>    };</p><p>    /**</p><p>     * @param {?} element</p><p>     * @param {?} name</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.getData = function (element, name) {</p><p>        return this.getAttribute(element, 'data-' + name);</p><p>    };</p><p>    /**</p><p>     * @param {?} element</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.getComputedStyle = function (element) { return getComputedStyle(element); };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.supportsWebAnimation = function () {</p><p>        return typeof ((Element)).prototype['animate'] === 'function';</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.performanceNow = function () {</p><p>        // performance.now() is not available in all browsers, see</p><p>        // http://caniuse.com/#search=performance.now</p><p>        return window.performance && window.performance.now ? window.performance.now() :</p><p>            new Date().getTime();</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.supportsCookies = function () { return true; };</p><p>    /**</p><p>     * @param {?} name</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.getCookie = function (name) { return Object(__WEBPACK_IMPORTED_MODULE_1__angular_common__["ɵparseCookieValue"])(document.cookie, name); };</p><p>    /**</p><p>     * @param {?} name</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    BrowserDomAdapter.prototype.setCookie = function (name, value) {</p><p>        // document.cookie is magical, assigning into it assigns/overrides one cookie value, but does</p><p>        // not clear other cookies.</p><p>        document.cookie = encodeURIComponent(name) + '=' + encodeURIComponent(value);</p><p>    };</p><p>    return BrowserDomAdapter;</p><p>}(GenericBrowserDomAdapter));</p><p>var baseElement = null;</p><p>/**</p><p> * @return {?}</p><p> */</p><p>function getBaseElementHref() {</p><p>    if (!baseElement) {</p><p>        baseElement = ((document.querySelector('base')));</p><p>        if (!baseElement) {</p><p>            return null;</p><p>        }</p><p>    }</p><p>    return baseElement.getAttribute('href');</p><p>}</p><p>// based on urlUtils.js in AngularJS 1</p><p>var urlParsingNode;</p><p>/**</p><p> * @param {?} url</p><p> * @return {?}</p><p> */</p><p>function relativePath(url) {</p><p>    if (!urlParsingNode) {</p><p>        urlParsingNode = document.createElement('a');</p><p>    }</p><p>    urlParsingNode.setAttribute('href', url);</p><p>    return (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname :</p><p>        '/' + urlParsingNode.pathname;</p><p>}</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * A DI Token representing the main rendering context. In a browser this is the DOM Document.</p><p> *</p><p> * Note: Document might not be available in the Application Context when Application and Rendering</p><p> * Contexts are not the same (e.g. when running the application into a Web Worker).</p><p> *</p><p> * @deprecated import from `\@angular/common` instead.</p><p> */</p><p>var DOCUMENT$1 = __WEBPACK_IMPORTED_MODULE_1__angular_common__["DOCUMENT"];</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> * @return {?}</p><p> */</p><p>function supportsState() {</p><p>    return !!window.history.pushState;</p><p>}</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * `PlatformLocation` encapsulates all of the direct calls to platform APIs.</p><p> * This class should not be used directly by an application developer. Instead, use</p><p> * {\@link Location}.</p><p> */</p><p>var BrowserPlatformLocation = (function (_super) {</p><p>    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](BrowserPlatformLocation, _super);</p><p>    /**</p><p>     * @param {?} _doc</p><p>     */</p><p>    function BrowserPlatformLocation(_doc) {</p><p>        var _this = _super.call(this) || this;</p><p>        _this._doc = _doc;</p><p>        _this._init();</p><p>        return _this;</p><p>    }</p><p>    /**</p><p>     * \@internal</p><p>     * @return {?}</p><p>     */</p><p>    BrowserPlatformLocation.prototype._init = function () {</p><p>        this._location = getDOM().getLocation();</p><p>        this._history = getDOM().getHistory();</p><p>    };</p><p>    Object.defineProperty(BrowserPlatformLocation.prototype, "location", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this._location; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    BrowserPlatformLocation.prototype.getBaseHrefFromDOM = function () { return ((getDOM().getBaseHref(this._doc))); };</p><p>    /**</p><p>     * @param {?} fn</p><p>     * @return {?}</p><p>     */</p><p>    BrowserPlatformLocation.prototype.onPopState = function (fn) {</p><p>        getDOM().getGlobalEventTarget(this._doc, 'window').addEventListener('popstate', fn, false);</p><p>    };</p><p>    /**</p><p>     * @param {?} fn</p><p>     * @return {?}</p><p>     */</p><p>    BrowserPlatformLocation.prototype.onHashChange = function (fn) {</p><p>        getDOM().getGlobalEventTarget(this._doc, 'window').addEventListener('hashchange', fn, false);</p><p>    };</p><p>    Object.defineProperty(BrowserPlatformLocation.prototype, "pathname", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this._location.pathname; },</p><p>        /**</p><p>         * @param {?} newPath</p><p>         * @return {?}</p><p>         */</p><p>        set: function (newPath) { this._location.pathname = newPath; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(BrowserPlatformLocation.prototype, "search", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this._location.search; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(BrowserPlatformLocation.prototype, "hash", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this._location.hash; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    /**</p><p>     * @param {?} state</p><p>     * @param {?} title</p><p>     * @param {?} url</p><p>     * @return {?}</p><p>     */</p><p>    BrowserPlatformLocation.prototype.pushState = function (state, title, url) {</p><p>        if (supportsState()) {</p><p>            this._history.pushState(state, title, url);</p><p>        }</p><p>        else {</p><p>            this._location.hash = url;</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @param {?} state</p><p>     * @param {?} title</p><p>     * @param {?} url</p><p>     * @return {?}</p><p>     */</p><p>    BrowserPlatformLocation.prototype.replaceState = function (state, title, url) {</p><p>        if (supportsState()) {</p><p>            this._history.replaceState(state, title, url);</p><p>        }</p><p>        else {</p><p>            this._location.hash = url;</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    BrowserPlatformLocation.prototype.forward = function () { this._history.forward(); };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    BrowserPlatformLocation.prototype.back = function () { this._history.back(); };</p><p>    return BrowserPlatformLocation;</p><p>}(__WEBPACK_IMPORTED_MODULE_1__angular_common__["PlatformLocation"]));</p><p>BrowserPlatformLocation.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>BrowserPlatformLocation.ctorParameters = function () { return [</p><p>    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Inject"], args: [DOCUMENT$1,] },] },</p><p>]; };</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * A service that can be used to get and add meta tags.</p><p> *</p><p> * \@experimental</p><p> */</p><p>var Meta = (function () {</p><p>    /**</p><p>     * @param {?} _doc</p><p>     */</p><p>    function Meta(_doc) {</p><p>        this._doc = _doc;</p><p>        this._dom = getDOM();</p><p>    }</p><p>    /**</p><p>     * @param {?} tag</p><p>     * @param {?=} forceCreation</p><p>     * @return {?}</p><p>     */</p><p>    Meta.prototype.addTag = function (tag, forceCreation) {</p><p>        if (forceCreation === void 0) { forceCreation = false; }</p><p>        if (!tag)</p><p>            return null;</p><p>        return this._getOrCreateElement(tag, forceCreation);</p><p>    };</p><p>    /**</p><p>     * @param {?} tags</p><p>     * @param {?=} forceCreation</p><p>     * @return {?}</p><p>     */</p><p>    Meta.prototype.addTags = function (tags, forceCreation) {</p><p>        var _this = this;</p><p>        if (forceCreation === void 0) { forceCreation = false; }</p><p>        if (!tags)</p><p>            return [];</p><p>        return tags.reduce(function (result, tag) {</p><p>            if (tag) {</p><p>                result.push(_this._getOrCreateElement(tag, forceCreation));</p><p>            }</p><p>            return result;</p><p>        }, []);</p><p>    };</p><p>    /**</p><p>     * @param {?} attrSelector</p><p>     * @return {?}</p><p>     */</p><p>    Meta.prototype.getTag = function (attrSelector) {</p><p>        if (!attrSelector)</p><p>            return null;</p><p>        return this._dom.querySelector(this._doc, "meta[" + attrSelector + "]");</p><p>    };</p><p>    /**</p><p>     * @param {?} attrSelector</p><p>     * @return {?}</p><p>     */</p><p>    Meta.prototype.getTags = function (attrSelector) {</p><p>        if (!attrSelector)</p><p>            return [];</p><p>        var /** @type {?} */ list /*NodeList*/ = this._dom.querySelectorAll(this._doc, "meta[" + attrSelector + "]");</p><p>        return list ? [].slice.call(list) : [];</p><p>    };</p><p>    /**</p><p>     * @param {?} tag</p><p>     * @param {?=} selector</p><p>     * @return {?}</p><p>     */</p><p>    Meta.prototype.updateTag = function (tag, selector) {</p><p>        if (!tag)</p><p>            return null;</p><p>        selector = selector || this._parseSelector(tag);</p><p>        var /** @type {?} */ meta = ((this.getTag(selector)));</p><p>        if (meta) {</p><p>            return this._setMetaElementAttributes(tag, meta);</p><p>        }</p><p>        return this._getOrCreateElement(tag, true);</p><p>    };</p><p>    /**</p><p>     * @param {?} attrSelector</p><p>     * @return {?}</p><p>     */</p><p>    Meta.prototype.removeTag = function (attrSelector) { this.removeTagElement(/** @type {?} */ ((this.getTag(attrSelector)))); };</p><p>    /**</p><p>     * @param {?} meta</p><p>     * @return {?}</p><p>     */</p><p>    Meta.prototype.removeTagElement = function (meta) {</p><p>        if (meta) {</p><p>            this._dom.remove(meta);</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @param {?} meta</p><p>     * @param {?=} forceCreation</p><p>     * @return {?}</p><p>     */</p><p>    Meta.prototype._getOrCreateElement = function (meta, forceCreation) {</p><p>        if (forceCreation === void 0) { forceCreation = false; }</p><p>        if (!forceCreation) {</p><p>            var /** @type {?} */ selector = this._parseSelector(meta);</p><p>            var /** @type {?} */ elem = ((this.getTag(selector)));</p><p>            // It's allowed to have multiple elements with the same name so it's not enough to</p><p>            // just check that element with the same name already present on the page. We also need to</p><p>            // check if element has tag attributes</p><p>            if (elem && this._containsAttributes(meta, elem))</p><p>                return elem;</p><p>        }</p><p>        var /** @type {?} */ element = (this._dom.createElement('meta'));</p><p>        this._setMetaElementAttributes(meta, element);</p><p>        var /** @type {?} */ head = this._dom.getElementsByTagName(this._doc, 'head')[0];</p><p>        this._dom.appendChild(head, element);</p><p>        return element;</p><p>    };</p><p>    /**</p><p>     * @param {?} tag</p><p>     * @param {?} el</p><p>     * @return {?}</p><p>     */</p><p>    Meta.prototype._setMetaElementAttributes = function (tag, el) {</p><p>        var _this = this;</p><p>        Object.keys(tag).forEach(function (prop) { return _this._dom.setAttribute(el, prop, tag[prop]); });</p><p>        return el;</p><p>    };</p><p>    /**</p><p>     * @param {?} tag</p><p>     * @return {?}</p><p>     */</p><p>    Meta.prototype._parseSelector = function (tag) {</p><p>        var /** @type {?} */ attr = tag.name ? 'name' : 'property';</p><p>        return attr + "=\"" + tag[attr] + "\"";</p><p>    };</p><p>    /**</p><p>     * @param {?} tag</p><p>     * @param {?} elem</p><p>     * @return {?}</p><p>     */</p><p>    Meta.prototype._containsAttributes = function (tag, elem) {</p><p>        var _this = this;</p><p>        return Object.keys(tag).every(function (key) { return _this._dom.getAttribute(elem, key) === tag[key]; });</p><p>    };</p><p>    return Meta;</p><p>}());</p><p>Meta.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>Meta.ctorParameters = function () { return [</p><p>    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Inject"], args: [DOCUMENT$1,] },] },</p><p>]; };</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * An id that identifies a particular application being bootstrapped, that should</p><p> * match across the client/server boundary.</p><p> */</p><p>var TRANSITION_ID = new __WEBPACK_IMPORTED_MODULE_2__angular_core__["InjectionToken"]('TRANSITION_ID');</p><p>/**</p><p> * @param {?} transitionId</p><p> * @param {?} document</p><p> * @param {?} injector</p><p> * @return {?}</p><p> */</p><p>function appInitializerFactory(transitionId, document, injector) {</p><p>    return function () {</p><p>        // Wait for all application initializers to be completed before removing the styles set by</p><p>        // the server.</p><p>        injector.get(__WEBPACK_IMPORTED_MODULE_2__angular_core__["ApplicationInitStatus"]).donePromise.then(function () {</p><p>            var /** @type {?} */ dom = getDOM();</p><p>            var /** @type {?} */ styles = Array.prototype.slice.apply(dom.querySelectorAll(document, "style[ng-transition]"));</p><p>            styles.filter(function (el) { return dom.getAttribute(el, 'ng-transition') === transitionId; })</p><p>                .forEach(function (el) { return dom.remove(el); });</p><p>        });</p><p>    };</p><p>}</p><p>var SERVER_TRANSITION_PROVIDERS = [</p><p>    {</p><p>        provide: __WEBPACK_IMPORTED_MODULE_2__angular_core__["APP_INITIALIZER"],</p><p>        useFactory: appInitializerFactory,</p><p>        deps: [TRANSITION_ID, DOCUMENT$1, __WEBPACK_IMPORTED_MODULE_2__angular_core__["Injector"]],</p><p>        multi: true</p><p>    },</p><p>];</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>var BrowserGetTestability = (function () {</p><p>    function BrowserGetTestability() {</p><p>    }</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    BrowserGetTestability.init = function () { Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["setTestabilityGetter"])(new BrowserGetTestability()); };</p><p>    /**</p><p>     * @param {?} registry</p><p>     * @return {?}</p><p>     */</p><p>    BrowserGetTestability.prototype.addToWindow = function (registry) {</p><p>        __WEBPACK_IMPORTED_MODULE_2__angular_core__["ɵglobal"]['getAngularTestability'] = function (elem, findInAncestors) {</p><p>            if (findInAncestors === void 0) { findInAncestors = true; }</p><p>            var /** @type {?} */ testability = registry.findTestabilityInTree(elem, findInAncestors);</p><p>            if (testability == null) {</p><p>                throw new Error('Could not find testability for element.');</p><p>            }</p><p>            return testability;</p><p>        };</p><p>        __WEBPACK_IMPORTED_MODULE_2__angular_core__["ɵglobal"]['getAllAngularTestabilities'] = function () { return registry.getAllTestabilities(); };</p><p>        __WEBPACK_IMPORTED_MODULE_2__angular_core__["ɵglobal"]['getAllAngularRootElements'] = function () { return registry.getAllRootElements(); };</p><p>        var /** @type {?} */ whenAllStable = function (callback /** TODO #9100 */) {</p><p>            var /** @type {?} */ testabilities = __WEBPACK_IMPORTED_MODULE_2__angular_core__["ɵglobal"]['getAllAngularTestabilities']();</p><p>            var /** @type {?} */ count = testabilities.length;</p><p>            var /** @type {?} */ didWork = false;</p><p>            var /** @type {?} */ decrement = function (didWork_ /** TODO #9100 */) {</p><p>                didWork = didWork || didWork_;</p><p>                count--;</p><p>                if (count == 0) {</p><p>                    callback(didWork);</p><p>                }</p><p>            };</p><p>            testabilities.forEach(function (testability /** TODO #9100 */) {</p><p>                testability.whenStable(decrement);</p><p>            });</p><p>        };</p><p>        if (!__WEBPACK_IMPORTED_MODULE_2__angular_core__["ɵglobal"]['frameworkStabilizers']) {</p><p>            __WEBPACK_IMPORTED_MODULE_2__angular_core__["ɵglobal"]['frameworkStabilizers'] = [];</p><p>        }</p><p>        __WEBPACK_IMPORTED_MODULE_2__angular_core__["ɵglobal"]['frameworkStabilizers'].push(whenAllStable);</p><p>    };</p><p>    /**</p><p>     * @param {?} registry</p><p>     * @param {?} elem</p><p>     * @param {?} findInAncestors</p><p>     * @return {?}</p><p>     */</p><p>    BrowserGetTestability.prototype.findTestabilityInTree = function (registry, elem, findInAncestors) {</p><p>        if (elem == null) {</p><p>            return null;</p><p>        }</p><p>        var /** @type {?} */ t = registry.getTestability(elem);</p><p>        if (t != null) {</p><p>            return t;</p><p>        }</p><p>        else if (!findInAncestors) {</p><p>            return null;</p><p>        }</p><p>        if (getDOM().isShadowRoot(elem)) {</p><p>            return this.findTestabilityInTree(registry, getDOM().getHost(elem), true);</p><p>        }</p><p>        return this.findTestabilityInTree(registry, getDOM().parentElement(elem), true);</p><p>    };</p><p>    return BrowserGetTestability;</p><p>}());</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * A service that can be used to get and set the title of a current HTML document.</p><p> *</p><p> * Since an Angular application can't be bootstrapped on the entire HTML document (`<html>` tag)</p><p> * it is not possible to bind to the `text` property of the `HTMLTitleElement` elements</p><p> * (representing the `<title>` tag). Instead, this service can be used to set and get the current</p><p> * title value.</p><p> *</p><p> * \@experimental</p><p> */</p><p>var Title = (function () {</p><p>    /**</p><p>     * @param {?} _doc</p><p>     */</p><p>    function Title(_doc) {</p><p>        this._doc = _doc;</p><p>    }</p><p>    /**</p><p>     * Get the title of the current HTML document.</p><p>     * @return {?}</p><p>     */</p><p>    Title.prototype.getTitle = function () { return getDOM().getTitle(this._doc); };</p><p>    /**</p><p>     * Set the title of the current HTML document.</p><p>     * @param {?} newTitle</p><p>     * @return {?}</p><p>     */</p><p>    Title.prototype.setTitle = function (newTitle) { getDOM().setTitle(this._doc, newTitle); };</p><p>    return Title;</p><p>}());</p><p>Title.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>Title.ctorParameters = function () { return [</p><p>    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Inject"], args: [DOCUMENT$1,] },] },</p><p>]; };</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * @param {?} input</p><p> * @return {?}</p><p> */</p><p>/**</p><p> * @param {?} input</p><p> * @return {?}</p><p> */</p><p>/**</p><p> * Exports the value under a given `name` in the global property `ng`. For example `ng.probe` if</p><p> * `name` is `'probe'`.</p><p> * @param {?} name Name under which it will be exported. Keep in mind this will be a property of the</p><p> * global `ng` object.</p><p> * @param {?} value The value to export.</p><p> * @return {?}</p><p> */</p><p>function exportNgVar(name, value) {</p><p>    if (!ng) {</p><p>        __WEBPACK_IMPORTED_MODULE_2__angular_core__["ɵglobal"]['ng'] = ng = ((__WEBPACK_IMPORTED_MODULE_2__angular_core__["ɵglobal"]['ng'])) || {};</p><p>    }</p><p>    ng[name] = value;</p><p>}</p><p>var ng;</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>var CORE_TOKENS = {</p><p>    'ApplicationRef': __WEBPACK_IMPORTED_MODULE_2__angular_core__["ApplicationRef"],</p><p>    'NgZone': __WEBPACK_IMPORTED_MODULE_2__angular_core__["NgZone"],</p><p>};</p><p>var INSPECT_GLOBAL_NAME = 'probe';</p><p>var CORE_TOKENS_GLOBAL_NAME = 'coreTokens';</p><p>/**</p><p> * Returns a {\@link DebugElement} for the given native DOM element, or</p><p> * null if the given native element does not have an Angular view associated</p><p> * with it.</p><p> * @param {?} element</p><p> * @return {?}</p><p> */</p><p>function inspectNativeElement(element) {</p><p>    return Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["getDebugNode"])(element);</p><p>}</p><p>/**</p><p> * Deprecated. Use the one from '\@angular/core'.</p><p> * @deprecated</p><p> */</p><p>var NgProbeToken$1 = (function () {</p><p>    /**</p><p>     * @param {?} name</p><p>     * @param {?} token</p><p>     */</p><p>    function NgProbeToken$1(name, token) {</p><p>        this.name = name;</p><p>        this.token = token;</p><p>    }</p><p>    return NgProbeToken$1;</p><p>}());</p><p>/**</p><p> * @param {?} extraTokens</p><p> * @param {?} coreTokens</p><p> * @return {?}</p><p> */</p><p>function _createNgProbe(extraTokens, coreTokens) {</p><p>    var /** @type {?} */ tokens = (extraTokens || []).concat(coreTokens || []);</p><p>    exportNgVar(INSPECT_GLOBAL_NAME, inspectNativeElement);</p><p>    exportNgVar(CORE_TOKENS_GLOBAL_NAME, Object.assign({}, CORE_TOKENS, _ngProbeTokensToMap(tokens || [])));</p><p>    return function () { return inspectNativeElement; };</p><p>}</p><p>/**</p><p> * @param {?} tokens</p><p> * @return {?}</p><p> */</p><p>function _ngProbeTokensToMap(tokens) {</p><p>    return tokens.reduce(function (prev, t) { return (prev[t.name] = t.token, prev); }, {});</p><p>}</p><p>/**</p><p> * Providers which support debugging Angular applications (e.g. via `ng.probe`).</p><p> */</p><p>var ELEMENT_PROBE_PROVIDERS = [</p><p>    {</p><p>        provide: __WEBPACK_IMPORTED_MODULE_2__angular_core__["APP_INITIALIZER"],</p><p>        useFactory: _createNgProbe,</p><p>        deps: [</p><p>            [NgProbeToken$1, new __WEBPACK_IMPORTED_MODULE_2__angular_core__["Optional"]()],</p><p>            [__WEBPACK_IMPORTED_MODULE_2__angular_core__["NgProbeToken"], new __WEBPACK_IMPORTED_MODULE_2__angular_core__["Optional"]()],</p><p>        ],</p><p>        multi: true,</p><p>    },</p><p>];</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * \@stable</p><p> */</p><p>var EVENT_MANAGER_PLUGINS = new __WEBPACK_IMPORTED_MODULE_2__angular_core__["InjectionToken"]('EventManagerPlugins');</p><p>/**</p><p> * \@stable</p><p> */</p><p>var EventManager = (function () {</p><p>    /**</p><p>     * @param {?} plugins</p><p>     * @param {?} _zone</p><p>     */</p><p>    function EventManager(plugins, _zone) {</p><p>        var _this = this;</p><p>        this._zone = _zone;</p><p>        this._eventNameToPlugin = new Map();</p><p>        plugins.forEach(function (p) { return p.manager = _this; });</p><p>        this._plugins = plugins.slice().reverse();</p><p>    }</p><p>    /**</p><p>     * @param {?} element</p><p>     * @param {?} eventName</p><p>     * @param {?} handler</p><p>     * @return {?}</p><p>     */</p><p>    EventManager.prototype.addEventListener = function (element, eventName, handler) {</p><p>        var /** @type {?} */ plugin = this._findPluginFor(eventName);</p><p>        return plugin.addEventListener(element, eventName, handler);</p><p>    };</p><p>    /**</p><p>     * @param {?} target</p><p>     * @param {?} eventName</p><p>     * @param {?} handler</p><p>     * @return {?}</p><p>     */</p><p>    EventManager.prototype.addGlobalEventListener = function (target, eventName, handler) {</p><p>        var /** @type {?} */ plugin = this._findPluginFor(eventName);</p><p>        return plugin.addGlobalEventListener(target, eventName, handler);</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    EventManager.prototype.getZone = function () { return this._zone; };</p><p>    /**</p><p>     * \@internal</p><p>     * @param {?} eventName</p><p>     * @return {?}</p><p>     */</p><p>    EventManager.prototype._findPluginFor = function (eventName) {</p><p>        var /** @type {?} */ plugin = this._eventNameToPlugin.get(eventName);</p><p>        if (plugin) {</p><p>            return plugin;</p><p>        }</p><p>        var /** @type {?} */ plugins = this._plugins;</p><p>        for (var /** @type {?} */ i = 0; i < plugins.length; i++) {</p><p>            var /** @type {?} */ plugin_1 = plugins[i];</p><p>            if (plugin_1.supports(eventName)) {</p><p>                this._eventNameToPlugin.set(eventName, plugin_1);</p><p>                return plugin_1;</p><p>            }</p><p>        }</p><p>        throw new Error("No event manager plugin found for event " + eventName);</p><p>    };</p><p>    return EventManager;</p><p>}());</p><p>EventManager.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>EventManager.ctorParameters = function () { return [</p><p>    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Inject"], args: [EVENT_MANAGER_PLUGINS,] },] },</p><p>    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["NgZone"], },</p><p>]; };</p><p>/**</p><p> * @abstract</p><p> */</p><p>var EventManagerPlugin = (function () {</p><p>    /**</p><p>     * @param {?} _doc</p><p>     */</p><p>    function EventManagerPlugin(_doc) {</p><p>        this._doc = _doc;</p><p>    }</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} eventName</p><p>     * @return {?}</p><p>     */</p><p>    EventManagerPlugin.prototype.supports = function (eventName) { };</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} element</p><p>     * @param {?} eventName</p><p>     * @param {?} handler</p><p>     * @return {?}</p><p>     */</p><p>    EventManagerPlugin.prototype.addEventListener = function (element, eventName, handler) { };</p><p>    /**</p><p>     * @param {?} element</p><p>     * @param {?} eventName</p><p>     * @param {?} handler</p><p>     * @return {?}</p><p>     */</p><p>    EventManagerPlugin.prototype.addGlobalEventListener = function (element, eventName, handler) {</p><p>        var /** @type {?} */ target = getDOM().getGlobalEventTarget(this._doc, element);</p><p>        if (!target) {</p><p>            throw new Error("Unsupported event target " + target + " for event " + eventName);</p><p>        }</p><p>        return this.addEventListener(target, eventName, handler);</p><p>    };</p><p>    ;</p><p>    return EventManagerPlugin;</p><p>}());</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>var SharedStylesHost = (function () {</p><p>    function SharedStylesHost() {</p><p>        /**</p><p>         * \@internal</p><p>         */</p><p>        this._stylesSet = new Set();</p><p>    }</p><p>    /**</p><p>     * @param {?} styles</p><p>     * @return {?}</p><p>     */</p><p>    SharedStylesHost.prototype.addStyles = function (styles) {</p><p>        var _this = this;</p><p>        var /** @type {?} */ additions = new Set();</p><p>        styles.forEach(function (style) {</p><p>            if (!_this._stylesSet.has(style)) {</p><p>                _this._stylesSet.add(style);</p><p>                additions.add(style);</p><p>            }</p><p>        });</p><p>        this.onStylesAdded(additions);</p><p>    };</p><p>    /**</p><p>     * @param {?} additions</p><p>     * @return {?}</p><p>     */</p><p>    SharedStylesHost.prototype.onStylesAdded = function (additions) { };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    SharedStylesHost.prototype.getAllStyles = function () { return Array.from(this._stylesSet); };</p><p>    return SharedStylesHost;</p><p>}());</p><p>SharedStylesHost.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>SharedStylesHost.ctorParameters = function () { return []; };</p><p>var DomSharedStylesHost = (function (_super) {</p><p>    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](DomSharedStylesHost, _super);</p><p>    /**</p><p>     * @param {?} _doc</p><p>     */</p><p>    function DomSharedStylesHost(_doc) {</p><p>        var _this = _super.call(this) || this;</p><p>        _this._doc = _doc;</p><p>        _this._hostNodes = new Set();</p><p>        _this._styleNodes = new Set();</p><p>        _this._hostNodes.add(_doc.head);</p><p>        return _this;</p><p>    }</p><p>    /**</p><p>     * @param {?} styles</p><p>     * @param {?} host</p><p>     * @return {?}</p><p>     */</p><p>    DomSharedStylesHost.prototype._addStylesToHost = function (styles, host) {</p><p>        var _this = this;</p><p>        styles.forEach(function (style) {</p><p>            var /** @type {?} */ styleEl = _this._doc.createElement('style');</p><p>            styleEl.textContent = style;</p><p>            _this._styleNodes.add(host.appendChild(styleEl));</p><p>        });</p><p>    };</p><p>    /**</p><p>     * @param {?} hostNode</p><p>     * @return {?}</p><p>     */</p><p>    DomSharedStylesHost.prototype.addHost = function (hostNode) {</p><p>        this._addStylesToHost(this._stylesSet, hostNode);</p><p>        this._hostNodes.add(hostNode);</p><p>    };</p><p>    /**</p><p>     * @param {?} hostNode</p><p>     * @return {?}</p><p>     */</p><p>    DomSharedStylesHost.prototype.removeHost = function (hostNode) { this._hostNodes.delete(hostNode); };</p><p>    /**</p><p>     * @param {?} additions</p><p>     * @return {?}</p><p>     */</p><p>    DomSharedStylesHost.prototype.onStylesAdded = function (additions) {</p><p>        var _this = this;</p><p>        this._hostNodes.forEach(function (hostNode) { return _this._addStylesToHost(additions, hostNode); });</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    DomSharedStylesHost.prototype.ngOnDestroy = function () { this._styleNodes.forEach(function (styleNode) { return getDOM().remove(styleNode); }); };</p><p>    return DomSharedStylesHost;</p><p>}(SharedStylesHost));</p><p>DomSharedStylesHost.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>DomSharedStylesHost.ctorParameters = function () { return [</p><p>    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Inject"], args: [DOCUMENT$1,] },] },</p><p>]; };</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>var NAMESPACE_URIS = {</p><p>    'svg': 'http://www.w3.org/2000/svg',</p><p>    'xhtml': 'http://www.w3.org/1999/xhtml',</p><p>    'xlink': 'http://www.w3.org/1999/xlink',</p><p>    'xml': 'http://www.w3.org/XML/1998/namespace',</p><p>    'xmlns': 'http://www.w3.org/2000/xmlns/',</p><p>};</p><p>var COMPONENT_REGEX = /%COMP%/g;</p><p>var COMPONENT_VARIABLE = '%COMP%';</p><p>var HOST_ATTR = "_nghost-" + COMPONENT_VARIABLE;</p><p>var CONTENT_ATTR = "_ngcontent-" + COMPONENT_VARIABLE;</p><p>/**</p><p> * @param {?} componentShortId</p><p> * @return {?}</p><p> */</p><p>function shimContentAttribute(componentShortId) {</p><p>    return CONTENT_ATTR.replace(COMPONENT_REGEX, componentShortId);</p><p>}</p><p>/**</p><p> * @param {?} componentShortId</p><p> * @return {?}</p><p> */</p><p>function shimHostAttribute(componentShortId) {</p><p>    return HOST_ATTR.replace(COMPONENT_REGEX, componentShortId);</p><p>}</p><p>/**</p><p> * @param {?} compId</p><p> * @param {?} styles</p><p> * @param {?} target</p><p> * @return {?}</p><p> */</p><p>function flattenStyles(compId, styles, target) {</p><p>    for (var /** @type {?} */ i = 0; i < styles.length; i++) {</p><p>        var /** @type {?} */ style = styles[i];</p><p>        if (Array.isArray(style)) {</p><p>            flattenStyles(compId, style, target);</p><p>        }</p><p>        else {</p><p>            style = style.replace(COMPONENT_REGEX, compId);</p><p>            target.push(style);</p><p>        }</p><p>    }</p><p>    return target;</p><p>}</p><p>/**</p><p> * @param {?} eventHandler</p><p> * @return {?}</p><p> */</p><p>function decoratePreventDefault(eventHandler) {</p><p>    return function (event) {</p><p>        var /** @type {?} */ allowDefaultBehavior = eventHandler(event);</p><p>        if (allowDefaultBehavior === false) {</p><p>            // TODO(tbosch): move preventDefault into event plugins...</p><p>            event.preventDefault();</p><p>            event.returnValue = false;</p><p>        }</p><p>    };</p><p>}</p><p>var DomRendererFactory2 = (function () {</p><p>    /**</p><p>     * @param {?} eventManager</p><p>     * @param {?} sharedStylesHost</p><p>     */</p><p>    function DomRendererFactory2(eventManager, sharedStylesHost) {</p><p>        this.eventManager = eventManager;</p><p>        this.sharedStylesHost = sharedStylesHost;</p><p>        this.rendererByCompId = new Map();</p><p>        this.defaultRenderer = new DefaultDomRenderer2(eventManager);</p><p>    }</p><p>    ;</p><p>    /**</p><p>     * @param {?} element</p><p>     * @param {?} type</p><p>     * @return {?}</p><p>     */</p><p>    DomRendererFactory2.prototype.createRenderer = function (element, type) {</p><p>        if (!element || !type) {</p><p>            return this.defaultRenderer;</p><p>        }</p><p>        switch (type.encapsulation) {</p><p>            case __WEBPACK_IMPORTED_MODULE_2__angular_core__["ViewEncapsulation"].Emulated: {</p><p>                var /** @type {?} */ renderer = this.rendererByCompId.get(type.id);</p><p>                if (!renderer) {</p><p>                    renderer =</p><p>                        new EmulatedEncapsulationDomRenderer2(this.eventManager, this.sharedStylesHost, type);</p><p>                    this.rendererByCompId.set(type.id, renderer);</p><p>                }</p><p>                ((renderer)).applyToHost(element);</p><p>                return renderer;</p><p>            }</p><p>            case __WEBPACK_IMPORTED_MODULE_2__angular_core__["ViewEncapsulation"].Native:</p><p>                return new ShadowDomRenderer(this.eventManager, this.sharedStylesHost, element, type);</p><p>            default: {</p><p>                if (!this.rendererByCompId.has(type.id)) {</p><p>                    var /** @type {?} */ styles = flattenStyles(type.id, type.styles, []);</p><p>                    this.sharedStylesHost.addStyles(styles);</p><p>                    this.rendererByCompId.set(type.id, this.defaultRenderer);</p><p>                }</p><p>                return this.defaultRenderer;</p><p>            }</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    DomRendererFactory2.prototype.begin = function () { };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    DomRendererFactory2.prototype.end = function () { };</p><p>    return DomRendererFactory2;</p><p>}());</p><p>DomRendererFactory2.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>DomRendererFactory2.ctorParameters = function () { return [</p><p>    { type: EventManager, },</p><p>    { type: DomSharedStylesHost, },</p><p>]; };</p><p>var DefaultDomRenderer2 = (function () {</p><p>    /**</p><p>     * @param {?} eventManager</p><p>     */</p><p>    function DefaultDomRenderer2(eventManager) {</p><p>        this.eventManager = eventManager;</p><p>        this.data = Object.create(null);</p><p>    }</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    DefaultDomRenderer2.prototype.destroy = function () { };</p><p>    /**</p><p>     * @param {?} name</p><p>     * @param {?=} namespace</p><p>     * @return {?}</p><p>     */</p><p>    DefaultDomRenderer2.prototype.createElement = function (name, namespace) {</p><p>        if (namespace) {</p><p>            return document.createElementNS(NAMESPACE_URIS[namespace], name);</p><p>        }</p><p>        return document.createElement(name);</p><p>    };</p><p>    /**</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    DefaultDomRenderer2.prototype.createComment = function (value) { return document.createComment(value); };</p><p>    /**</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    DefaultDomRenderer2.prototype.createText = function (value) { return document.createTextNode(value); };</p><p>    /**</p><p>     * @param {?} parent</p><p>     * @param {?} newChild</p><p>     * @return {?}</p><p>     */</p><p>    DefaultDomRenderer2.prototype.appendChild = function (parent, newChild) { parent.appendChild(newChild); };</p><p>    /**</p><p>     * @param {?} parent</p><p>     * @param {?} newChild</p><p>     * @param {?} refChild</p><p>     * @return {?}</p><p>     */</p><p>    DefaultDomRenderer2.prototype.insertBefore = function (parent, newChild, refChild) {</p><p>        if (parent) {</p><p>            parent.insertBefore(newChild, refChild);</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @param {?} parent</p><p>     * @param {?} oldChild</p><p>     * @return {?}</p><p>     */</p><p>    DefaultDomRenderer2.prototype.removeChild = function (parent, oldChild) {</p><p>        if (parent) {</p><p>            parent.removeChild(oldChild);</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @param {?} selectorOrNode</p><p>     * @return {?}</p><p>     */</p><p>    DefaultDomRenderer2.prototype.selectRootElement = function (selectorOrNode) {</p><p>        var /** @type {?} */ el = typeof selectorOrNode === 'string' ? document.querySelector(selectorOrNode) :</p><p>            selectorOrNode;</p><p>        if (!el) {</p><p>            throw new Error("The selector \"" + selectorOrNode + "\" did not match any elements");</p><p>        }</p><p>        el.textContent = '';</p><p>        return el;</p><p>    };</p><p>    /**</p><p>     * @param {?} node</p><p>     * @return {?}</p><p>     */</p><p>    DefaultDomRenderer2.prototype.parentNode = function (node) { return node.parentNode; };</p><p>    /**</p><p>     * @param {?} node</p><p>     * @return {?}</p><p>     */</p><p>    DefaultDomRenderer2.prototype.nextSibling = function (node) { return node.nextSibling; };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @param {?} name</p><p>     * @param {?} value</p><p>     * @param {?=} namespace</p><p>     * @return {?}</p><p>     */</p><p>    DefaultDomRenderer2.prototype.setAttribute = function (el, name, value, namespace) {</p><p>        if (namespace) {</p><p>            name = namespace + ":" + name;</p><p>            var /** @type {?} */ namespaceUri = NAMESPACE_URIS[namespace];</p><p>            if (namespaceUri) {</p><p>                el.setAttributeNS(namespaceUri, name, value);</p><p>            }</p><p>            else {</p><p>                el.setAttribute(name, value);</p><p>            }</p><p>        }</p><p>        else {</p><p>            el.setAttribute(name, value);</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @param {?} name</p><p>     * @param {?=} namespace</p><p>     * @return {?}</p><p>     */</p><p>    DefaultDomRenderer2.prototype.removeAttribute = function (el, name, namespace) {</p><p>        if (namespace) {</p><p>            var /** @type {?} */ namespaceUri = NAMESPACE_URIS[namespace];</p><p>            if (namespaceUri) {</p><p>                el.removeAttributeNS(namespaceUri, name);</p><p>            }</p><p>            else {</p><p>                el.removeAttribute(namespace + ":" + name);</p><p>            }</p><p>        }</p><p>        else {</p><p>            el.removeAttribute(name);</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @param {?} name</p><p>     * @return {?}</p><p>     */</p><p>    DefaultDomRenderer2.prototype.addClass = function (el, name) { el.classList.add(name); };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @param {?} name</p><p>     * @return {?}</p><p>     */</p><p>    DefaultDomRenderer2.prototype.removeClass = function (el, name) { el.classList.remove(name); };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @param {?} style</p><p>     * @param {?} value</p><p>     * @param {?} flags</p><p>     * @return {?}</p><p>     */</p><p>    DefaultDomRenderer2.prototype.setStyle = function (el, style, value, flags) {</p><p>        if (flags & __WEBPACK_IMPORTED_MODULE_2__angular_core__["RendererStyleFlags2"].DashCase) {</p><p>            el.style.setProperty(style, value, !!(flags & __WEBPACK_IMPORTED_MODULE_2__angular_core__["RendererStyleFlags2"].Important) ? 'important' : '');</p><p>        }</p><p>        else {</p><p>            el.style[style] = value;</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @param {?} style</p><p>     * @param {?} flags</p><p>     * @return {?}</p><p>     */</p><p>    DefaultDomRenderer2.prototype.removeStyle = function (el, style, flags) {</p><p>        if (flags & __WEBPACK_IMPORTED_MODULE_2__angular_core__["RendererStyleFlags2"].DashCase) {</p><p>            el.style.removeProperty(style);</p><p>        }</p><p>        else {</p><p>            // IE requires '' instead of null</p><p>            // see https://github.com/angular/angular/issues/7916</p><p>            el.style[style] = '';</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @param {?} name</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    DefaultDomRenderer2.prototype.setProperty = function (el, name, value) {</p><p>        checkNoSyntheticProp(name, 'property');</p><p>        el[name] = value;</p><p>    };</p><p>    /**</p><p>     * @param {?} node</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    DefaultDomRenderer2.prototype.setValue = function (node, value) { node.nodeValue = value; };</p><p>    /**</p><p>     * @param {?} target</p><p>     * @param {?} event</p><p>     * @param {?} callback</p><p>     * @return {?}</p><p>     */</p><p>    DefaultDomRenderer2.prototype.listen = function (target, event, callback) {</p><p>        checkNoSyntheticProp(event, 'listener');</p><p>        if (typeof target === 'string') {</p><p>            return (this.eventManager.addGlobalEventListener(target, event, decoratePreventDefault(callback)));</p><p>        }</p><p>        return ((this.eventManager.addEventListener(target, event, decoratePreventDefault(callback))));</p><p>    };</p><p>    return DefaultDomRenderer2;</p><p>}());</p><p>var AT_CHARCODE = '@'.charCodeAt(0);</p><p>/**</p><p> * @param {?} name</p><p> * @param {?} nameKind</p><p> * @return {?}</p><p> */</p><p>function checkNoSyntheticProp(name, nameKind) {</p><p>    if (name.charCodeAt(0) === AT_CHARCODE) {</p><p>        throw new Error("Found the synthetic " + nameKind + " " + name + ". Please include either \"BrowserAnimationsModule\" or \"NoopAnimationsModule\" in your application.");</p><p>    }</p><p>}</p><p>var EmulatedEncapsulationDomRenderer2 = (function (_super) {</p><p>    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](EmulatedEncapsulationDomRenderer2, _super);</p><p>    /**</p><p>     * @param {?} eventManager</p><p>     * @param {?} sharedStylesHost</p><p>     * @param {?} component</p><p>     */</p><p>    function EmulatedEncapsulationDomRenderer2(eventManager, sharedStylesHost, component) {</p><p>        var _this = _super.call(this, eventManager) || this;</p><p>        _this.component = component;</p><p>        var styles = flattenStyles(component.id, component.styles, []);</p><p>        sharedStylesHost.addStyles(styles);</p><p>        _this.contentAttr = shimContentAttribute(component.id);</p><p>        _this.hostAttr = shimHostAttribute(component.id);</p><p>        return _this;</p><p>    }</p><p>    /**</p><p>     * @param {?} element</p><p>     * @return {?}</p><p>     */</p><p>    EmulatedEncapsulationDomRenderer2.prototype.applyToHost = function (element) { _super.prototype.setAttribute.call(this, element, this.hostAttr, ''); };</p><p>    /**</p><p>     * @param {?} parent</p><p>     * @param {?} name</p><p>     * @return {?}</p><p>     */</p><p>    EmulatedEncapsulationDomRenderer2.prototype.createElement = function (parent, name) {</p><p>        var /** @type {?} */ el = _super.prototype.createElement.call(this, parent, name);</p><p>        _super.prototype.setAttribute.call(this, el, this.contentAttr, '');</p><p>        return el;</p><p>    };</p><p>    return EmulatedEncapsulationDomRenderer2;</p><p>}(DefaultDomRenderer2));</p><p>var ShadowDomRenderer = (function (_super) {</p><p>    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](ShadowDomRenderer, _super);</p><p>    /**</p><p>     * @param {?} eventManager</p><p>     * @param {?} sharedStylesHost</p><p>     * @param {?} hostEl</p><p>     * @param {?} component</p><p>     */</p><p>    function ShadowDomRenderer(eventManager, sharedStylesHost, hostEl, component) {</p><p>        var _this = _super.call(this, eventManager) || this;</p><p>        _this.sharedStylesHost = sharedStylesHost;</p><p>        _this.hostEl = hostEl;</p><p>        _this.component = component;</p><p>        _this.shadowRoot = hostEl.createShadowRoot();</p><p>        _this.sharedStylesHost.addHost(_this.shadowRoot);</p><p>        var styles = flattenStyles(component.id, component.styles, []);</p><p>        for (var i = 0; i < styles.length; i++) {</p><p>            var styleEl = document.createElement('style');</p><p>            styleEl.textContent = styles[i];</p><p>            _this.shadowRoot.appendChild(styleEl);</p><p>        }</p><p>        return _this;</p><p>    }</p><p>    /**</p><p>     * @param {?} node</p><p>     * @return {?}</p><p>     */</p><p>    ShadowDomRenderer.prototype.nodeOrShadowRoot = function (node) { return node === this.hostEl ? this.shadowRoot : node; };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    ShadowDomRenderer.prototype.destroy = function () { this.sharedStylesHost.removeHost(this.shadowRoot); };</p><p>    /**</p><p>     * @param {?} parent</p><p>     * @param {?} newChild</p><p>     * @return {?}</p><p>     */</p><p>    ShadowDomRenderer.prototype.appendChild = function (parent, newChild) {</p><p>        return _super.prototype.appendChild.call(this, this.nodeOrShadowRoot(parent), newChild);</p><p>    };</p><p>    /**</p><p>     * @param {?} parent</p><p>     * @param {?} newChild</p><p>     * @param {?} refChild</p><p>     * @return {?}</p><p>     */</p><p>    ShadowDomRenderer.prototype.insertBefore = function (parent, newChild, refChild) {</p><p>        return _super.prototype.insertBefore.call(this, this.nodeOrShadowRoot(parent), newChild, refChild);</p><p>    };</p><p>    /**</p><p>     * @param {?} parent</p><p>     * @param {?} oldChild</p><p>     * @return {?}</p><p>     */</p><p>    ShadowDomRenderer.prototype.removeChild = function (parent, oldChild) {</p><p>        return _super.prototype.removeChild.call(this, this.nodeOrShadowRoot(parent), oldChild);</p><p>    };</p><p>    /**</p><p>     * @param {?} node</p><p>     * @return {?}</p><p>     */</p><p>    ShadowDomRenderer.prototype.parentNode = function (node) {</p><p>        return this.nodeOrShadowRoot(_super.prototype.parentNode.call(this, this.nodeOrShadowRoot(node)));</p><p>    };</p><p>    return ShadowDomRenderer;</p><p>}(DefaultDomRenderer2));</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>var DomEventsPlugin = (function (_super) {</p><p>    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](DomEventsPlugin, _super);</p><p>    /**</p><p>     * @param {?} doc</p><p>     */</p><p>    function DomEventsPlugin(doc) {</p><p>        return _super.call(this, doc) || this;</p><p>    }</p><p>    /**</p><p>     * @param {?} eventName</p><p>     * @return {?}</p><p>     */</p><p>    DomEventsPlugin.prototype.supports = function (eventName) { return true; };</p><p>    /**</p><p>     * @param {?} element</p><p>     * @param {?} eventName</p><p>     * @param {?} handler</p><p>     * @return {?}</p><p>     */</p><p>    DomEventsPlugin.prototype.addEventListener = function (element, eventName, handler) {</p><p>        element.addEventListener(eventName, /** @type {?} */ (handler), false);</p><p>        return function () { return element.removeEventListener(eventName, /** @type {?} */ (handler), false); };</p><p>    };</p><p>    return DomEventsPlugin;</p><p>}(EventManagerPlugin));</p><p>DomEventsPlugin.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>DomEventsPlugin.ctorParameters = function () { return [</p><p>    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Inject"], args: [DOCUMENT$1,] },] },</p><p>]; };</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>var EVENT_NAMES = {</p><p>    // pan</p><p>    'pan': true,</p><p>    'panstart': true,</p><p>    'panmove': true,</p><p>    'panend': true,</p><p>    'pancancel': true,</p><p>    'panleft': true,</p><p>    'panright': true,</p><p>    'panup': true,</p><p>    'pandown': true,</p><p>    // pinch</p><p>    'pinch': true,</p><p>    'pinchstart': true,</p><p>    'pinchmove': true,</p><p>    'pinchend': true,</p><p>    'pinchcancel': true,</p><p>    'pinchin': true,</p><p>    'pinchout': true,</p><p>    // press</p><p>    'press': true,</p><p>    'pressup': true,</p><p>    // rotate</p><p>    'rotate': true,</p><p>    'rotatestart': true,</p><p>    'rotatemove': true,</p><p>    'rotateend': true,</p><p>    'rotatecancel': true,</p><p>    // swipe</p><p>    'swipe': true,</p><p>    'swipeleft': true,</p><p>    'swiperight': true,</p><p>    'swipeup': true,</p><p>    'swipedown': true,</p><p>    // tap</p><p>    'tap': true,</p><p>};</p><p>/**</p><p> * A DI token that you can use to provide{\@link HammerGestureConfig} to Angular. Use it to configure</p><p> * Hammer gestures.</p><p> *</p><p> * \@experimental</p><p> */</p><p>var HAMMER_GESTURE_CONFIG = new __WEBPACK_IMPORTED_MODULE_2__angular_core__["InjectionToken"]('HammerGestureConfig');</p><p>/**</p><p> * \@experimental</p><p> */</p><p>var HammerGestureConfig = (function () {</p><p>    function HammerGestureConfig() {</p><p>        this.events = [];</p><p>        this.overrides = {};</p><p>    }</p><p>    /**</p><p>     * @param {?} element</p><p>     * @return {?}</p><p>     */</p><p>    HammerGestureConfig.prototype.buildHammer = function (element) {</p><p>        var /** @type {?} */ mc = new Hammer(element);</p><p>        mc.get('pinch').set({ enable: true });</p><p>        mc.get('rotate').set({ enable: true });</p><p>        for (var /** @type {?} */ eventName in this.overrides) {</p><p>            mc.get(eventName).set(this.overrides[eventName]);</p><p>        }</p><p>        return mc;</p><p>    };</p><p>    return HammerGestureConfig;</p><p>}());</p><p>HammerGestureConfig.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>HammerGestureConfig.ctorParameters = function () { return []; };</p><p>var HammerGesturesPlugin = (function (_super) {</p><p>    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](HammerGesturesPlugin, _super);</p><p>    /**</p><p>     * @param {?} doc</p><p>     * @param {?} _config</p><p>     */</p><p>    function HammerGesturesPlugin(doc, _config) {</p><p>        var _this = _super.call(this, doc) || this;</p><p>        _this._config = _config;</p><p>        return _this;</p><p>    }</p><p>    /**</p><p>     * @param {?} eventName</p><p>     * @return {?}</p><p>     */</p><p>    HammerGesturesPlugin.prototype.supports = function (eventName) {</p><p>        if (!EVENT_NAMES.hasOwnProperty(eventName.toLowerCase()) && !this.isCustomEvent(eventName)) {</p><p>            return false;</p><p>        }</p><p>        if (!((window)).Hammer) {</p><p>            throw new Error("Hammer.js is not loaded, can not bind " + eventName + " event");</p><p>        }</p><p>        return true;</p><p>    };</p><p>    /**</p><p>     * @param {?} element</p><p>     * @param {?} eventName</p><p>     * @param {?} handler</p><p>     * @return {?}</p><p>     */</p><p>    HammerGesturesPlugin.prototype.addEventListener = function (element, eventName, handler) {</p><p>        var _this = this;</p><p>        var /** @type {?} */ zone = this.manager.getZone();</p><p>        eventName = eventName.toLowerCase();</p><p>        return zone.runOutsideAngular(function () {</p><p>            // Creating the manager bind events, must be done outside of angular</p><p>            var /** @type {?} */ mc = _this._config.buildHammer(element);</p><p>            var /** @type {?} */ callback = function (eventObj) {</p><p>                zone.runGuarded(function () { handler(eventObj); });</p><p>            };</p><p>            mc.on(eventName, callback);</p><p>            return function () { return mc.off(eventName, callback); };</p><p>        });</p><p>    };</p><p>    /**</p><p>     * @param {?} eventName</p><p>     * @return {?}</p><p>     */</p><p>    HammerGesturesPlugin.prototype.isCustomEvent = function (eventName) { return this._config.events.indexOf(eventName) > -1; };</p><p>    return HammerGesturesPlugin;</p><p>}(EventManagerPlugin));</p><p>HammerGesturesPlugin.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>HammerGesturesPlugin.ctorParameters = function () { return [</p><p>    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Inject"], args: [DOCUMENT$1,] },] },</p><p>    { type: HammerGestureConfig, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Inject"], args: [HAMMER_GESTURE_CONFIG,] },] },</p><p>]; };</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>var MODIFIER_KEYS = ['alt', 'control', 'meta', 'shift'];</p><p>var MODIFIER_KEY_GETTERS = {</p><p>    'alt': function (event) { return event.altKey; },</p><p>    'control': function (event) { return event.ctrlKey; },</p><p>    'meta': function (event) { return event.metaKey; },</p><p>    'shift': function (event) { return event.shiftKey; }</p><p>};</p><p>/**</p><p> * \@experimental</p><p> */</p><p>var KeyEventsPlugin = (function (_super) {</p><p>    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](KeyEventsPlugin, _super);</p><p>    /**</p><p>     * @param {?} doc</p><p>     */</p><p>    function KeyEventsPlugin(doc) {</p><p>        return _super.call(this, doc) || this;</p><p>    }</p><p>    /**</p><p>     * @param {?} eventName</p><p>     * @return {?}</p><p>     */</p><p>    KeyEventsPlugin.prototype.supports = function (eventName) { return KeyEventsPlugin.parseEventName(eventName) != null; };</p><p>    /**</p><p>     * @param {?} element</p><p>     * @param {?} eventName</p><p>     * @param {?} handler</p><p>     * @return {?}</p><p>     */</p><p>    KeyEventsPlugin.prototype.addEventListener = function (element, eventName, handler) {</p><p>        var /** @type {?} */ parsedEvent = ((KeyEventsPlugin.parseEventName(eventName)));</p><p>        var /** @type {?} */ outsideHandler = KeyEventsPlugin.eventCallback(parsedEvent['fullKey'], handler, this.manager.getZone());</p><p>        return this.manager.getZone().runOutsideAngular(function () {</p><p>            return getDOM().onAndCancel(element, parsedEvent['domEventName'], outsideHandler);</p><p>        });</p><p>    };</p><p>    /**</p><p>     * @param {?} eventName</p><p>     * @return {?}</p><p>     */</p><p>    KeyEventsPlugin.parseEventName = function (eventName) {</p><p>        var /** @type {?} */ parts = eventName.toLowerCase().split('.');</p><p>        var /** @type {?} */ domEventName = parts.shift();</p><p>        if ((parts.length === 0) || !(domEventName === 'keydown' || domEventName === 'keyup')) {</p><p>            return null;</p><p>        }</p><p>        var /** @type {?} */ key = KeyEventsPlugin._normalizeKey(/** @type {?} */ ((parts.pop())));</p><p>        var /** @type {?} */ fullKey = '';</p><p>        MODIFIER_KEYS.forEach(function (modifierName) {</p><p>            var /** @type {?} */ index = parts.indexOf(modifierName);</p><p>            if (index > -1) {</p><p>                parts.splice(index, 1);</p><p>                fullKey += modifierName + '.';</p><p>            }</p><p>        });</p><p>        fullKey += key;</p><p>        if (parts.length != 0 || key.length === 0) {</p><p>            // returning null instead of throwing to let another plugin process the event</p><p>            return null;</p><p>        }</p><p>        var /** @type {?} */ result = {};</p><p>        result['domEventName'] = domEventName;</p><p>        result['fullKey'] = fullKey;</p><p>        return result;</p><p>    };</p><p>    /**</p><p>     * @param {?} event</p><p>     * @return {?}</p><p>     */</p><p>    KeyEventsPlugin.getEventFullKey = function (event) {</p><p>        var /** @type {?} */ fullKey = '';</p><p>        var /** @type {?} */ key = getDOM().getEventKey(event);</p><p>        key = key.toLowerCase();</p><p>        if (key === ' ') {</p><p>            key = 'space'; // for readability</p><p>        }</p><p>        else if (key === '.') {</p><p>            key = 'dot'; // because '.' is used as a separator in event names</p><p>        }</p><p>        MODIFIER_KEYS.forEach(function (modifierName) {</p><p>            if (modifierName != key) {</p><p>                var /** @type {?} */ modifierGetter = MODIFIER_KEY_GETTERS[modifierName];</p><p>                if (modifierGetter(event)) {</p><p>                    fullKey += modifierName + '.';</p><p>                }</p><p>            }</p><p>        });</p><p>        fullKey += key;</p><p>        return fullKey;</p><p>    };</p><p>    /**</p><p>     * @param {?} fullKey</p><p>     * @param {?} handler</p><p>     * @param {?} zone</p><p>     * @return {?}</p><p>     */</p><p>    KeyEventsPlugin.eventCallback = function (fullKey, handler, zone) {</p><p>        return function (event /** TODO #9100 */) {</p><p>            if (KeyEventsPlugin.getEventFullKey(event) === fullKey) {</p><p>                zone.runGuarded(function () { return handler(event); });</p><p>            }</p><p>        };</p><p>    };</p><p>    /**</p><p>     * \@internal</p><p>     * @param {?} keyName</p><p>     * @return {?}</p><p>     */</p><p>    KeyEventsPlugin._normalizeKey = function (keyName) {</p><p>        // TODO: switch to a Map if the mapping grows too much</p><p>        switch (keyName) {</p><p>            case 'esc':</p><p>                return 'escape';</p><p>            default:</p><p>                return keyName;</p><p>        }</p><p>    };</p><p>    return KeyEventsPlugin;</p><p>}(EventManagerPlugin));</p><p>KeyEventsPlugin.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>KeyEventsPlugin.ctorParameters = function () { return [</p><p>    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Inject"], args: [DOCUMENT$1,] },] },</p><p>]; };</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * A pattern that recognizes a commonly useful subset of URLs that are safe.</p><p> *</p><p> * This regular expression matches a subset of URLs that will not cause script</p><p> * execution if used in URL context within a HTML document. Specifically, this</p><p> * regular expression matches if (comment from here on and regex copied from</p><p> * Soy's EscapingConventions):</p><p> * (1) Either a protocol in a whitelist (http, https, mailto or ftp).</p><p> * (2) or no protocol.  A protocol must be followed by a colon. The below</p><p> *     allows that by allowing colons only after one of the characters [/?#].</p><p> *     A colon after a hash (#) must be in the fragment.</p><p> *     Otherwise, a colon after a (?) must be in a query.</p><p> *     Otherwise, a colon after a single solidus (/) must be in a path.</p><p> *     Otherwise, a colon after a double solidus (//) must be in the authority</p><p> *     (before port).</p><p> *</p><p> * The pattern disallows &, used in HTML entity declarations before</p><p> * one of the characters in [/?#]. This disallows HTML entities used in the</p><p> * protocol name, which should never happen, e.g. "h&#116;tp" for "http".</p><p> * It also disallows HTML entities in the first path part of a relative path,</p><p> * e.g. "foo&lt;bar/baz".  Our existing escaping functions should not produce</p><p> * that. More importantly, it disallows masking of a colon,</p><p> * e.g. "javascript&#58;...".</p><p> *</p><p> * This regular expression was taken from the Closure sanitization library.</p><p> */</p><p>var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi;</p><p>/**</p><p> * A pattern that matches safe data URLs. Only matches image, video and audio types.</p><p> */</p><p>var DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i;</p><p>/**</p><p> * @param {?} url</p><p> * @return {?}</p><p> */</p><p>function sanitizeUrl(url) {</p><p>    url = String(url);</p><p>    if (url.match(SAFE_URL_PATTERN) || url.match(DATA_URL_PATTERN))</p><p>        return url;</p><p>    if (Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["isDevMode"])()) {</p><p>        getDOM().log("WARNING: sanitizing unsafe URL value " + url + " (see http://g.co/ng/security#xss)");</p><p>    }</p><p>    return 'unsafe:' + url;</p><p>}</p><p>/**</p><p> * @param {?} srcset</p><p> * @return {?}</p><p> */</p><p>function sanitizeSrcset(srcset) {</p><p>    srcset = String(srcset);</p><p>    return srcset.split(',').map(function (srcset) { return sanitizeUrl(srcset.trim()); }).join(', ');</p><p>}</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * A <body> element that can be safely used to parse untrusted HTML. Lazily initialized below.</p><p> */</p><p>var inertElement = null;</p><p>/**</p><p> * Lazily initialized to make sure the DOM adapter gets set before use.</p><p> */</p><p>var DOM = null;</p><p>/**</p><p> * Returns an HTML element that is guaranteed to not execute code when creating elements in it.</p><p> * @return {?}</p><p> */</p><p>function getInertElement() {</p><p>    if (inertElement)</p><p>        return inertElement;</p><p>    DOM = getDOM();</p><p>    // Prefer using <template> element if supported.</p><p>    var /** @type {?} */ templateEl = DOM.createElement('template');</p><p>    if ('content' in templateEl)</p><p>        return templateEl;</p><p>    var /** @type {?} */ doc = DOM.createHtmlDocument();</p><p>    inertElement = DOM.querySelector(doc, 'body');</p><p>    if (inertElement == null) {</p><p>        // usually there should be only one body element in the document, but IE doesn't have any, so we</p><p>        // need to create one.</p><p>        var /** @type {?} */ html = DOM.createElement('html', doc);</p><p>        inertElement = DOM.createElement('body', doc);</p><p>        DOM.appendChild(html, inertElement);</p><p>        DOM.appendChild(doc, html);</p><p>    }</p><p>    return inertElement;</p><p>}</p><p>/**</p><p> * @param {?} tags</p><p> * @return {?}</p><p> */</p><p>function tagSet(tags) {</p><p>    var /** @type {?} */ res = {};</p><p>    for (var _i = 0, _a = tags.split(','); _i < _a.length; _i++) {</p><p>        var t = _a[_i];</p><p>        res[t] = true;</p><p>    }</p><p>    return res;</p><p>}</p><p>/**</p><p> * @param {...?} sets</p><p> * @return {?}</p><p> */</p><p>function merge() {</p><p>    var sets = [];</p><p>    for (var _i = 0; _i < arguments.length; _i++) {</p><p>        sets[_i] = arguments[_i];</p><p>    }</p><p>    var /** @type {?} */ res = {};</p><p>    for (var _a = 0, sets_1 = sets; _a < sets_1.length; _a++) {</p><p>        var s = sets_1[_a];</p><p>        for (var /** @type {?} */ v in s) {</p><p>            if (s.hasOwnProperty(v))</p><p>                res[v] = true;</p><p>        }</p><p>    }</p><p>    return res;</p><p>}</p><p>// Good source of info about elements and attributes</p><p>// http://dev.w3.org/html5/spec/Overview.html#semantics</p><p>// http://simon.html5.org/html-elements</p><p>// Safe Void Elements - HTML5</p><p>// http://dev.w3.org/html5/spec/Overview.html#void-elements</p><p>var VOID_ELEMENTS = tagSet('area,br,col,hr,img,wbr');</p><p>// Elements that you can, intentionally, leave open (and which close themselves)</p><p>// http://dev.w3.org/html5/spec/Overview.html#optional-tags</p><p>var OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr');</p><p>var OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet('rp,rt');</p><p>var OPTIONAL_END_TAG_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS);</p><p>// Safe Block Elements - HTML5</p><p>var BLOCK_ELEMENTS = merge(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet('address,article,' +</p><p>    'aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,' +</p><p>    'h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul'));</p><p>// Inline Elements - HTML5</p><p>var INLINE_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet('a,abbr,acronym,audio,b,' +</p><p>    'bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,' +</p><p>    'samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video'));</p><p>var VALID_ELEMENTS = merge(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS);</p><p>// Attributes that have href and hence need to be sanitized</p><p>var URI_ATTRS = tagSet('background,cite,href,itemtype,longdesc,poster,src,xlink:href');</p><p>// Attributes that have special href set hence need to be sanitized</p><p>var SRCSET_ATTRS = tagSet('srcset');</p><p>var HTML_ATTRS = tagSet('abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,' +</p><p>    'compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,' +</p><p>    'ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,' +</p><p>    'scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,' +</p><p>    'valign,value,vspace,width');</p><p>// NB: This currently consciously doesn't support SVG. SVG sanitization has had several security</p><p>// issues in the past, so it seems safer to leave it out if possible. If support for binding SVG via</p><p>// innerHTML is required, SVG attributes should be added here.</p><p>// NB: Sanitization does not allow <form> elements or other active elements (<button> etc). Those</p><p>// can be sanitized, but they increase security surface area without a legitimate use case, so they</p><p>// are left out here.</p><p>var VALID_ATTRS = merge(URI_ATTRS, SRCSET_ATTRS, HTML_ATTRS);</p><p>/**</p><p> * SanitizingHtmlSerializer serializes a DOM fragment, stripping out any unsafe elements and unsafe</p><p> * attributes.</p><p> */</p><p>var SanitizingHtmlSerializer = (function () {</p><p>    function SanitizingHtmlSerializer() {</p><p>        this.sanitizedSomething = false;</p><p>        this.buf = [];</p><p>    }</p><p>    /**</p><p>     * @param {?} el</p><p>     * @return {?}</p><p>     */</p><p>    SanitizingHtmlSerializer.prototype.sanitizeChildren = function (el) {</p><p>        // This cannot use a TreeWalker, as it has to run on Angular's various DOM adapters.</p><p>        // However this code never accesses properties off of `document` before deleting its contents</p><p>        // again, so it shouldn't be vulnerable to DOM clobbering.</p><p>        var /** @type {?} */ current = ((el.firstChild));</p><p>        while (current) {</p><p>            if (DOM.isElementNode(current)) {</p><p>                this.startElement(/** @type {?} */ (current));</p><p>            }</p><p>            else if (DOM.isTextNode(current)) {</p><p>                this.chars(/** @type {?} */ ((DOM.nodeValue(current))));</p><p>            }</p><p>            else {</p><p>                // Strip non-element, non-text nodes.</p><p>                this.sanitizedSomething = true;</p><p>            }</p><p>            if (DOM.firstChild(current)) {</p><p>                current = ((DOM.firstChild(current)));</p><p>                continue;</p><p>            }</p><p>            while (current) {</p><p>                // Leaving the element. Walk up and to the right, closing tags as we go.</p><p>                if (DOM.isElementNode(current)) {</p><p>                    this.endElement(/** @type {?} */ (current));</p><p>                }</p><p>                var /** @type {?} */ next = checkClobberedElement(current, /** @type {?} */ ((DOM.nextSibling(current))));</p><p>                if (next) {</p><p>                    current = next;</p><p>                    break;</p><p>                }</p><p>                current = checkClobberedElement(current, /** @type {?} */ ((DOM.parentElement(current))));</p><p>            }</p><p>        }</p><p>        return this.buf.join('');</p><p>    };</p><p>    /**</p><p>     * @param {?} element</p><p>     * @return {?}</p><p>     */</p><p>    SanitizingHtmlSerializer.prototype.startElement = function (element) {</p><p>        var _this = this;</p><p>        var /** @type {?} */ tagName = DOM.nodeName(element).toLowerCase();</p><p>        if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {</p><p>            this.sanitizedSomething = true;</p><p>            return;</p><p>        }</p><p>        this.buf.push('<');</p><p>        this.buf.push(tagName);</p><p>        DOM.attributeMap(element).forEach(function (value, attrName) {</p><p>            var /** @type {?} */ lower = attrName.toLowerCase();</p><p>            if (!VALID_ATTRS.hasOwnProperty(lower)) {</p><p>                _this.sanitizedSomething = true;</p><p>                return;</p><p>            }</p><p>            // TODO(martinprobst): Special case image URIs for data:image/...</p><p>            if (URI_ATTRS[lower])</p><p>                value = sanitizeUrl(value);</p><p>            if (SRCSET_ATTRS[lower])</p><p>                value = sanitizeSrcset(value);</p><p>            _this.buf.push(' ');</p><p>            _this.buf.push(attrName);</p><p>            _this.buf.push('="');</p><p>            _this.buf.push(encodeEntities(value));</p><p>            _this.buf.push('"');</p><p>        });</p><p>        this.buf.push('>');</p><p>    };</p><p>    /**</p><p>     * @param {?} current</p><p>     * @return {?}</p><p>     */</p><p>    SanitizingHtmlSerializer.prototype.endElement = function (current) {</p><p>        var /** @type {?} */ tagName = DOM.nodeName(current).toLowerCase();</p><p>        if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {</p><p>            this.buf.push('</');</p><p>            this.buf.push(tagName);</p><p>            this.buf.push('>');</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @param {?} chars</p><p>     * @return {?}</p><p>     */</p><p>    SanitizingHtmlSerializer.prototype.chars = function (chars) { this.buf.push(encodeEntities(chars)); };</p><p>    return SanitizingHtmlSerializer;</p><p>}());</p><p>/**</p><p> * @param {?} node</p><p> * @param {?} nextNode</p><p> * @return {?}</p><p> */</p><p>function checkClobberedElement(node, nextNode) {</p><p>    if (nextNode && DOM.contains(node, nextNode)) {</p><p>        throw new Error("Failed to sanitize html because the element is clobbered: " + DOM.getOuterHTML(node));</p><p>    }</p><p>    return nextNode;</p><p>}</p><p>// Regular Expressions for parsing tags and attributes</p><p>var SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;</p><p>// ! to ~ is the ASCII range.</p><p>var NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;</p><p>/**</p><p> * Escapes all potentially dangerous characters, so that the</p><p> * resulting string can be safely inserted into attribute or</p><p> * element text.</p><p> * @param {?} value</p><p> * @return {?}</p><p> */</p><p>function encodeEntities(value) {</p><p>    return value.replace(/&/g, '&amp;')</p><p>        .replace(SURROGATE_PAIR_REGEXP, function (match) {</p><p>        var /** @type {?} */ hi = match.charCodeAt(0);</p><p>        var /** @type {?} */ low = match.charCodeAt(1);</p><p>        return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';</p><p>    })</p><p>        .replace(NON_ALPHANUMERIC_REGEXP, function (match) { return '&#' + match.charCodeAt(0) + ';'; })</p><p>        .replace(/</g, '&lt;')</p><p>        .replace(/>/g, '&gt;');</p><p>}</p><p>/**</p><p> * When IE9-11 comes across an unknown namespaced attribute e.g. 'xlink:foo' it adds 'xmlns:ns1'</p><p> * attribute to declare ns1 namespace and prefixes the attribute with 'ns1' (e.g. 'ns1:xlink:foo').</p><p> *</p><p> * This is undesirable since we don't want to allow any of these custom attributes. This method</p><p> * strips them all.</p><p> * @param {?} el</p><p> * @return {?}</p><p> */</p><p>function stripCustomNsAttrs(el) {</p><p>    DOM.attributeMap(el).forEach(function (_, attrName) {</p><p>        if (attrName === 'xmlns:ns1' || attrName.indexOf('ns1:') === 0) {</p><p>            DOM.removeAttribute(el, attrName);</p><p>        }</p><p>    });</p><p>    for (var _i = 0, _a = DOM.childNodesAsList(el); _i < _a.length; _i++) {</p><p>        var n = _a[_i];</p><p>        if (DOM.isElementNode(n))</p><p>            stripCustomNsAttrs(/** @type {?} */ (n));</p><p>    }</p><p>}</p><p>/**</p><p> * Sanitizes the given unsafe, untrusted HTML fragment, and returns HTML text that is safe to add to</p><p> * the DOM in a browser environment.</p><p> * @param {?} defaultDoc</p><p> * @param {?} unsafeHtmlInput</p><p> * @return {?}</p><p> */</p><p>function sanitizeHtml(defaultDoc, unsafeHtmlInput) {</p><p>    try {</p><p>        var /** @type {?} */ containerEl = getInertElement();</p><p>        // Make sure unsafeHtml is actually a string (TypeScript types are not enforced at runtime).</p><p>        var /** @type {?} */ unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : '';</p><p>        // mXSS protection. Repeatedly parse the document to make sure it stabilizes, so that a browser</p><p>        // trying to auto-correct incorrect HTML cannot cause formerly inert HTML to become dangerous.</p><p>        var /** @type {?} */ mXSSAttempts = 5;</p><p>        var /** @type {?} */ parsedHtml = unsafeHtml;</p><p>        do {</p><p>            if (mXSSAttempts === 0) {</p><p>                throw new Error('Failed to sanitize html because the input is unstable');</p><p>            }</p><p>            mXSSAttempts--;</p><p>            unsafeHtml = parsedHtml;</p><p>            DOM.setInnerHTML(containerEl, unsafeHtml);</p><p>            if (defaultDoc.documentMode) {</p><p>                // strip custom-namespaced attributes on IE<=11</p><p>                stripCustomNsAttrs(containerEl);</p><p>            }</p><p>            parsedHtml = DOM.getInnerHTML(containerEl);</p><p>        } while (unsafeHtml !== parsedHtml);</p><p>        var /** @type {?} */ sanitizer = new SanitizingHtmlSerializer();</p><p>        var /** @type {?} */ safeHtml = sanitizer.sanitizeChildren(DOM.getTemplateContent(containerEl) || containerEl);</p><p>        // Clear out the body element.</p><p>        var /** @type {?} */ parent = DOM.getTemplateContent(containerEl) || containerEl;</p><p>        for (var _i = 0, _a = DOM.childNodesAsList(parent); _i < _a.length; _i++) {</p><p>            var child = _a[_i];</p><p>            DOM.removeChild(parent, child);</p><p>        }</p><p>        if (Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["isDevMode"])() && sanitizer.sanitizedSomething) {</p><p>            DOM.log('WARNING: sanitizing HTML stripped some content (see http://g.co/ng/security#xss).');</p><p>        }</p><p>        return safeHtml;</p><p>    }</p><p>    catch (e) {</p><p>        // In case anything goes wrong, clear out inertElement to reset the entire DOM structure.</p><p>        inertElement = null;</p><p>        throw e;</p><p>    }</p><p>}</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * Regular expression for safe style values.</p><p> *</p><p> * Quotes (" and ') are allowed, but a check must be done elsewhere to ensure they're balanced.</p><p> *</p><p> * ',' allows multiple values to be assigned to the same property (e.g. background-attachment or</p><p> * font-family) and hence could allow multiple values to get injected, but that should pose no risk</p><p> * of XSS.</p><p> *</p><p> * The function expression checks only for XSS safety, not for CSS validity.</p><p> *</p><p> * This regular expression was taken from the Closure sanitization library, and augmented for</p><p> * transformation values.</p><p> */</p><p>var VALUES = '[-,."\'%_!# a-zA-Z0-9]+';</p><p>var TRANSFORMATION_FNS = '(?:matrix|translate|scale|rotate|skew|perspective)(?:X|Y|3d)?';</p><p>var COLOR_FNS = '(?:rgb|hsl)a?';</p><p>var GRADIENTS = '(?:repeating-)?(?:linear|radial)-gradient';</p><p>var CSS3_FNS = '(?:calc|attr)';</p><p>var FN_ARGS = '\\([-0-9.%, #a-zA-Z]+\\)';</p><p>var SAFE_STYLE_VALUE = new RegExp("^(" + VALUES + "|" +</p><p>    ("(?:" + TRANSFORMATION_FNS + "|" + COLOR_FNS + "|" + GRADIENTS + "|" + CSS3_FNS + ")") +</p><p>    (FN_ARGS + ")$"), 'g');</p><p>/**</p><p> * Matches a `url(...)` value with an arbitrary argument as long as it does</p><p> * not contain parentheses.</p><p> *</p><p> * The URL value still needs to be sanitized separately.</p><p> *</p><p> * `url(...)` values are a very common use case, e.g. for `background-image`. With carefully crafted</p><p> * CSS style rules, it is possible to construct an information leak with `url` values in CSS, e.g.</p><p> * by observing whether scroll bars are displayed, or character ranges used by a font face</p><p> * definition.</p><p> *</p><p> * Angular only allows binding CSS values (as opposed to entire CSS rules), so it is unlikely that</p><p> * binding a URL value without further cooperation from the page will cause an information leak, and</p><p> * if so, it is just a leak, not a full blown XSS vulnerability.</p><p> *</p><p> * Given the common use case, low likelihood of attack vector, and low impact of an attack, this</p><p> * code is permissive and allows URLs that sanitize otherwise.</p><p> */</p><p>var URL_RE = /^url\(([^)]+)\)$/;</p><p>/**</p><p> * Checks that quotes (" and ') are properly balanced inside a string. Assumes</p><p> * that neither escape (\) nor any other character that could result in</p><p> * breaking out of a string parsing context are allowed;</p><p> * see http://www.w3.org/TR/css3-syntax/#string-token-diagram.</p><p> *</p><p> * This code was taken from the Closure sanitization library.</p><p> * @param {?} value</p><p> * @return {?}</p><p> */</p><p>function hasBalancedQuotes(value) {</p><p>    var /** @type {?} */ outsideSingle = true;</p><p>    var /** @type {?} */ outsideDouble = true;</p><p>    for (var /** @type {?} */ i = 0; i < value.length; i++) {</p><p>        var /** @type {?} */ c = value.charAt(i);</p><p>        if (c === '\'' && outsideDouble) {</p><p>            outsideSingle = !outsideSingle;</p><p>        }</p><p>        else if (c === '"' && outsideSingle) {</p><p>            outsideDouble = !outsideDouble;</p><p>        }</p><p>    }</p><p>    return outsideSingle && outsideDouble;</p><p>}</p><p>/**</p><p> * Sanitizes the given untrusted CSS style property value (i.e. not an entire object, just a single</p><p> * value) and returns a value that is safe to use in a browser environment.</p><p> * @param {?} value</p><p> * @return {?}</p><p> */</p><p>function sanitizeStyle(value) {</p><p>    value = String(value).trim(); // Make sure it's actually a string.</p><p>    if (!value)</p><p>        return '';</p><p>    // Single url(...) values are supported, but only for URLs that sanitize cleanly. See above for</p><p>    // reasoning behind this.</p><p>    var /** @type {?} */ urlMatch = value.match(URL_RE);</p><p>    if ((urlMatch && sanitizeUrl(urlMatch[1]) === urlMatch[1]) ||</p><p>        value.match(SAFE_STYLE_VALUE) && hasBalancedQuotes(value)) {</p><p>        return value; // Safe style values.</p><p>    }</p><p>    if (Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["isDevMode"])()) {</p><p>        getDOM().log("WARNING: sanitizing unsafe style value " + value + " (see http://g.co/ng/security#xss).");</p><p>    }</p><p>    return 'unsafe';</p><p>}</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * DomSanitizer helps preventing Cross Site Scripting Security bugs (XSS) by sanitizing</p><p> * values to be safe to use in the different DOM contexts.</p><p> *</p><p> * For example, when binding a URL in an `<a [href]="someValue">` hyperlink, `someValue` will be</p><p> * sanitized so that an attacker cannot inject e.g. a `javascript:` URL that would execute code on</p><p> * the website.</p><p> *</p><p> * In specific situations, it might be necessary to disable sanitization, for example if the</p><p> * application genuinely needs to produce a `javascript:` style link with a dynamic value in it.</p><p> * Users can bypass security by constructing a value with one of the `bypassSecurityTrust...`</p><p> * methods, and then binding to that value from the template.</p><p> *</p><p> * These situations should be very rare, and extraordinary care must be taken to avoid creating a</p><p> * Cross Site Scripting (XSS) security bug!</p><p> *</p><p> * When using `bypassSecurityTrust...`, make sure to call the method as early as possible and as</p><p> * close as possible to the source of the value, to make it easy to verify no security bug is</p><p> * created by its use.</p><p> *</p><p> * It is not required (and not recommended) to bypass security if the value is safe, e.g. a URL that</p><p> * does not start with a suspicious protocol, or an HTML snippet that does not contain dangerous</p><p> * code. The sanitizer leaves safe values intact.</p><p> *</p><p> * \@security Calling any of the `bypassSecurityTrust...` APIs disables Angular's built-in</p><p> * sanitization for the value passed in. Carefully check and audit all values and code paths going</p><p> * into this call. Make sure any user data is appropriately escaped for this security context.</p><p> * For more detail, see the [Security Guide](http://g.co/ng/security).</p><p> *</p><p> * \@stable</p><p> * @abstract</p><p> */</p><p>var DomSanitizer = (function () {</p><p>    function DomSanitizer() {</p><p>    }</p><p>    /**</p><p>     * Sanitizes a value for use in the given SecurityContext.</p><p>     *</p><p>     * If value is trusted for the context, this method will unwrap the contained safe value and use</p><p>     * it directly. Otherwise, value will be sanitized to be safe in the given context, for example</p><p>     * by replacing URLs that have an unsafe protocol part (such as `javascript:`). The implementation</p><p>     * is responsible to make sure that the value can definitely be safely used in the given context.</p><p>     * @abstract</p><p>     * @param {?} context</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    DomSanitizer.prototype.sanitize = function (context, value) { };</p><p>    /**</p><p>     * Bypass security and trust the given value to be safe HTML. Only use this when the bound HTML</p><p>     * is unsafe (e.g. contains `<script>` tags) and the code should be executed. The sanitizer will</p><p>     * leave safe HTML intact, so in most situations this method should not be used.</p><p>     *</p><p>     * **WARNING:** calling this method with untrusted user data exposes your application to XSS</p><p>     * security risks!</p><p>     * @abstract</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    DomSanitizer.prototype.bypassSecurityTrustHtml = function (value) { };</p><p>    /**</p><p>     * Bypass security and trust the given value to be safe style value (CSS).</p><p>     *</p><p>     * **WARNING:** calling this method with untrusted user data exposes your application to XSS</p><p>     * security risks!</p><p>     * @abstract</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    DomSanitizer.prototype.bypassSecurityTrustStyle = function (value) { };</p><p>    /**</p><p>     * Bypass security and trust the given value to be safe JavaScript.</p><p>     *</p><p>     * **WARNING:** calling this method with untrusted user data exposes your application to XSS</p><p>     * security risks!</p><p>     * @abstract</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    DomSanitizer.prototype.bypassSecurityTrustScript = function (value) { };</p><p>    /**</p><p>     * Bypass security and trust the given value to be a safe style URL, i.e. a value that can be used</p><p>     * in hyperlinks or `<img src>`.</p><p>     *</p><p>     * **WARNING:** calling this method with untrusted user data exposes your application to XSS</p><p>     * security risks!</p><p>     * @abstract</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    DomSanitizer.prototype.bypassSecurityTrustUrl = function (value) { };</p><p>    /**</p><p>     * Bypass security and trust the given value to be a safe resource URL, i.e. a location that may</p><p>     * be used to load executable code from, like `<script src>`, or `<iframe src>`.</p><p>     *</p><p>     * **WARNING:** calling this method with untrusted user data exposes your application to XSS</p><p>     * security risks!</p><p>     * @abstract</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    DomSanitizer.prototype.bypassSecurityTrustResourceUrl = function (value) { };</p><p>    return DomSanitizer;</p><p>}());</p><p>var DomSanitizerImpl = (function (_super) {</p><p>    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](DomSanitizerImpl, _super);</p><p>    /**</p><p>     * @param {?} _doc</p><p>     */</p><p>    function DomSanitizerImpl(_doc) {</p><p>        var _this = _super.call(this) || this;</p><p>        _this._doc = _doc;</p><p>        return _this;</p><p>    }</p><p>    /**</p><p>     * @param {?} ctx</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    DomSanitizerImpl.prototype.sanitize = function (ctx, value) {</p><p>        if (value == null)</p><p>            return null;</p><p>        switch (ctx) {</p><p>            case __WEBPACK_IMPORTED_MODULE_2__angular_core__["SecurityContext"].NONE:</p><p>                return (value);</p><p>            case __WEBPACK_IMPORTED_MODULE_2__angular_core__["SecurityContext"].HTML:</p><p>                if (value instanceof SafeHtmlImpl)</p><p>                    return value.changingThisBreaksApplicationSecurity;</p><p>                this.checkNotSafeValue(value, 'HTML');</p><p>                return sanitizeHtml(this._doc, String(value));</p><p>            case __WEBPACK_IMPORTED_MODULE_2__angular_core__["SecurityContext"].STYLE:</p><p>                if (value instanceof SafeStyleImpl)</p><p>                    return value.changingThisBreaksApplicationSecurity;</p><p>                this.checkNotSafeValue(value, 'Style');</p><p>                return sanitizeStyle(/** @type {?} */ (value));</p><p>            case __WEBPACK_IMPORTED_MODULE_2__angular_core__["SecurityContext"].SCRIPT:</p><p>                if (value instanceof SafeScriptImpl)</p><p>                    return value.changingThisBreaksApplicationSecurity;</p><p>                this.checkNotSafeValue(value, 'Script');</p><p>                throw new Error('unsafe value used in a script context');</p><p>            case __WEBPACK_IMPORTED_MODULE_2__angular_core__["SecurityContext"].URL:</p><p>                if (value instanceof SafeResourceUrlImpl || value instanceof SafeUrlImpl) {</p><p>                    // Allow resource URLs in URL contexts, they are strictly more trusted.</p><p>                    return value.changingThisBreaksApplicationSecurity;</p><p>                }</p><p>                this.checkNotSafeValue(value, 'URL');</p><p>                return sanitizeUrl(String(value));</p><p>            case __WEBPACK_IMPORTED_MODULE_2__angular_core__["SecurityContext"].RESOURCE_URL:</p><p>                if (value instanceof SafeResourceUrlImpl) {</p><p>                    return value.changingThisBreaksApplicationSecurity;</p><p>                }</p><p>                this.checkNotSafeValue(value, 'ResourceURL');</p><p>                throw new Error('unsafe value used in a resource URL context (see http://g.co/ng/security#xss)');</p><p>            default:</p><p>                throw new Error("Unexpected SecurityContext " + ctx + " (see http://g.co/ng/security#xss)");</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @param {?} value</p><p>     * @param {?} expectedType</p><p>     * @return {?}</p><p>     */</p><p>    DomSanitizerImpl.prototype.checkNotSafeValue = function (value, expectedType) {</p><p>        if (value instanceof SafeValueImpl) {</p><p>            throw new Error("Required a safe " + expectedType + ", got a " + value.getTypeName() + " " +</p><p>                "(see http://g.co/ng/security#xss)");</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    DomSanitizerImpl.prototype.bypassSecurityTrustHtml = function (value) { return new SafeHtmlImpl(value); };</p><p>    /**</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    DomSanitizerImpl.prototype.bypassSecurityTrustStyle = function (value) { return new SafeStyleImpl(value); };</p><p>    /**</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    DomSanitizerImpl.prototype.bypassSecurityTrustScript = function (value) { return new SafeScriptImpl(value); };</p><p>    /**</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    DomSanitizerImpl.prototype.bypassSecurityTrustUrl = function (value) { return new SafeUrlImpl(value); };</p><p>    /**</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    DomSanitizerImpl.prototype.bypassSecurityTrustResourceUrl = function (value) {</p><p>        return new SafeResourceUrlImpl(value);</p><p>    };</p><p>    return DomSanitizerImpl;</p><p>}(DomSanitizer));</p><p>DomSanitizerImpl.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>DomSanitizerImpl.ctorParameters = function () { return [</p><p>    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Inject"], args: [DOCUMENT$1,] },] },</p><p>]; };</p><p>/**</p><p> * @abstract</p><p> */</p><p>var SafeValueImpl = (function () {</p><p>    /**</p><p>     * @param {?} changingThisBreaksApplicationSecurity</p><p>     */</p><p>    function SafeValueImpl(changingThisBreaksApplicationSecurity) {</p><p>        this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;</p><p>        // empty</p><p>    }</p><p>    /**</p><p>     * @abstract</p><p>     * @return {?}</p><p>     */</p><p>    SafeValueImpl.prototype.getTypeName = function () { };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    SafeValueImpl.prototype.toString = function () {</p><p>        return "SafeValue must use [property]=binding: " + this.changingThisBreaksApplicationSecurity +</p><p>            " (see http://g.co/ng/security#xss)";</p><p>    };</p><p>    return SafeValueImpl;</p><p>}());</p><p>var SafeHtmlImpl = (function (_super) {</p><p>    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](SafeHtmlImpl, _super);</p><p>    function SafeHtmlImpl() {</p><p>        return _super !== null && _super.apply(this, arguments) || this;</p><p>    }</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    SafeHtmlImpl.prototype.getTypeName = function () { return 'HTML'; };</p><p>    return SafeHtmlImpl;</p><p>}(SafeValueImpl));</p><p>var SafeStyleImpl = (function (_super) {</p><p>    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](SafeStyleImpl, _super);</p><p>    function SafeStyleImpl() {</p><p>        return _super !== null && _super.apply(this, arguments) || this;</p><p>    }</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    SafeStyleImpl.prototype.getTypeName = function () { return 'Style'; };</p><p>    return SafeStyleImpl;</p><p>}(SafeValueImpl));</p><p>var SafeScriptImpl = (function (_super) {</p><p>    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](SafeScriptImpl, _super);</p><p>    function SafeScriptImpl() {</p><p>        return _super !== null && _super.apply(this, arguments) || this;</p><p>    }</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    SafeScriptImpl.prototype.getTypeName = function () { return 'Script'; };</p><p>    return SafeScriptImpl;</p><p>}(SafeValueImpl));</p><p>var SafeUrlImpl = (function (_super) {</p><p>    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](SafeUrlImpl, _super);</p><p>    function SafeUrlImpl() {</p><p>        return _super !== null && _super.apply(this, arguments) || this;</p><p>    }</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    SafeUrlImpl.prototype.getTypeName = function () { return 'URL'; };</p><p>    return SafeUrlImpl;</p><p>}(SafeValueImpl));</p><p>var SafeResourceUrlImpl = (function (_super) {</p><p>    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](SafeResourceUrlImpl, _super);</p><p>    function SafeResourceUrlImpl() {</p><p>        return _super !== null && _super.apply(this, arguments) || this;</p><p>    }</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    SafeResourceUrlImpl.prototype.getTypeName = function () { return 'ResourceURL'; };</p><p>    return SafeResourceUrlImpl;</p><p>}(SafeValueImpl));</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>var INTERNAL_BROWSER_PLATFORM_PROVIDERS = [</p><p>    { provide: __WEBPACK_IMPORTED_MODULE_2__angular_core__["PLATFORM_ID"], useValue: __WEBPACK_IMPORTED_MODULE_1__angular_common__["ɵPLATFORM_BROWSER_ID"] },</p><p>    { provide: __WEBPACK_IMPORTED_MODULE_2__angular_core__["PLATFORM_INITIALIZER"], useValue: initDomAdapter, multi: true },</p><p>    { provide: __WEBPACK_IMPORTED_MODULE_1__angular_common__["PlatformLocation"], useClass: BrowserPlatformLocation },</p><p>    { provide: DOCUMENT$1, useFactory: _document, deps: [] },</p><p>];</p><p>/**</p><p> * \@security Replacing built-in sanitization providers exposes the application to XSS risks.</p><p> * Attacker-controlled data introduced by an unsanitized provider could expose your</p><p> * application to XSS risks. For more detail, see the [Security Guide](http://g.co/ng/security).</p><p> * \@experimental</p><p> */</p><p>var BROWSER_SANITIZATION_PROVIDERS = [</p><p>    { provide: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Sanitizer"], useExisting: DomSanitizer },</p><p>    { provide: DomSanitizer, useClass: DomSanitizerImpl },</p><p>];</p><p>/**</p><p> * \@stable</p><p> */</p><p>var platformBrowser = Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["createPlatformFactory"])(__WEBPACK_IMPORTED_MODULE_2__angular_core__["platformCore"], 'browser', INTERNAL_BROWSER_PLATFORM_PROVIDERS);</p><p>/**</p><p> * @return {?}</p><p> */</p><p>function initDomAdapter() {</p><p>    BrowserDomAdapter.makeCurrent();</p><p>    BrowserGetTestability.init();</p><p>}</p><p>/**</p><p> * @return {?}</p><p> */</p><p>function errorHandler() {</p><p>    return new __WEBPACK_IMPORTED_MODULE_2__angular_core__["ErrorHandler"]();</p><p>}</p><p>/**</p><p> * @return {?}</p><p> */</p><p>function _document() {</p><p>    return document;</p><p>}</p><p>/**</p><p> * The ng module for the browser.</p><p> *</p><p> * \@stable</p><p> */</p><p>var BrowserModule = (function () {</p><p>    /**</p><p>     * @param {?} parentModule</p><p>     */</p><p>    function BrowserModule(parentModule) {</p><p>        if (parentModule) {</p><p>            throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.");</p><p>        }</p><p>    }</p><p>    /**</p><p>     * Configures a browser-based application to transition from a server-rendered app, if</p><p>     * one is present on the page. The specified parameters must include an application id,</p><p>     * which must match between the client and server applications.</p><p>     *</p><p>     * \@experimental</p><p>     * @param {?} params</p><p>     * @return {?}</p><p>     */</p><p>    BrowserModule.withServerTransition = function (params) {</p><p>        return {</p><p>            ngModule: BrowserModule,</p><p>            providers: [</p><p>                { provide: __WEBPACK_IMPORTED_MODULE_2__angular_core__["APP_ID"], useValue: params.appId },</p><p>                { provide: TRANSITION_ID, useExisting: __WEBPACK_IMPORTED_MODULE_2__angular_core__["APP_ID"] },</p><p>                SERVER_TRANSITION_PROVIDERS,</p><p>            ],</p><p>        };</p><p>    };</p><p>    return BrowserModule;</p><p>}());</p><p>BrowserModule.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["NgModule"], args: [{</p><p>                providers: [</p><p>                    BROWSER_SANITIZATION_PROVIDERS,</p><p>                    { provide: __WEBPACK_IMPORTED_MODULE_2__angular_core__["ErrorHandler"], useFactory: errorHandler, deps: [] },</p><p>                    { provide: EVENT_MANAGER_PLUGINS, useClass: DomEventsPlugin, multi: true },</p><p>                    { provide: EVENT_MANAGER_PLUGINS, useClass: KeyEventsPlugin, multi: true },</p><p>                    { provide: EVENT_MANAGER_PLUGINS, useClass: HammerGesturesPlugin, multi: true },</p><p>                    { provide: HAMMER_GESTURE_CONFIG, useClass: HammerGestureConfig },</p><p>                    DomRendererFactory2,</p><p>                    { provide: __WEBPACK_IMPORTED_MODULE_2__angular_core__["RendererFactory2"], useExisting: DomRendererFactory2 },</p><p>                    { provide: SharedStylesHost, useExisting: DomSharedStylesHost },</p><p>                    DomSharedStylesHost,</p><p>                    __WEBPACK_IMPORTED_MODULE_2__angular_core__["Testability"],</p><p>                    EventManager,</p><p>                    ELEMENT_PROBE_PROVIDERS,</p><p>                    Meta,</p><p>                    Title,</p><p>                ],</p><p>                exports: [__WEBPACK_IMPORTED_MODULE_1__angular_common__["CommonModule"], __WEBPACK_IMPORTED_MODULE_2__angular_core__["ApplicationModule"]]</p><p>            },] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>BrowserModule.ctorParameters = function () { return [</p><p>    { type: BrowserModule, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["SkipSelf"] },] },</p><p>]; };</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>var win = typeof window !== 'undefined' && window || {};</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>var ChangeDetectionPerfRecord = (function () {</p><p>    /**</p><p>     * @param {?} msPerTick</p><p>     * @param {?} numTicks</p><p>     */</p><p>    function ChangeDetectionPerfRecord(msPerTick, numTicks) {</p><p>        this.msPerTick = msPerTick;</p><p>        this.numTicks = numTicks;</p><p>    }</p><p>    return ChangeDetectionPerfRecord;</p><p>}());</p><p>/**</p><p> * Entry point for all Angular profiling-related debug tools. This object</p><p> * corresponds to the `ng.profiler` in the dev console.</p><p> */</p><p>var AngularProfiler = (function () {</p><p>    /**</p><p>     * @param {?} ref</p><p>     */</p><p>    function AngularProfiler(ref) {</p><p>        this.appRef = ref.injector.get(__WEBPACK_IMPORTED_MODULE_2__angular_core__["ApplicationRef"]);</p><p>    }</p><p>    /**</p><p>     * Exercises change detection in a loop and then prints the average amount of</p><p>     * time in milliseconds how long a single round of change detection takes for</p><p>     * the current state of the UI. It runs a minimum of 5 rounds for a minimum</p><p>     * of 500 milliseconds.</p><p>     *</p><p>     * Optionally, a user may pass a `config` parameter containing a map of</p><p>     * options. Supported options are:</p><p>     *</p><p>     * `record` (boolean) - causes the profiler to record a CPU profile while</p><p>     * it exercises the change detector. Example:</p><p>     *</p><p>     * ```</p><p>     * ng.profiler.timeChangeDetection({record: true})</p><p>     * ```</p><p>     * @param {?} config</p><p>     * @return {?}</p><p>     */</p><p>    AngularProfiler.prototype.timeChangeDetection = function (config) {</p><p>        var /** @type {?} */ record = config && config['record'];</p><p>        var /** @type {?} */ profileName = 'Change Detection';</p><p>        // Profiler is not available in Android browsers, nor in IE 9 without dev tools opened</p><p>        var /** @type {?} */ isProfilerAvailable = win.console.profile != null;</p><p>        if (record && isProfilerAvailable) {</p><p>            win.console.profile(profileName);</p><p>        }</p><p>        var /** @type {?} */ start = getDOM().performanceNow();</p><p>        var /** @type {?} */ numTicks = 0;</p><p>        while (numTicks < 5 || (getDOM().performanceNow() - start) < 500) {</p><p>            this.appRef.tick();</p><p>            numTicks++;</p><p>        }</p><p>        var /** @type {?} */ end = getDOM().performanceNow();</p><p>        if (record && isProfilerAvailable) {</p><p>            // need to cast to <any> because type checker thinks there's no argument</p><p>            // while in fact there is:</p><p>            //</p><p>            // https://developer.mozilla.org/en-US/docs/Web/API/Console/profileEnd</p><p>            ((win.console.profileEnd))(profileName);</p><p>        }</p><p>        var /** @type {?} */ msPerTick = (end - start) / numTicks;</p><p>        win.console.log("ran " + numTicks + " change detection cycles");</p><p>        win.console.log(msPerTick.toFixed(2) + " ms per check");</p><p>        return new ChangeDetectionPerfRecord(msPerTick, numTicks);</p><p>    };</p><p>    return AngularProfiler;</p><p>}());</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>var PROFILER_GLOBAL_NAME = 'profiler';</p><p>/**</p><p> * Enabled Angular debug tools that are accessible via your browser's</p><p> * developer console.</p><p> *</p><p> * Usage:</p><p> *</p><p> * 1. Open developer console (e.g. in Chrome Ctrl + Shift + j)</p><p> * 1. Type `ng.` (usually the console will show auto-complete suggestion)</p><p> * 1. Try the change detection profiler `ng.profiler.timeChangeDetection()`</p><p> *    then hit Enter.</p><p> *</p><p> * \@experimental All debugging apis are currently experimental.</p><p> * @template T</p><p> * @param {?} ref</p><p> * @return {?}</p><p> */</p><p>function enableDebugTools(ref) {</p><p>    exportNgVar(PROFILER_GLOBAL_NAME, new AngularProfiler(ref));</p><p>    return ref;</p><p>}</p><p>/**</p><p> * Disables Angular tools.</p><p> *</p><p> * \@experimental All debugging apis are currently experimental.</p><p> * @return {?}</p><p> */</p><p>function disableDebugTools() {</p><p>    exportNgVar(PROFILER_GLOBAL_NAME, null);</p><p>}</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * Predicates for use with {\@link DebugElement}'s query functions.</p><p> *</p><p> * \@experimental All debugging apis are currently experimental.</p><p> */</p><p>var By = (function () {</p><p>    function By() {</p><p>    }</p><p>    /**</p><p>     * Match all elements.</p><p>     *</p><p>     * ## Example</p><p>     *</p><p>     * {\@example platform-browser/dom/debug/ts/by/by.ts region='by_all'}</p><p>     * @return {?}</p><p>     */</p><p>    By.all = function () { return function (debugElement) { return true; }; };</p><p>    /**</p><p>     * Match elements by the given CSS selector.</p><p>     *</p><p>     * ## Example</p><p>     *</p><p>     * {\@example platform-browser/dom/debug/ts/by/by.ts region='by_css'}</p><p>     * @param {?} selector</p><p>     * @return {?}</p><p>     */</p><p>    By.css = function (selector) {</p><p>        return function (debugElement) {</p><p>            return debugElement.nativeElement != null ?</p><p>                getDOM().elementMatches(debugElement.nativeElement, selector) :</p><p>                false;</p><p>        };</p><p>    };</p><p>    /**</p><p>     * Match elements that have the given directive present.</p><p>     *</p><p>     * ## Example</p><p>     *</p><p>     * {\@example platform-browser/dom/debug/ts/by/by.ts region='by_directive'}</p><p>     * @param {?} type</p><p>     * @return {?}</p><p>     */</p><p>    By.directive = function (type) {</p><p>        return function (debugElement) { return ((debugElement.providerTokens)).indexOf(type) !== -1; };</p><p>    };</p><p>    return By;</p><p>}());</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * @module</p><p> * @description</p><p> * Entry point for all public APIs of the common package.</p><p> */</p><p>/**</p><p> * \@stable</p><p> */</p><p>var VERSION = new __WEBPACK_IMPORTED_MODULE_2__angular_core__["Version"]('4.3.5');</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * @module</p><p> * @description</p><p> * Entry point for all public APIs of the platform-browser package.</p><p> */</p><p>// This file only reexports content of the `src` folder. Keep it that way.</p><p>/**</p><p> * Generated bundle index. Do not edit.</p><p> */</p><p></p><p>//# sourceMappingURL=platform-browser.es5.js.map</p><p></p><p></p><p>/***/ }),</p><p></p><p>/***/ "../../../platform-browser/@angular/platform-browser/animations.es5.js":</p><p>/***/ (function(module, __webpack_exports__, __webpack_require__) {</p><p></p><p>"use strict";</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BrowserAnimationsModule; });</p><p>/* unused harmony export NoopAnimationsModule */</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return BrowserAnimationBuilder; });</p><p>/* unused harmony export ɵBrowserAnimationFactory */</p><p>/* unused harmony export ɵAnimationRenderer */</p><p>/* unused harmony export ɵAnimationRendererFactory */</p><p>/* unused harmony export ɵa */</p><p>/* unused harmony export ɵf */</p><p>/* unused harmony export ɵg */</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return InjectableAnimationEngine; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return instantiateDefaultStyleNormalizer; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return instantiateRendererFactory; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return instantiateSupportedAnimationDriver; });</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__("../../../../tslib/tslib.es6.js");</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__("../../../core/@angular/core.es5.js");</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_platform_browser__ = __webpack_require__("../../../platform-browser/@angular/platform-browser.es5.js");</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__angular_animations__ = __webpack_require__("../../../animations/@angular/animations.es5.js");</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__ = __webpack_require__("../../../animations/@angular/animations/browser.es5.js");</p><p></p><p>/**</p><p> * @license Angular v4.3.5</p><p> * (c) 2010-2017 Google, Inc. https://angular.io/</p><p> * License: MIT</p><p> */</p><p></p><p></p><p></p><p></p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>var BrowserAnimationBuilder = (function (_super) {</p><p>    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](BrowserAnimationBuilder, _super);</p><p>    /**</p><p>     * @param {?} rootRenderer</p><p>     */</p><p>    function BrowserAnimationBuilder(rootRenderer) {</p><p>        var _this = _super.call(this) || this;</p><p>        _this._nextAnimationId = 0;</p><p>        var typeData = {</p><p>            id: '0',</p><p>            encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewEncapsulation"].None,</p><p>            styles: [],</p><p>            data: { animation: [] }</p><p>        };</p><p>        _this._renderer = rootRenderer.createRenderer(document.body, typeData);</p><p>        return _this;</p><p>    }</p><p>    /**</p><p>     * @param {?} animation</p><p>     * @return {?}</p><p>     */</p><p>    BrowserAnimationBuilder.prototype.build = function (animation) {</p><p>        var /** @type {?} */ id = this._nextAnimationId.toString();</p><p>        this._nextAnimationId++;</p><p>        var /** @type {?} */ entry = Array.isArray(animation) ? Object(__WEBPACK_IMPORTED_MODULE_3__angular_animations__["sequence"])(animation) : animation;</p><p>        issueAnimationCommand(this._renderer, null, id, 'register', [entry]);</p><p>        return new BrowserAnimationFactory(id, this._renderer);</p><p>    };</p><p>    return BrowserAnimationBuilder;</p><p>}(__WEBPACK_IMPORTED_MODULE_3__angular_animations__["AnimationBuilder"]));</p><p>BrowserAnimationBuilder.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>BrowserAnimationBuilder.ctorParameters = function () { return [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["RendererFactory2"], },</p><p>]; };</p><p>var BrowserAnimationFactory = (function (_super) {</p><p>    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](BrowserAnimationFactory, _super);</p><p>    /**</p><p>     * @param {?} _id</p><p>     * @param {?} _renderer</p><p>     */</p><p>    function BrowserAnimationFactory(_id, _renderer) {</p><p>        var _this = _super.call(this) || this;</p><p>        _this._id = _id;</p><p>        _this._renderer = _renderer;</p><p>        return _this;</p><p>    }</p><p>    /**</p><p>     * @param {?} element</p><p>     * @param {?=} options</p><p>     * @return {?}</p><p>     */</p><p>    BrowserAnimationFactory.prototype.create = function (element, options) {</p><p>        return new RendererAnimationPlayer(this._id, element, options || {}, this._renderer);</p><p>    };</p><p>    return BrowserAnimationFactory;</p><p>}(__WEBPACK_IMPORTED_MODULE_3__angular_animations__["AnimationFactory"]));</p><p>var RendererAnimationPlayer = (function () {</p><p>    /**</p><p>     * @param {?} id</p><p>     * @param {?} element</p><p>     * @param {?} options</p><p>     * @param {?} _renderer</p><p>     */</p><p>    function RendererAnimationPlayer(id, element, options, _renderer) {</p><p>        this.id = id;</p><p>        this.element = element;</p><p>        this._renderer = _renderer;</p><p>        this.parentPlayer = null;</p><p>        this._started = false;</p><p>        this.totalTime = 0;</p><p>        this._command('create', options);</p><p>    }</p><p>    /**</p><p>     * @param {?} eventName</p><p>     * @param {?} callback</p><p>     * @return {?}</p><p>     */</p><p>    RendererAnimationPlayer.prototype._listen = function (eventName, callback) {</p><p>        return this._renderer.listen(this.element, "@@" + this.id + ":" + eventName, callback);</p><p>    };</p><p>    /**</p><p>     * @param {?} command</p><p>     * @param {...?} args</p><p>     * @return {?}</p><p>     */</p><p>    RendererAnimationPlayer.prototype._command = function (command) {</p><p>        var args = [];</p><p>        for (var _i = 1; _i < arguments.length; _i++) {</p><p>            args[_i - 1] = arguments[_i];</p><p>        }</p><p>        return issueAnimationCommand(this._renderer, this.element, this.id, command, args);</p><p>    };</p><p>    /**</p><p>     * @param {?} fn</p><p>     * @return {?}</p><p>     */</p><p>    RendererAnimationPlayer.prototype.onDone = function (fn) { this._listen('done', fn); };</p><p>    /**</p><p>     * @param {?} fn</p><p>     * @return {?}</p><p>     */</p><p>    RendererAnimationPlayer.prototype.onStart = function (fn) { this._listen('start', fn); };</p><p>    /**</p><p>     * @param {?} fn</p><p>     * @return {?}</p><p>     */</p><p>    RendererAnimationPlayer.prototype.onDestroy = function (fn) { this._listen('destroy', fn); };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    RendererAnimationPlayer.prototype.init = function () { this._command('init'); };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    RendererAnimationPlayer.prototype.hasStarted = function () { return this._started; };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    RendererAnimationPlayer.prototype.play = function () {</p><p>        this._command('play');</p><p>        this._started = true;</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    RendererAnimationPlayer.prototype.pause = function () { this._command('pause'); };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    RendererAnimationPlayer.prototype.restart = function () { this._command('restart'); };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    RendererAnimationPlayer.prototype.finish = function () { this._command('finish'); };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    RendererAnimationPlayer.prototype.destroy = function () { this._command('destroy'); };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    RendererAnimationPlayer.prototype.reset = function () { this._command('reset'); };</p><p>    /**</p><p>     * @param {?} p</p><p>     * @return {?}</p><p>     */</p><p>    RendererAnimationPlayer.prototype.setPosition = function (p) { this._command('setPosition', p); };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    RendererAnimationPlayer.prototype.getPosition = function () { return 0; };</p><p>    return RendererAnimationPlayer;</p><p>}());</p><p>/**</p><p> * @param {?} renderer</p><p> * @param {?} element</p><p> * @param {?} id</p><p> * @param {?} command</p><p> * @param {?} args</p><p> * @return {?}</p><p> */</p><p>function issueAnimationCommand(renderer, element, id, command, args) {</p><p>    return renderer.setProperty(element, "@@" + id + ":" + command, args);</p><p>}</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>var ANIMATION_PREFIX = '@';</p><p>var DISABLE_ANIMATIONS_FLAG = '@.disabled';</p><p>var AnimationRendererFactory = (function () {</p><p>    /**</p><p>     * @param {?} delegate</p><p>     * @param {?} engine</p><p>     * @param {?} _zone</p><p>     */</p><p>    function AnimationRendererFactory(delegate, engine, _zone) {</p><p>        this.delegate = delegate;</p><p>        this.engine = engine;</p><p>        this._zone = _zone;</p><p>        this._currentId = 0;</p><p>        this._microtaskId = 1;</p><p>        this._animationCallbacksBuffer = [];</p><p>        this._rendererCache = new Map();</p><p>        this._cdRecurDepth = 0;</p><p>        engine.onRemovalComplete = function (element, delegate) {</p><p>            // Note: if an component element has a leave animation, and the component</p><p>            // a host leave animation, the view engine will call `removeChild` for the parent</p><p>            // component renderer as well as for the child component renderer.</p><p>            // Therefore, we need to check if we already removed the element.</p><p>            if (delegate && delegate.parentNode(element)) {</p><p>                delegate.removeChild(element.parentNode, element);</p><p>            }</p><p>        };</p><p>    }</p><p>    /**</p><p>     * @param {?} hostElement</p><p>     * @param {?} type</p><p>     * @return {?}</p><p>     */</p><p>    AnimationRendererFactory.prototype.createRenderer = function (hostElement, type) {</p><p>        var _this = this;</p><p>        var /** @type {?} */ EMPTY_NAMESPACE_ID = '';</p><p>        // cache the delegates to find out which cached delegate can</p><p>        // be used by which cached renderer</p><p>        var /** @type {?} */ delegate = this.delegate.createRenderer(hostElement, type);</p><p>        if (!hostElement || !type || !type.data || !type.data['animation']) {</p><p>            var /** @type {?} */ renderer = this._rendererCache.get(delegate);</p><p>            if (!renderer) {</p><p>                renderer = new BaseAnimationRenderer(EMPTY_NAMESPACE_ID, delegate, this.engine);</p><p>                // only cache this result when the base renderer is used</p><p>                this._rendererCache.set(delegate, renderer);</p><p>            }</p><p>            return renderer;</p><p>        }</p><p>        var /** @type {?} */ componentId = type.id;</p><p>        var /** @type {?} */ namespaceId = type.id + '-' + this._currentId;</p><p>        this._currentId++;</p><p>        this.engine.register(namespaceId, hostElement);</p><p>        var /** @type {?} */ animationTriggers = (type.data['animation']);</p><p>        animationTriggers.forEach(function (trigger) { return _this.engine.registerTrigger(componentId, namespaceId, hostElement, trigger.name, trigger); });</p><p>        return new AnimationRenderer(this, namespaceId, delegate, this.engine);</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    AnimationRendererFactory.prototype.begin = function () {</p><p>        this._cdRecurDepth++;</p><p>        if (this.delegate.begin) {</p><p>            this.delegate.begin();</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    AnimationRendererFactory.prototype._scheduleCountTask = function () {</p><p>        var _this = this;</p><p>        Zone.current.scheduleMicroTask('incremenet the animation microtask', function () { return _this._microtaskId++; });</p><p>    };</p><p>    /**</p><p>     * @param {?} count</p><p>     * @param {?} fn</p><p>     * @param {?} data</p><p>     * @return {?}</p><p>     */</p><p>    AnimationRendererFactory.prototype.scheduleListenerCallback = function (count, fn, data) {</p><p>        var _this = this;</p><p>        if (count >= 0 && count < this._microtaskId) {</p><p>            this._zone.run(function () { return fn(data); });</p><p>            return;</p><p>        }</p><p>        if (this._animationCallbacksBuffer.length == 0) {</p><p>            Promise.resolve(null).then(function () {</p><p>                _this._zone.run(function () {</p><p>                    _this._animationCallbacksBuffer.forEach(function (tuple) {</p><p>                        var fn = tuple[0], data = tuple[1];</p><p>                        fn(data);</p><p>                    });</p><p>                    _this._animationCallbacksBuffer = [];</p><p>                });</p><p>            });</p><p>        }</p><p>        this._animationCallbacksBuffer.push([fn, data]);</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    AnimationRendererFactory.prototype.end = function () {</p><p>        var _this = this;</p><p>        this._cdRecurDepth--;</p><p>        // this is to prevent animations from running twice when an inner</p><p>        // component does CD when a parent component insted has inserted it</p><p>        if (this._cdRecurDepth == 0) {</p><p>            this._zone.runOutsideAngular(function () {</p><p>                _this._scheduleCountTask();</p><p>                _this.engine.flush(_this._microtaskId);</p><p>            });</p><p>        }</p><p>        if (this.delegate.end) {</p><p>            this.delegate.end();</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    AnimationRendererFactory.prototype.whenRenderingDone = function () { return this.engine.whenRenderingDone(); };</p><p>    return AnimationRendererFactory;</p><p>}());</p><p>AnimationRendererFactory.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>AnimationRendererFactory.ctorParameters = function () { return [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["RendererFactory2"], },</p><p>    { type: __WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__["b" /* ɵAnimationEngine */], },</p><p>    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["NgZone"], },</p><p>]; };</p><p>var BaseAnimationRenderer = (function () {</p><p>    /**</p><p>     * @param {?} namespaceId</p><p>     * @param {?} delegate</p><p>     * @param {?} engine</p><p>     */</p><p>    function BaseAnimationRenderer(namespaceId, delegate, engine) {</p><p>        this.namespaceId = namespaceId;</p><p>        this.delegate = delegate;</p><p>        this.engine = engine;</p><p>        this.destroyNode = this.delegate.destroyNode ? function (n) { return delegate.destroyNode(n); } : null;</p><p>    }</p><p>    Object.defineProperty(BaseAnimationRenderer.prototype, "data", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this.delegate.data; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    BaseAnimationRenderer.prototype.destroy = function () {</p><p>        this.engine.destroy(this.namespaceId, this.delegate);</p><p>        this.delegate.destroy();</p><p>    };</p><p>    /**</p><p>     * @param {?} name</p><p>     * @param {?=} namespace</p><p>     * @return {?}</p><p>     */</p><p>    BaseAnimationRenderer.prototype.createElement = function (name, namespace) {</p><p>        return this.delegate.createElement(name, namespace);</p><p>    };</p><p>    /**</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    BaseAnimationRenderer.prototype.createComment = function (value) { return this.delegate.createComment(value); };</p><p>    /**</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    BaseAnimationRenderer.prototype.createText = function (value) { return this.delegate.createText(value); };</p><p>    /**</p><p>     * @param {?} parent</p><p>     * @param {?} newChild</p><p>     * @return {?}</p><p>     */</p><p>    BaseAnimationRenderer.prototype.appendChild = function (parent, newChild) {</p><p>        this.delegate.appendChild(parent, newChild);</p><p>        this.engine.onInsert(this.namespaceId, newChild, parent, false);</p><p>    };</p><p>    /**</p><p>     * @param {?} parent</p><p>     * @param {?} newChild</p><p>     * @param {?} refChild</p><p>     * @return {?}</p><p>     */</p><p>    BaseAnimationRenderer.prototype.insertBefore = function (parent, newChild, refChild) {</p><p>        this.delegate.insertBefore(parent, newChild, refChild);</p><p>        this.engine.onInsert(this.namespaceId, newChild, parent, true);</p><p>    };</p><p>    /**</p><p>     * @param {?} parent</p><p>     * @param {?} oldChild</p><p>     * @return {?}</p><p>     */</p><p>    BaseAnimationRenderer.prototype.removeChild = function (parent, oldChild) {</p><p>        this.engine.onRemove(this.namespaceId, oldChild, this.delegate);</p><p>    };</p><p>    /**</p><p>     * @param {?} selectorOrNode</p><p>     * @return {?}</p><p>     */</p><p>    BaseAnimationRenderer.prototype.selectRootElement = function (selectorOrNode) { return this.delegate.selectRootElement(selectorOrNode); };</p><p>    /**</p><p>     * @param {?} node</p><p>     * @return {?}</p><p>     */</p><p>    BaseAnimationRenderer.prototype.parentNode = function (node) { return this.delegate.parentNode(node); };</p><p>    /**</p><p>     * @param {?} node</p><p>     * @return {?}</p><p>     */</p><p>    BaseAnimationRenderer.prototype.nextSibling = function (node) { return this.delegate.nextSibling(node); };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @param {?} name</p><p>     * @param {?} value</p><p>     * @param {?=} namespace</p><p>     * @return {?}</p><p>     */</p><p>    BaseAnimationRenderer.prototype.setAttribute = function (el, name, value, namespace) {</p><p>        this.delegate.setAttribute(el, name, value, namespace);</p><p>    };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @param {?} name</p><p>     * @param {?=} namespace</p><p>     * @return {?}</p><p>     */</p><p>    BaseAnimationRenderer.prototype.removeAttribute = function (el, name, namespace) {</p><p>        this.delegate.removeAttribute(el, name, namespace);</p><p>    };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @param {?} name</p><p>     * @return {?}</p><p>     */</p><p>    BaseAnimationRenderer.prototype.addClass = function (el, name) { this.delegate.addClass(el, name); };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @param {?} name</p><p>     * @return {?}</p><p>     */</p><p>    BaseAnimationRenderer.prototype.removeClass = function (el, name) { this.delegate.removeClass(el, name); };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @param {?} style</p><p>     * @param {?} value</p><p>     * @param {?=} flags</p><p>     * @return {?}</p><p>     */</p><p>    BaseAnimationRenderer.prototype.setStyle = function (el, style, value, flags) {</p><p>        this.delegate.setStyle(el, style, value, flags);</p><p>    };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @param {?} style</p><p>     * @param {?=} flags</p><p>     * @return {?}</p><p>     */</p><p>    BaseAnimationRenderer.prototype.removeStyle = function (el, style, flags) {</p><p>        this.delegate.removeStyle(el, style, flags);</p><p>    };</p><p>    /**</p><p>     * @param {?} el</p><p>     * @param {?} name</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    BaseAnimationRenderer.prototype.setProperty = function (el, name, value) {</p><p>        if (name.charAt(0) == ANIMATION_PREFIX && name == DISABLE_ANIMATIONS_FLAG) {</p><p>            this.disableAnimations(el, !!value);</p><p>        }</p><p>        else {</p><p>            this.delegate.setProperty(el, name, value);</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @param {?} node</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    BaseAnimationRenderer.prototype.setValue = function (node, value) { this.delegate.setValue(node, value); };</p><p>    /**</p><p>     * @param {?} target</p><p>     * @param {?} eventName</p><p>     * @param {?} callback</p><p>     * @return {?}</p><p>     */</p><p>    BaseAnimationRenderer.prototype.listen = function (target, eventName, callback) {</p><p>        return this.delegate.listen(target, eventName, callback);</p><p>    };</p><p>    /**</p><p>     * @param {?} element</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    BaseAnimationRenderer.prototype.disableAnimations = function (element, value) {</p><p>        this.engine.disableAnimations(element, value);</p><p>    };</p><p>    return BaseAnimationRenderer;</p><p>}());</p><p>var AnimationRenderer = (function (_super) {</p><p>    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](AnimationRenderer, _super);</p><p>    /**</p><p>     * @param {?} factory</p><p>     * @param {?} namespaceId</p><p>     * @param {?} delegate</p><p>     * @param {?} engine</p><p>     */</p><p>    function AnimationRenderer(factory, namespaceId, delegate, engine) {</p><p>        var _this = _super.call(this, namespaceId, delegate, engine) || this;</p><p>        _this.factory = factory;</p><p>        _this.namespaceId = namespaceId;</p><p>        return _this;</p><p>    }</p><p>    /**</p><p>     * @param {?} el</p><p>     * @param {?} name</p><p>     * @param {?} value</p><p>     * @return {?}</p><p>     */</p><p>    AnimationRenderer.prototype.setProperty = function (el, name, value) {</p><p>        if (name.charAt(0) == ANIMATION_PREFIX) {</p><p>            if (name.charAt(1) == '.' && name == DISABLE_ANIMATIONS_FLAG) {</p><p>                this.disableAnimations(el, !!value);</p><p>            }</p><p>            else {</p><p>                this.engine.process(this.namespaceId, el, name.substr(1), value);</p><p>            }</p><p>        }</p><p>        else {</p><p>            this.delegate.setProperty(el, name, value);</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @param {?} target</p><p>     * @param {?} eventName</p><p>     * @param {?} callback</p><p>     * @return {?}</p><p>     */</p><p>    AnimationRenderer.prototype.listen = function (target, eventName, callback) {</p><p>        var _this = this;</p><p>        if (eventName.charAt(0) == ANIMATION_PREFIX) {</p><p>            var /** @type {?} */ element = resolveElementFromTarget(target);</p><p>            var /** @type {?} */ name = eventName.substr(1);</p><p>            var /** @type {?} */ phase = '';</p><p>            // @listener.phase is for trigger animation callbacks</p><p>            // @@listener is for animation builder callbacks</p><p>            if (name.charAt(0) != ANIMATION_PREFIX) {</p><p>                _a = parseTriggerCallbackName(name), name = _a[0], phase = _a[1];</p><p>            }</p><p>            return this.engine.listen(this.namespaceId, element, name, phase, function (event) {</p><p>                var /** @type {?} */ countId = ((event))['_data'] || -1;</p><p>                _this.factory.scheduleListenerCallback(countId, callback, event);</p><p>            });</p><p>        }</p><p>        return this.delegate.listen(target, eventName, callback);</p><p>        var _a;</p><p>    };</p><p>    return AnimationRenderer;</p><p>}(BaseAnimationRenderer));</p><p>/**</p><p> * @param {?} target</p><p> * @return {?}</p><p> */</p><p>function resolveElementFromTarget(target) {</p><p>    switch (target) {</p><p>        case 'body':</p><p>            return document.body;</p><p>        case 'document':</p><p>            return document;</p><p>        case 'window':</p><p>            return window;</p><p>        default:</p><p>            return target;</p><p>    }</p><p>}</p><p>/**</p><p> * @param {?} triggerName</p><p> * @return {?}</p><p> */</p><p>function parseTriggerCallbackName(triggerName) {</p><p>    var /** @type {?} */ dotIndex = triggerName.indexOf('.');</p><p>    var /** @type {?} */ trigger = triggerName.substring(0, dotIndex);</p><p>    var /** @type {?} */ phase = triggerName.substr(dotIndex + 1);</p><p>    return [trigger, phase];</p><p>}</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>var InjectableAnimationEngine = (function (_super) {</p><p>    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](InjectableAnimationEngine, _super);</p><p>    /**</p><p>     * @param {?} driver</p><p>     * @param {?} normalizer</p><p>     */</p><p>    function InjectableAnimationEngine(driver, normalizer) {</p><p>        return _super.call(this, driver, normalizer) || this;</p><p>    }</p><p>    return InjectableAnimationEngine;</p><p>}(__WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__["b" /* ɵAnimationEngine */]));</p><p>InjectableAnimationEngine.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>InjectableAnimationEngine.ctorParameters = function () { return [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__["a" /* AnimationDriver */], },</p><p>    { type: __WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__["c" /* ɵAnimationStyleNormalizer */], },</p><p>]; };</p><p>/**</p><p> * @return {?}</p><p> */</p><p>function instantiateSupportedAnimationDriver() {</p><p>    if (Object(__WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__["g" /* ɵsupportsWebAnimations */])()) {</p><p>        return new __WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__["e" /* ɵWebAnimationsDriver */]();</p><p>    }</p><p>    return new __WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__["d" /* ɵNoopAnimationDriver */]();</p><p>}</p><p>/**</p><p> * @return {?}</p><p> */</p><p>function instantiateDefaultStyleNormalizer() {</p><p>    return new __WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__["f" /* ɵWebAnimationsStyleNormalizer */]();</p><p>}</p><p>/**</p><p> * @param {?} renderer</p><p> * @param {?} engine</p><p> * @param {?} zone</p><p> * @return {?}</p><p> */</p><p>function instantiateRendererFactory(renderer, engine, zone) {</p><p>    return new AnimationRendererFactory(renderer, engine, zone);</p><p>}</p><p>var SHARED_ANIMATION_PROVIDERS = [</p><p>    { provide: __WEBPACK_IMPORTED_MODULE_3__angular_animations__["AnimationBuilder"], useClass: BrowserAnimationBuilder },</p><p>    { provide: __WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__["c" /* ɵAnimationStyleNormalizer */], useFactory: instantiateDefaultStyleNormalizer },</p><p>    { provide: __WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__["b" /* ɵAnimationEngine */], useClass: InjectableAnimationEngine }, {</p><p>        provide: __WEBPACK_IMPORTED_MODULE_1__angular_core__["RendererFactory2"],</p><p>        useFactory: instantiateRendererFactory,</p><p>        deps: [__WEBPACK_IMPORTED_MODULE_2__angular_platform_browser__["ɵDomRendererFactory2"], __WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__["b" /* ɵAnimationEngine */], __WEBPACK_IMPORTED_MODULE_1__angular_core__["NgZone"]]</p><p>    }</p><p>];</p><p>/**</p><p> * Separate providers from the actual module so that we can do a local modification in Google3 to</p><p> * include them in the BrowserModule.</p><p> */</p><p>var BROWSER_ANIMATIONS_PROVIDERS = [</p><p>    { provide: __WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__["a" /* AnimationDriver */], useFactory: instantiateSupportedAnimationDriver }</p><p>].concat(SHARED_ANIMATION_PROVIDERS);</p><p>/**</p><p> * Separate providers from the actual module so that we can do a local modification in Google3 to</p><p> * include them in the BrowserTestingModule.</p><p> */</p><p>var BROWSER_NOOP_ANIMATIONS_PROVIDERS = [{ provide: __WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__["a" /* AnimationDriver */], useClass: __WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__["d" /* ɵNoopAnimationDriver */] }].concat(SHARED_ANIMATION_PROVIDERS);</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * \@experimental Animation support is experimental.</p><p> */</p><p>var BrowserAnimationsModule = (function () {</p><p>    function BrowserAnimationsModule() {</p><p>    }</p><p>    return BrowserAnimationsModule;</p><p>}());</p><p>BrowserAnimationsModule.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["NgModule"], args: [{</p><p>                exports: [__WEBPACK_IMPORTED_MODULE_2__angular_platform_browser__["BrowserModule"]],</p><p>                providers: BROWSER_ANIMATIONS_PROVIDERS,</p><p>            },] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>BrowserAnimationsModule.ctorParameters = function () { return []; };</p><p>/**</p><p> * \@experimental Animation support is experimental.</p><p> */</p><p>var NoopAnimationsModule = (function () {</p><p>    function NoopAnimationsModule() {</p><p>    }</p><p>    return NoopAnimationsModule;</p><p>}());</p><p>NoopAnimationsModule.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["NgModule"], args: [{</p><p>                exports: [__WEBPACK_IMPORTED_MODULE_2__angular_platform_browser__["BrowserModule"]],</p><p>                providers: BROWSER_NOOP_ANIMATIONS_PROVIDERS,</p><p>            },] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>NoopAnimationsModule.ctorParameters = function () { return []; };</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * @module</p><p> * @description</p><p> * Entry point for all animation APIs of the animation browser package.</p><p> */</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * @module</p><p> * @description</p><p> * Entry point for all public APIs of the animation package.</p><p> */</p><p>/**</p><p> * Generated bundle index. Do not edit.</p><p> */</p><p></p><p>//# sourceMappingURL=animations.es5.js.map</p><p></p><p></p><p>/***/ }),</p><p></p><p>/***/ "../../../router/@angular/router.es5.js":</p><p>/***/ (function(module, __webpack_exports__, __webpack_require__) {</p><p></p><p>"use strict";</p><p>Object.defineProperty(__webpack_exports__, "__esModule", { value: true });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RouterLink", function() { return RouterLink; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RouterLinkWithHref", function() { return RouterLinkWithHref; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RouterLinkActive", function() { return RouterLinkActive; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RouterOutlet", function() { return RouterOutlet; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GuardsCheckEnd", function() { return GuardsCheckEnd; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GuardsCheckStart", function() { return GuardsCheckStart; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NavigationCancel", function() { return NavigationCancel; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NavigationEnd", function() { return NavigationEnd; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NavigationError", function() { return NavigationError; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NavigationStart", function() { return NavigationStart; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ResolveEnd", function() { return ResolveEnd; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ResolveStart", function() { return ResolveStart; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RouteConfigLoadEnd", function() { return RouteConfigLoadEnd; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RouteConfigLoadStart", function() { return RouteConfigLoadStart; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RoutesRecognized", function() { return RoutesRecognized; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RouteReuseStrategy", function() { return RouteReuseStrategy; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Router", function() { return Router; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ROUTES", function() { return ROUTES; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ROUTER_CONFIGURATION", function() { return ROUTER_CONFIGURATION; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ROUTER_INITIALIZER", function() { return ROUTER_INITIALIZER; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RouterModule", function() { return RouterModule; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "provideRoutes", function() { return provideRoutes; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ChildrenOutletContexts", function() { return ChildrenOutletContexts; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OutletContext", function() { return OutletContext; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoPreloading", function() { return NoPreloading; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PreloadAllModules", function() { return PreloadAllModules; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PreloadingStrategy", function() { return PreloadingStrategy; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RouterPreloader", function() { return RouterPreloader; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ActivatedRoute", function() { return ActivatedRoute; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ActivatedRouteSnapshot", function() { return ActivatedRouteSnapshot; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RouterState", function() { return RouterState; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RouterStateSnapshot", function() { return RouterStateSnapshot; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PRIMARY_OUTLET", function() { return PRIMARY_OUTLET; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "convertToParamMap", function() { return convertToParamMap; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UrlHandlingStrategy", function() { return UrlHandlingStrategy; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultUrlSerializer", function() { return DefaultUrlSerializer; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UrlSegment", function() { return UrlSegment; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UrlSegmentGroup", function() { return UrlSegmentGroup; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UrlSerializer", function() { return UrlSerializer; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UrlTree", function() { return UrlTree; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return VERSION; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵROUTER_PROVIDERS", function() { return ROUTER_PROVIDERS; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵflatten", function() { return flatten; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵa", function() { return ROUTER_FORROOT_GUARD; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵg", function() { return RouterInitializer; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵh", function() { return getAppInitializer; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵi", function() { return getBootstrapListener; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵd", function() { return provideForRootGuard; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵc", function() { return provideLocationStrategy; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵj", function() { return provideRouterInitializer; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵf", function() { return rootRoute; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵb", function() { return routerNgProbeToken; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵe", function() { return setupRouter; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵk", function() { return Tree; });</p><p>/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵl", function() { return TreeNode; });</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__("../../../../tslib/tslib.es6.js");</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common__ = __webpack_require__("../../../common/@angular/common.es5.js");</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__("../../../core/@angular/core.es5.js");</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject__ = __webpack_require__("../../../../rxjs/BehaviorSubject.js");</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject__);</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_rxjs_Subject__ = __webpack_require__("../../../../rxjs/Subject.js");</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_rxjs_Subject___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_rxjs_Subject__);</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs_observable_from__ = __webpack_require__("../../../../rxjs/observable/from.js");</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs_observable_from___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_from__);</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__ = __webpack_require__("../../../../rxjs/observable/of.js");</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__);</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_concatMap__ = __webpack_require__("../../../../rxjs/operator/concatMap.js");</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_concatMap___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_rxjs_operator_concatMap__);</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_rxjs_operator_every__ = __webpack_require__("../../../../rxjs/operator/every.js");</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_rxjs_operator_every___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_rxjs_operator_every__);</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_rxjs_operator_first__ = __webpack_require__("../../../../rxjs/operator/first.js");</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_rxjs_operator_first___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_rxjs_operator_first__);</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_rxjs_operator_last__ = __webpack_require__("../../../../rxjs/operator/last.js");</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_rxjs_operator_last___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10_rxjs_operator_last__);</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__ = __webpack_require__("../../../../rxjs/operator/map.js");</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__);</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_rxjs_operator_mergeMap__ = __webpack_require__("../../../../rxjs/operator/mergeMap.js");</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_rxjs_operator_mergeMap___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_12_rxjs_operator_mergeMap__);</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_rxjs_operator_reduce__ = __webpack_require__("../../../../rxjs/operator/reduce.js");</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_rxjs_operator_reduce___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_13_rxjs_operator_reduce__);</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_rxjs_Observable__ = __webpack_require__("../../../../rxjs/Observable.js");</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_14_rxjs_Observable__);</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_rxjs_operator_catch__ = __webpack_require__("../../../../rxjs/operator/catch.js");</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_rxjs_operator_catch___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_15_rxjs_operator_catch__);</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_rxjs_operator_concatAll__ = __webpack_require__("../../../../rxjs/operator/concatAll.js");</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_rxjs_operator_concatAll___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_16_rxjs_operator_concatAll__);</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_rxjs_util_EmptyError__ = __webpack_require__("../../../../rxjs/util/EmptyError.js");</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_rxjs_util_EmptyError___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_17_rxjs_util_EmptyError__);</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18_rxjs_observable_fromPromise__ = __webpack_require__("../../../../rxjs/observable/fromPromise.js");</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18_rxjs_observable_fromPromise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_18_rxjs_observable_fromPromise__);</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19_rxjs_operator_mergeAll__ = __webpack_require__("../../../../rxjs/operator/mergeAll.js");</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19_rxjs_operator_mergeAll___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_19_rxjs_operator_mergeAll__);</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__angular_platform_browser__ = __webpack_require__("../../../platform-browser/@angular/platform-browser.es5.js");</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21_rxjs_operator_filter__ = __webpack_require__("../../../../rxjs/operator/filter.js");</p><p>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21_rxjs_operator_filter___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_21_rxjs_operator_filter__);</p><p></p><p>/**</p><p> * @license Angular v4.3.5</p><p> * (c) 2010-2017 Google, Inc. https://angular.io/</p><p> * License: MIT</p><p> */</p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * \@whatItDoes Represents an event triggered when a navigation starts.</p><p> *</p><p> * \@stable</p><p> */</p><p>var NavigationStart = (function () {</p><p>    /**</p><p>     * @param {?} id</p><p>     * @param {?} url</p><p>     */</p><p>    function NavigationStart(id, url) {</p><p>        this.id = id;</p><p>        this.url = url;</p><p>    }</p><p>    /**</p><p>     * \@docsNotRequired</p><p>     * @return {?}</p><p>     */</p><p>    NavigationStart.prototype.toString = function () { return "NavigationStart(id: " + this.id + ", url: '" + this.url + "')"; };</p><p>    return NavigationStart;</p><p>}());</p><p>/**</p><p> * \@whatItDoes Represents an event triggered when a navigation ends successfully.</p><p> *</p><p> * \@stable</p><p> */</p><p>var NavigationEnd = (function () {</p><p>    /**</p><p>     * @param {?} id</p><p>     * @param {?} url</p><p>     * @param {?} urlAfterRedirects</p><p>     */</p><p>    function NavigationEnd(id, url, urlAfterRedirects) {</p><p>        this.id = id;</p><p>        this.url = url;</p><p>        this.urlAfterRedirects = urlAfterRedirects;</p><p>    }</p><p>    /**</p><p>     * \@docsNotRequired</p><p>     * @return {?}</p><p>     */</p><p>    NavigationEnd.prototype.toString = function () {</p><p>        return "NavigationEnd(id: " + this.id + ", url: '" + this.url + "', urlAfterRedirects: '" + this.urlAfterRedirects + "')";</p><p>    };</p><p>    return NavigationEnd;</p><p>}());</p><p>/**</p><p> * \@whatItDoes Represents an event triggered when a navigation is canceled.</p><p> *</p><p> * \@stable</p><p> */</p><p>var NavigationCancel = (function () {</p><p>    /**</p><p>     * @param {?} id</p><p>     * @param {?} url</p><p>     * @param {?} reason</p><p>     */</p><p>    function NavigationCancel(id, url, reason) {</p><p>        this.id = id;</p><p>        this.url = url;</p><p>        this.reason = reason;</p><p>    }</p><p>    /**</p><p>     * \@docsNotRequired</p><p>     * @return {?}</p><p>     */</p><p>    NavigationCancel.prototype.toString = function () { return "NavigationCancel(id: " + this.id + ", url: '" + this.url + "')"; };</p><p>    return NavigationCancel;</p><p>}());</p><p>/**</p><p> * \@whatItDoes Represents an event triggered when a navigation fails due to an unexpected error.</p><p> *</p><p> * \@stable</p><p> */</p><p>var NavigationError = (function () {</p><p>    /**</p><p>     * @param {?} id</p><p>     * @param {?} url</p><p>     * @param {?} error</p><p>     */</p><p>    function NavigationError(id, url, error) {</p><p>        this.id = id;</p><p>        this.url = url;</p><p>        this.error = error;</p><p>    }</p><p>    /**</p><p>     * \@docsNotRequired</p><p>     * @return {?}</p><p>     */</p><p>    NavigationError.prototype.toString = function () {</p><p>        return "NavigationError(id: " + this.id + ", url: '" + this.url + "', error: " + this.error + ")";</p><p>    };</p><p>    return NavigationError;</p><p>}());</p><p>/**</p><p> * \@whatItDoes Represents an event triggered when routes are recognized.</p><p> *</p><p> * \@stable</p><p> */</p><p>var RoutesRecognized = (function () {</p><p>    /**</p><p>     * @param {?} id</p><p>     * @param {?} url</p><p>     * @param {?} urlAfterRedirects</p><p>     * @param {?} state</p><p>     */</p><p>    function RoutesRecognized(id, url, urlAfterRedirects, state) {</p><p>        this.id = id;</p><p>        this.url = url;</p><p>        this.urlAfterRedirects = urlAfterRedirects;</p><p>        this.state = state;</p><p>    }</p><p>    /**</p><p>     * \@docsNotRequired</p><p>     * @return {?}</p><p>     */</p><p>    RoutesRecognized.prototype.toString = function () {</p><p>        return "RoutesRecognized(id: " + this.id + ", url: '" + this.url + "', urlAfterRedirects: '" + this.urlAfterRedirects + "', state: " + this.state + ")";</p><p>    };</p><p>    return RoutesRecognized;</p><p>}());</p><p>/**</p><p> * \@whatItDoes Represents an event triggered before lazy loading a route config.</p><p> *</p><p> * \@experimental</p><p> */</p><p>var RouteConfigLoadStart = (function () {</p><p>    /**</p><p>     * @param {?} route</p><p>     */</p><p>    function RouteConfigLoadStart(route) {</p><p>        this.route = route;</p><p>    }</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    RouteConfigLoadStart.prototype.toString = function () { return "RouteConfigLoadStart(path: " + this.route.path + ")"; };</p><p>    return RouteConfigLoadStart;</p><p>}());</p><p>/**</p><p> * \@whatItDoes Represents an event triggered when a route has been lazy loaded.</p><p> *</p><p> * \@experimental</p><p> */</p><p>var RouteConfigLoadEnd = (function () {</p><p>    /**</p><p>     * @param {?} route</p><p>     */</p><p>    function RouteConfigLoadEnd(route) {</p><p>        this.route = route;</p><p>    }</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    RouteConfigLoadEnd.prototype.toString = function () { return "RouteConfigLoadEnd(path: " + this.route.path + ")"; };</p><p>    return RouteConfigLoadEnd;</p><p>}());</p><p>/**</p><p> * \@whatItDoes Represents the start of the Guard phase of routing.</p><p> *</p><p> * \@experimental</p><p> */</p><p>var GuardsCheckStart = (function () {</p><p>    /**</p><p>     * @param {?} id</p><p>     * @param {?} url</p><p>     * @param {?} urlAfterRedirects</p><p>     * @param {?} state</p><p>     */</p><p>    function GuardsCheckStart(id, url, urlAfterRedirects, state) {</p><p>        this.id = id;</p><p>        this.url = url;</p><p>        this.urlAfterRedirects = urlAfterRedirects;</p><p>        this.state = state;</p><p>    }</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    GuardsCheckStart.prototype.toString = function () {</p><p>        return "GuardsCheckStart(id: " + this.id + ", url: '" + this.url + "', urlAfterRedirects: '" + this.urlAfterRedirects + "', state: " + this.state + ")";</p><p>    };</p><p>    return GuardsCheckStart;</p><p>}());</p><p>/**</p><p> * \@whatItDoes Represents the end of the Guard phase of routing.</p><p> *</p><p> * \@experimental</p><p> */</p><p>var GuardsCheckEnd = (function () {</p><p>    /**</p><p>     * @param {?} id</p><p>     * @param {?} url</p><p>     * @param {?} urlAfterRedirects</p><p>     * @param {?} state</p><p>     * @param {?} shouldActivate</p><p>     */</p><p>    function GuardsCheckEnd(id, url, urlAfterRedirects, state, shouldActivate) {</p><p>        this.id = id;</p><p>        this.url = url;</p><p>        this.urlAfterRedirects = urlAfterRedirects;</p><p>        this.state = state;</p><p>        this.shouldActivate = shouldActivate;</p><p>    }</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    GuardsCheckEnd.prototype.toString = function () {</p><p>        return "GuardsCheckEnd(id: " + this.id + ", url: '" + this.url + "', urlAfterRedirects: '" + this.urlAfterRedirects + "', state: " + this.state + ", shouldActivate: " + this.shouldActivate + ")";</p><p>    };</p><p>    return GuardsCheckEnd;</p><p>}());</p><p>/**</p><p> * \@whatItDoes Represents the start of the Resolve phase of routing. The timing of this</p><p> * event may change, thus it's experimental. In the current iteration it will run</p><p> * in the "resolve" phase whether there's things to resolve or not. In the future this</p><p> * behavior may change to only run when there are things to be resolved.</p><p> *</p><p> * \@experimental</p><p> */</p><p>var ResolveStart = (function () {</p><p>    /**</p><p>     * @param {?} id</p><p>     * @param {?} url</p><p>     * @param {?} urlAfterRedirects</p><p>     * @param {?} state</p><p>     */</p><p>    function ResolveStart(id, url, urlAfterRedirects, state) {</p><p>        this.id = id;</p><p>        this.url = url;</p><p>        this.urlAfterRedirects = urlAfterRedirects;</p><p>        this.state = state;</p><p>    }</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    ResolveStart.prototype.toString = function () {</p><p>        return "ResolveStart(id: " + this.id + ", url: '" + this.url + "', urlAfterRedirects: '" + this.urlAfterRedirects + "', state: " + this.state + ")";</p><p>    };</p><p>    return ResolveStart;</p><p>}());</p><p>/**</p><p> * \@whatItDoes Represents the end of the Resolve phase of routing. See note on</p><p> * {\@link ResolveStart} for use of this experimental API.</p><p> *</p><p> * \@experimental</p><p> */</p><p>var ResolveEnd = (function () {</p><p>    /**</p><p>     * @param {?} id</p><p>     * @param {?} url</p><p>     * @param {?} urlAfterRedirects</p><p>     * @param {?} state</p><p>     */</p><p>    function ResolveEnd(id, url, urlAfterRedirects, state) {</p><p>        this.id = id;</p><p>        this.url = url;</p><p>        this.urlAfterRedirects = urlAfterRedirects;</p><p>        this.state = state;</p><p>    }</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    ResolveEnd.prototype.toString = function () {</p><p>        return "ResolveEnd(id: " + this.id + ", url: '" + this.url + "', urlAfterRedirects: '" + this.urlAfterRedirects + "', state: " + this.state + ")";</p><p>    };</p><p>    return ResolveEnd;</p><p>}());</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * \@whatItDoes Name of the primary outlet.</p><p> *</p><p> * \@stable</p><p> */</p><p>var PRIMARY_OUTLET = 'primary';</p><p>var ParamsAsMap = (function () {</p><p>    /**</p><p>     * @param {?} params</p><p>     */</p><p>    function ParamsAsMap(params) {</p><p>        this.params = params || {};</p><p>    }</p><p>    /**</p><p>     * @param {?} name</p><p>     * @return {?}</p><p>     */</p><p>    ParamsAsMap.prototype.has = function (name) { return this.params.hasOwnProperty(name); };</p><p>    /**</p><p>     * @param {?} name</p><p>     * @return {?}</p><p>     */</p><p>    ParamsAsMap.prototype.get = function (name) {</p><p>        if (this.has(name)) {</p><p>            var /** @type {?} */ v = this.params[name];</p><p>            return Array.isArray(v) ? v[0] : v;</p><p>        }</p><p>        return null;</p><p>    };</p><p>    /**</p><p>     * @param {?} name</p><p>     * @return {?}</p><p>     */</p><p>    ParamsAsMap.prototype.getAll = function (name) {</p><p>        if (this.has(name)) {</p><p>            var /** @type {?} */ v = this.params[name];</p><p>            return Array.isArray(v) ? v : [v];</p><p>        }</p><p>        return [];</p><p>    };</p><p>    Object.defineProperty(ParamsAsMap.prototype, "keys", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return Object.keys(this.params); },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    return ParamsAsMap;</p><p>}());</p><p>/**</p><p> * Convert a {\@link Params} instance to a {\@link ParamMap}.</p><p> *</p><p> * \@stable</p><p> * @param {?} params</p><p> * @return {?}</p><p> */</p><p>function convertToParamMap(params) {</p><p>    return new ParamsAsMap(params);</p><p>}</p><p>var NAVIGATION_CANCELING_ERROR = 'ngNavigationCancelingError';</p><p>/**</p><p> * @param {?} message</p><p> * @return {?}</p><p> */</p><p>function navigationCancelingError(message) {</p><p>    var /** @type {?} */ error = Error('NavigationCancelingError: ' + message);</p><p>    ((error))[NAVIGATION_CANCELING_ERROR] = true;</p><p>    return error;</p><p>}</p><p>/**</p><p> * @param {?} error</p><p> * @return {?}</p><p> */</p><p>function isNavigationCancelingError(error) {</p><p>    return ((error))[NAVIGATION_CANCELING_ERROR];</p><p>}</p><p>/**</p><p> * @param {?} segments</p><p> * @param {?} segmentGroup</p><p> * @param {?} route</p><p> * @return {?}</p><p> */</p><p>function defaultUrlMatcher(segments, segmentGroup, route) {</p><p>    var /** @type {?} */ parts = ((route.path)).split('/');</p><p>    if (parts.length > segments.length) {</p><p>        // The actual URL is shorter than the config, no match</p><p>        return null;</p><p>    }</p><p>    if (route.pathMatch === 'full' &&</p><p>        (segmentGroup.hasChildren() || parts.length < segments.length)) {</p><p>        // The config is longer than the actual URL but we are looking for a full match, return null</p><p>        return null;</p><p>    }</p><p>    var /** @type {?} */ posParams = {};</p><p>    // Check each config part against the actual URL</p><p>    for (var /** @type {?} */ index = 0; index < parts.length; index++) {</p><p>        var /** @type {?} */ part = parts[index];</p><p>        var /** @type {?} */ segment = segments[index];</p><p>        var /** @type {?} */ isParameter = part.startsWith(':');</p><p>        if (isParameter) {</p><p>            posParams[part.substring(1)] = segment;</p><p>        }</p><p>        else if (part !== segment.path) {</p><p>            // The actual URL part does not match the config, no match</p><p>            return null;</p><p>        }</p><p>    }</p><p>    return { consumed: segments.slice(0, parts.length), posParams: posParams };</p><p>}</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>var LoadedRouterConfig = (function () {</p><p>    /**</p><p>     * @param {?} routes</p><p>     * @param {?} module</p><p>     */</p><p>    function LoadedRouterConfig(routes, module) {</p><p>        this.routes = routes;</p><p>        this.module = module;</p><p>    }</p><p>    return LoadedRouterConfig;</p><p>}());</p><p>/**</p><p> * @param {?} config</p><p> * @param {?=} parentPath</p><p> * @return {?}</p><p> */</p><p>function validateConfig(config, parentPath) {</p><p>    if (parentPath === void 0) { parentPath = ''; }</p><p>    // forEach doesn't iterate undefined values</p><p>    for (var /** @type {?} */ i = 0; i < config.length; i++) {</p><p>        var /** @type {?} */ route = config[i];</p><p>        var /** @type {?} */ fullPath = getFullPath(parentPath, route);</p><p>        validateNode(route, fullPath);</p><p>    }</p><p>}</p><p>/**</p><p> * @param {?} route</p><p> * @param {?} fullPath</p><p> * @return {?}</p><p> */</p><p>function validateNode(route, fullPath) {</p><p>    if (!route) {</p><p>        throw new Error("\n      Invalid configuration of route '" + fullPath + "': Encountered undefined route.\n      The reason might be an extra comma.\n\n      Example:\n      const routes: Routes = [\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\n        { path: 'detail/:id', component: HeroDetailComponent }\n      ];\n    ");</p><p>    }</p><p>    if (Array.isArray(route)) {</p><p>        throw new Error("Invalid configuration of route '" + fullPath + "': Array cannot be specified");</p><p>    }</p><p>    if (!route.component && (route.outlet && route.outlet !== PRIMARY_OUTLET)) {</p><p>        throw new Error("Invalid configuration of route '" + fullPath + "': a componentless route cannot have a named outlet set");</p><p>    }</p><p>    if (route.redirectTo && route.children) {</p><p>        throw new Error("Invalid configuration of route '" + fullPath + "': redirectTo and children cannot be used together");</p><p>    }</p><p>    if (route.redirectTo && route.loadChildren) {</p><p>        throw new Error("Invalid configuration of route '" + fullPath + "': redirectTo and loadChildren cannot be used together");</p><p>    }</p><p>    if (route.children && route.loadChildren) {</p><p>        throw new Error("Invalid configuration of route '" + fullPath + "': children and loadChildren cannot be used together");</p><p>    }</p><p>    if (route.redirectTo && route.component) {</p><p>        throw new Error("Invalid configuration of route '" + fullPath + "': redirectTo and component cannot be used together");</p><p>    }</p><p>    if (route.path && route.matcher) {</p><p>        throw new Error("Invalid configuration of route '" + fullPath + "': path and matcher cannot be used together");</p><p>    }</p><p>    if (route.redirectTo === void 0 && !route.component && !route.children && !route.loadChildren) {</p><p>        throw new Error("Invalid configuration of route '" + fullPath + "'. One of the following must be provided: component, redirectTo, children or loadChildren");</p><p>    }</p><p>    if (route.path === void 0 && route.matcher === void 0) {</p><p>        throw new Error("Invalid configuration of route '" + fullPath + "': routes must have either a path or a matcher specified");</p><p>    }</p><p>    if (typeof route.path === 'string' && route.path.charAt(0) === '/') {</p><p>        throw new Error("Invalid configuration of route '" + fullPath + "': path cannot start with a slash");</p><p>    }</p><p>    if (route.path === '' && route.redirectTo !== void 0 && route.pathMatch === void 0) {</p><p>        var /** @type {?} */ exp = "The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.";</p><p>        throw new Error("Invalid configuration of route '{path: \"" + fullPath + "\", redirectTo: \"" + route.redirectTo + "\"}': please provide 'pathMatch'. " + exp);</p><p>    }</p><p>    if (route.pathMatch !== void 0 && route.pathMatch !== 'full' && route.pathMatch !== 'prefix') {</p><p>        throw new Error("Invalid configuration of route '" + fullPath + "': pathMatch can only be set to 'prefix' or 'full'");</p><p>    }</p><p>    if (route.children) {</p><p>        validateConfig(route.children, fullPath);</p><p>    }</p><p>}</p><p>/**</p><p> * @param {?} parentPath</p><p> * @param {?} currentRoute</p><p> * @return {?}</p><p> */</p><p>function getFullPath(parentPath, currentRoute) {</p><p>    if (!currentRoute) {</p><p>        return parentPath;</p><p>    }</p><p>    if (!parentPath && !currentRoute.path) {</p><p>        return '';</p><p>    }</p><p>    else if (parentPath && !currentRoute.path) {</p><p>        return parentPath + "/";</p><p>    }</p><p>    else if (!parentPath && currentRoute.path) {</p><p>        return currentRoute.path;</p><p>    }</p><p>    else {</p><p>        return parentPath + "/" + currentRoute.path;</p><p>    }</p><p>}</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * @param {?} a</p><p> * @param {?} b</p><p> * @return {?}</p><p> */</p><p>function shallowEqualArrays(a, b) {</p><p>    if (a.length !== b.length)</p><p>        return false;</p><p>    for (var /** @type {?} */ i = 0; i < a.length; ++i) {</p><p>        if (!shallowEqual(a[i], b[i]))</p><p>            return false;</p><p>    }</p><p>    return true;</p><p>}</p><p>/**</p><p> * @param {?} a</p><p> * @param {?} b</p><p> * @return {?}</p><p> */</p><p>function shallowEqual(a, b) {</p><p>    var /** @type {?} */ k1 = Object.keys(a);</p><p>    var /** @type {?} */ k2 = Object.keys(b);</p><p>    if (k1.length != k2.length) {</p><p>        return false;</p><p>    }</p><p>    var /** @type {?} */ key;</p><p>    for (var /** @type {?} */ i = 0; i < k1.length; i++) {</p><p>        key = k1[i];</p><p>        if (a[key] !== b[key]) {</p><p>            return false;</p><p>        }</p><p>    }</p><p>    return true;</p><p>}</p><p>/**</p><p> * @template T</p><p> * @param {?} arr</p><p> * @return {?}</p><p> */</p><p>function flatten(arr) {</p><p>    return Array.prototype.concat.apply([], arr);</p><p>}</p><p>/**</p><p> * @template T</p><p> * @param {?} a</p><p> * @return {?}</p><p> */</p><p>function last$1(a) {</p><p>    return a.length > 0 ? a[a.length - 1] : null;</p><p>}</p><p>/**</p><p> * @param {?} bools</p><p> * @return {?}</p><p> */</p><p>/**</p><p> * @template K, V</p><p> * @param {?} map</p><p> * @param {?} callback</p><p> * @return {?}</p><p> */</p><p>function forEach(map$$1, callback) {</p><p>    for (var /** @type {?} */ prop in map$$1) {</p><p>        if (map$$1.hasOwnProperty(prop)) {</p><p>            callback(map$$1[prop], prop);</p><p>        }</p><p>    }</p><p>}</p><p>/**</p><p> * @template A, B</p><p> * @param {?} obj</p><p> * @param {?} fn</p><p> * @return {?}</p><p> */</p><p>function waitForMap(obj, fn) {</p><p>    if (Object.keys(obj).length === 0) {</p><p>        return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])({});</p><p>    }</p><p>    var /** @type {?} */ waitHead = [];</p><p>    var /** @type {?} */ waitTail = [];</p><p>    var /** @type {?} */ res = {};</p><p>    forEach(obj, function (a, k) {</p><p>        var /** @type {?} */ mapped = __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(fn(k, a), function (r) { return res[k] = r; });</p><p>        if (k === PRIMARY_OUTLET) {</p><p>            waitHead.push(mapped);</p><p>        }</p><p>        else {</p><p>            waitTail.push(mapped);</p><p>        }</p><p>    });</p><p>    var /** @type {?} */ concat$ = __WEBPACK_IMPORTED_MODULE_16_rxjs_operator_concatAll__["concatAll"].call(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"].apply(void 0, waitHead.concat(waitTail)));</p><p>    var /** @type {?} */ last$ = __WEBPACK_IMPORTED_MODULE_10_rxjs_operator_last__["last"].call(concat$);</p><p>    return __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(last$, function () { return res; });</p><p>}</p><p>/**</p><p> * @param {?} observables</p><p> * @return {?}</p><p> */</p><p>function andObservables(observables) {</p><p>    var /** @type {?} */ merged$ = __WEBPACK_IMPORTED_MODULE_19_rxjs_operator_mergeAll__["mergeAll"].call(observables);</p><p>    return __WEBPACK_IMPORTED_MODULE_8_rxjs_operator_every__["every"].call(merged$, function (result) { return result === true; });</p><p>}</p><p>/**</p><p> * @template T</p><p> * @param {?} value</p><p> * @return {?}</p><p> */</p><p>function wrapIntoObservable(value) {</p><p>    if (Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["ɵisObservable"])(value)) {</p><p>        return value;</p><p>    }</p><p>    if (Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["ɵisPromise"])(value)) {</p><p>        // Use `Promise.resolve()` to wrap promise-like instances.</p><p>        // Required ie when a Resolver returns a AngularJS `$q` promise to correctly trigger the</p><p>        // change detection.</p><p>        return Object(__WEBPACK_IMPORTED_MODULE_18_rxjs_observable_fromPromise__["fromPromise"])(Promise.resolve(value));</p><p>    }</p><p>    return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(/** @type {?} */ (value));</p><p>}</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * @return {?}</p><p> */</p><p>function createEmptyUrlTree() {</p><p>    return new UrlTree(new UrlSegmentGroup([], {}), {}, null);</p><p>}</p><p>/**</p><p> * @param {?} container</p><p> * @param {?} containee</p><p> * @param {?} exact</p><p> * @return {?}</p><p> */</p><p>function containsTree(container, containee, exact) {</p><p>    if (exact) {</p><p>        return equalQueryParams(container.queryParams, containee.queryParams) &&</p><p>            equalSegmentGroups(container.root, containee.root);</p><p>    }</p><p>    return containsQueryParams(container.queryParams, containee.queryParams) &&</p><p>        containsSegmentGroup(container.root, containee.root);</p><p>}</p><p>/**</p><p> * @param {?} container</p><p> * @param {?} containee</p><p> * @return {?}</p><p> */</p><p>function equalQueryParams(container, containee) {</p><p>    return shallowEqual(container, containee);</p><p>}</p><p>/**</p><p> * @param {?} container</p><p> * @param {?} containee</p><p> * @return {?}</p><p> */</p><p>function equalSegmentGroups(container, containee) {</p><p>    if (!equalPath(container.segments, containee.segments))</p><p>        return false;</p><p>    if (container.numberOfChildren !== containee.numberOfChildren)</p><p>        return false;</p><p>    for (var /** @type {?} */ c in containee.children) {</p><p>        if (!container.children[c])</p><p>            return false;</p><p>        if (!equalSegmentGroups(container.children[c], containee.children[c]))</p><p>            return false;</p><p>    }</p><p>    return true;</p><p>}</p><p>/**</p><p> * @param {?} container</p><p> * @param {?} containee</p><p> * @return {?}</p><p> */</p><p>function containsQueryParams(container, containee) {</p><p>    return Object.keys(containee).length <= Object.keys(container).length &&</p><p>        Object.keys(containee).every(function (key) { return containee[key] === container[key]; });</p><p>}</p><p>/**</p><p> * @param {?} container</p><p> * @param {?} containee</p><p> * @return {?}</p><p> */</p><p>function containsSegmentGroup(container, containee) {</p><p>    return containsSegmentGroupHelper(container, containee, containee.segments);</p><p>}</p><p>/**</p><p> * @param {?} container</p><p> * @param {?} containee</p><p> * @param {?} containeePaths</p><p> * @return {?}</p><p> */</p><p>function containsSegmentGroupHelper(container, containee, containeePaths) {</p><p>    if (container.segments.length > containeePaths.length) {</p><p>        var /** @type {?} */ current = container.segments.slice(0, containeePaths.length);</p><p>        if (!equalPath(current, containeePaths))</p><p>            return false;</p><p>        if (containee.hasChildren())</p><p>            return false;</p><p>        return true;</p><p>    }</p><p>    else if (container.segments.length === containeePaths.length) {</p><p>        if (!equalPath(container.segments, containeePaths))</p><p>            return false;</p><p>        for (var /** @type {?} */ c in containee.children) {</p><p>            if (!container.children[c])</p><p>                return false;</p><p>            if (!containsSegmentGroup(container.children[c], containee.children[c]))</p><p>                return false;</p><p>        }</p><p>        return true;</p><p>    }</p><p>    else {</p><p>        var /** @type {?} */ current = containeePaths.slice(0, container.segments.length);</p><p>        var /** @type {?} */ next = containeePaths.slice(container.segments.length);</p><p>        if (!equalPath(container.segments, current))</p><p>            return false;</p><p>        if (!container.children[PRIMARY_OUTLET])</p><p>            return false;</p><p>        return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next);</p><p>    }</p><p>}</p><p>/**</p><p> * \@whatItDoes Represents the parsed URL.</p><p> *</p><p> * \@howToUse</p><p> *</p><p> * ```</p><p> * \@Component({templateUrl:'template.html'})</p><p> * class MyComponent {</p><p> *   constructor(router: Router) {</p><p> *     const tree: UrlTree =</p><p> *       router.parseUrl('/team/33/(user/victor//support:help)?debug=true#fragment');</p><p> *     const f = tree.fragment; // return 'fragment'</p><p> *     const q = tree.queryParams; // returns {debug: 'true'}</p><p> *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];</p><p> *     const s: UrlSegment[] = g.segments; // returns 2 segments 'team' and '33'</p><p> *     g.children[PRIMARY_OUTLET].segments; // returns 2 segments 'user' and 'victor'</p><p> *     g.children['support'].segments; // return 1 segment 'help'</p><p> *   }</p><p> * }</p><p> * ```</p><p> *</p><p> * \@description</p><p> *</p><p> * Since a router state is a tree, and the URL is nothing but a serialized state, the URL is a</p><p> * serialized tree.</p><p> * UrlTree is a data structure that provides a lot of affordances in dealing with URLs</p><p> *</p><p> * \@stable</p><p> */</p><p>var UrlTree = (function () {</p><p>    /**</p><p>     * \@internal</p><p>     * @param {?} root</p><p>     * @param {?} queryParams</p><p>     * @param {?} fragment</p><p>     */</p><p>    function UrlTree(root, queryParams, fragment) {</p><p>        this.root = root;</p><p>        this.queryParams = queryParams;</p><p>        this.fragment = fragment;</p><p>    }</p><p>    Object.defineProperty(UrlTree.prototype, "queryParamMap", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () {</p><p>            if (!this._queryParamMap) {</p><p>                this._queryParamMap = convertToParamMap(this.queryParams);</p><p>            }</p><p>            return this._queryParamMap;</p><p>        },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    /**</p><p>     * \@docsNotRequired</p><p>     * @return {?}</p><p>     */</p><p>    UrlTree.prototype.toString = function () { return DEFAULT_SERIALIZER.serialize(this); };</p><p>    return UrlTree;</p><p>}());</p><p>/**</p><p> * \@whatItDoes Represents the parsed URL segment group.</p><p> *</p><p> * See {\@link UrlTree} for more information.</p><p> *</p><p> * \@stable</p><p> */</p><p>var UrlSegmentGroup = (function () {</p><p>    /**</p><p>     * @param {?} segments</p><p>     * @param {?} children</p><p>     */</p><p>    function UrlSegmentGroup(segments, children) {</p><p>        var _this = this;</p><p>        this.segments = segments;</p><p>        this.children = children;</p><p>        /**</p><p>         * The parent node in the url tree</p><p>         */</p><p>        this.parent = null;</p><p>        forEach(children, function (v, k) { return v.parent = _this; });</p><p>    }</p><p>    /**</p><p>     * Whether the segment has child segments</p><p>     * @return {?}</p><p>     */</p><p>    UrlSegmentGroup.prototype.hasChildren = function () { return this.numberOfChildren > 0; };</p><p>    Object.defineProperty(UrlSegmentGroup.prototype, "numberOfChildren", {</p><p>        /**</p><p>         * Number of child segments</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return Object.keys(this.children).length; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    /**</p><p>     * \@docsNotRequired</p><p>     * @return {?}</p><p>     */</p><p>    UrlSegmentGroup.prototype.toString = function () { return serializePaths(this); };</p><p>    return UrlSegmentGroup;</p><p>}());</p><p>/**</p><p> * \@whatItDoes Represents a single URL segment.</p><p> *</p><p> * \@howToUse</p><p> *</p><p> * ```</p><p> * \@Component({templateUrl:'template.html'})</p><p> * class MyComponent {</p><p> *   constructor(router: Router) {</p><p> *     const tree: UrlTree = router.parseUrl('/team;id=33');</p><p> *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];</p><p> *     const s: UrlSegment[] = g.segments;</p><p> *     s[0].path; // returns 'team'</p><p> *     s[0].parameters; // returns {id: 33}</p><p> *   }</p><p> * }</p><p> * ```</p><p> *</p><p> * \@description</p><p> *</p><p> * A UrlSegment is a part of a URL between the two slashes. It contains a path and the matrix</p><p> * parameters associated with the segment.</p><p> *</p><p> * \@stable</p><p> */</p><p>var UrlSegment = (function () {</p><p>    /**</p><p>     * @param {?} path</p><p>     * @param {?} parameters</p><p>     */</p><p>    function UrlSegment(path, parameters) {</p><p>        this.path = path;</p><p>        this.parameters = parameters;</p><p>    }</p><p>    Object.defineProperty(UrlSegment.prototype, "parameterMap", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () {</p><p>            if (!this._parameterMap) {</p><p>                this._parameterMap = convertToParamMap(this.parameters);</p><p>            }</p><p>            return this._parameterMap;</p><p>        },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    /**</p><p>     * \@docsNotRequired</p><p>     * @return {?}</p><p>     */</p><p>    UrlSegment.prototype.toString = function () { return serializePath(this); };</p><p>    return UrlSegment;</p><p>}());</p><p>/**</p><p> * @param {?} as</p><p> * @param {?} bs</p><p> * @return {?}</p><p> */</p><p>function equalSegments(as, bs) {</p><p>    return equalPath(as, bs) && as.every(function (a, i) { return shallowEqual(a.parameters, bs[i].parameters); });</p><p>}</p><p>/**</p><p> * @param {?} as</p><p> * @param {?} bs</p><p> * @return {?}</p><p> */</p><p>function equalPath(as, bs) {</p><p>    if (as.length !== bs.length)</p><p>        return false;</p><p>    return as.every(function (a, i) { return a.path === bs[i].path; });</p><p>}</p><p>/**</p><p> * @template T</p><p> * @param {?} segment</p><p> * @param {?} fn</p><p> * @return {?}</p><p> */</p><p>function mapChildrenIntoArray(segment, fn) {</p><p>    var /** @type {?} */ res = [];</p><p>    forEach(segment.children, function (child, childOutlet) {</p><p>        if (childOutlet === PRIMARY_OUTLET) {</p><p>            res = res.concat(fn(child, childOutlet));</p><p>        }</p><p>    });</p><p>    forEach(segment.children, function (child, childOutlet) {</p><p>        if (childOutlet !== PRIMARY_OUTLET) {</p><p>            res = res.concat(fn(child, childOutlet));</p><p>        }</p><p>    });</p><p>    return res;</p><p>}</p><p>/**</p><p> * \@whatItDoes Serializes and deserializes a URL string into a URL tree.</p><p> *</p><p> * \@description The url serialization strategy is customizable. You can</p><p> * make all URLs case insensitive by providing a custom UrlSerializer.</p><p> *</p><p> * See {\@link DefaultUrlSerializer} for an example of a URL serializer.</p><p> *</p><p> * \@stable</p><p> * @abstract</p><p> */</p><p>var UrlSerializer = (function () {</p><p>    function UrlSerializer() {</p><p>    }</p><p>    /**</p><p>     * Parse a url into a {\@link UrlTree}</p><p>     * @abstract</p><p>     * @param {?} url</p><p>     * @return {?}</p><p>     */</p><p>    UrlSerializer.prototype.parse = function (url) { };</p><p>    /**</p><p>     * Converts a {\@link UrlTree} into a url</p><p>     * @abstract</p><p>     * @param {?} tree</p><p>     * @return {?}</p><p>     */</p><p>    UrlSerializer.prototype.serialize = function (tree) { };</p><p>    return UrlSerializer;</p><p>}());</p><p>/**</p><p> * \@whatItDoes A default implementation of the {\@link UrlSerializer}.</p><p> *</p><p> * \@description</p><p> *</p><p> * Example URLs:</p><p> *</p><p> * ```</p><p> * /inbox/33(popup:compose)</p><p> * /inbox/33;open=true/messages/44</p><p> * ```</p><p> *</p><p> * DefaultUrlSerializer uses parentheses to serialize secondary segments (e.g., popup:compose), the</p><p> * colon syntax to specify the outlet, and the ';parameter=value' syntax (e.g., open=true) to</p><p> * specify route specific parameters.</p><p> *</p><p> * \@stable</p><p> */</p><p>var DefaultUrlSerializer = (function () {</p><p>    function DefaultUrlSerializer() {</p><p>    }</p><p>    /**</p><p>     * Parses a url into a {\@link UrlTree}</p><p>     * @param {?} url</p><p>     * @return {?}</p><p>     */</p><p>    DefaultUrlSerializer.prototype.parse = function (url) {</p><p>        var /** @type {?} */ p = new UrlParser(url);</p><p>        return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());</p><p>    };</p><p>    /**</p><p>     * Converts a {\@link UrlTree} into a url</p><p>     * @param {?} tree</p><p>     * @return {?}</p><p>     */</p><p>    DefaultUrlSerializer.prototype.serialize = function (tree) {</p><p>        var /** @type {?} */ segment = "/" + serializeSegment(tree.root, true);</p><p>        var /** @type {?} */ query = serializeQueryParams(tree.queryParams);</p><p>        var /** @type {?} */ fragment = typeof tree.fragment === "string" ? "#" + encodeURI(/** @type {?} */ ((tree.fragment))) : '';</p><p>        return "" + segment + query + fragment;</p><p>    };</p><p>    return DefaultUrlSerializer;</p><p>}());</p><p>var DEFAULT_SERIALIZER = new DefaultUrlSerializer();</p><p>/**</p><p> * @param {?} segment</p><p> * @return {?}</p><p> */</p><p>function serializePaths(segment) {</p><p>    return segment.segments.map(function (p) { return serializePath(p); }).join('/');</p><p>}</p><p>/**</p><p> * @param {?} segment</p><p> * @param {?} root</p><p> * @return {?}</p><p> */</p><p>function serializeSegment(segment, root) {</p><p>    if (!segment.hasChildren()) {</p><p>        return serializePaths(segment);</p><p>    }</p><p>    if (root) {</p><p>        var /** @type {?} */ primary = segment.children[PRIMARY_OUTLET] ?</p><p>            serializeSegment(segment.children[PRIMARY_OUTLET], false) :</p><p>            '';</p><p>        var /** @type {?} */ children_1 = [];</p><p>        forEach(segment.children, function (v, k) {</p><p>            if (k !== PRIMARY_OUTLET) {</p><p>                children_1.push(k + ":" + serializeSegment(v, false));</p><p>            }</p><p>        });</p><p>        return children_1.length > 0 ? primary + "(" + children_1.join('//') + ")" : primary;</p><p>    }</p><p>    else {</p><p>        var /** @type {?} */ children = mapChildrenIntoArray(segment, function (v, k) {</p><p>            if (k === PRIMARY_OUTLET) {</p><p>                return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];</p><p>            }</p><p>            return [k + ":" + serializeSegment(v, false)];</p><p>        });</p><p>        return serializePaths(segment) + "/(" + children.join('//') + ")";</p><p>    }</p><p>}</p><p>/**</p><p> * This method is intended for encoding *key* or *value* parts of query component. We need a custom</p><p> * method because encodeURIComponent is too aggressive and encodes stuff that doesn't have to be</p><p> * encoded per http://tools.ietf.org/html/rfc3986:</p><p> *    query         = *( pchar / "/" / "?" )</p><p> *    pchar         = unreserved / pct-encoded / sub-delims / ":" / "\@"</p><p> *    unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"</p><p> *    pct-encoded   = "%" HEXDIG HEXDIG</p><p> *    sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"</p><p> *                     / "*" / "+" / "," / ";" / "="</p><p> * @param {?} s</p><p> * @return {?}</p><p> */</p><p>function encode(s) {</p><p>    return encodeURIComponent(s)</p><p>        .replace(/%40/g, '@')</p><p>        .replace(/%3A/gi, ':')</p><p>        .replace(/%24/g, '$')</p><p>        .replace(/%2C/gi, ',')</p><p>        .replace(/%3B/gi, ';');</p><p>}</p><p>/**</p><p> * @param {?} s</p><p> * @return {?}</p><p> */</p><p>function decode(s) {</p><p>    return decodeURIComponent(s);</p><p>}</p><p>/**</p><p> * @param {?} path</p><p> * @return {?}</p><p> */</p><p>function serializePath(path) {</p><p>    return "" + encode(path.path) + serializeParams(path.parameters);</p><p>}</p><p>/**</p><p> * @param {?} params</p><p> * @return {?}</p><p> */</p><p>function serializeParams(params) {</p><p>    return Object.keys(params).map(function (key) { return ";" + encode(key) + "=" + encode(params[key]); }).join('');</p><p>}</p><p>/**</p><p> * @param {?} params</p><p> * @return {?}</p><p> */</p><p>function serializeQueryParams(params) {</p><p>    var /** @type {?} */ strParams = Object.keys(params).map(function (name) {</p><p>        var /** @type {?} */ value = params[name];</p><p>        return Array.isArray(value) ? value.map(function (v) { return encode(name) + "=" + encode(v); }).join('&') :</p><p>            encode(name) + "=" + encode(value);</p><p>    });</p><p>    return strParams.length ? "?" + strParams.join("&") : '';</p><p>}</p><p>var SEGMENT_RE = /^[^\/()?;=&#]+/;</p><p>/**</p><p> * @param {?} str</p><p> * @return {?}</p><p> */</p><p>function matchSegments(str) {</p><p>    var /** @type {?} */ match = str.match(SEGMENT_RE);</p><p>    return match ? match[0] : '';</p><p>}</p><p>var QUERY_PARAM_RE = /^[^=?&#]+/;</p><p>/**</p><p> * @param {?} str</p><p> * @return {?}</p><p> */</p><p>function matchQueryParams(str) {</p><p>    var /** @type {?} */ match = str.match(QUERY_PARAM_RE);</p><p>    return match ? match[0] : '';</p><p>}</p><p>var QUERY_PARAM_VALUE_RE = /^[^?&#]+/;</p><p>/**</p><p> * @param {?} str</p><p> * @return {?}</p><p> */</p><p>function matchUrlQueryParamValue(str) {</p><p>    var /** @type {?} */ match = str.match(QUERY_PARAM_VALUE_RE);</p><p>    return match ? match[0] : '';</p><p>}</p><p>var UrlParser = (function () {</p><p>    /**</p><p>     * @param {?} url</p><p>     */</p><p>    function UrlParser(url) {</p><p>        this.url = url;</p><p>        this.remaining = url;</p><p>    }</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    UrlParser.prototype.parseRootSegment = function () {</p><p>        this.consumeOptional('/');</p><p>        if (this.remaining === '' || this.peekStartsWith('?') || this.peekStartsWith('#')) {</p><p>            return new UrlSegmentGroup([], {});</p><p>        }</p><p>        // The root segment group never has segments</p><p>        return new UrlSegmentGroup([], this.parseChildren());</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    UrlParser.prototype.parseQueryParams = function () {</p><p>        var /** @type {?} */ params = {};</p><p>        if (this.consumeOptional('?')) {</p><p>            do {</p><p>                this.parseQueryParam(params);</p><p>            } while (this.consumeOptional('&'));</p><p>        }</p><p>        return params;</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    UrlParser.prototype.parseFragment = function () {</p><p>        return this.consumeOptional('#') ? decodeURI(this.remaining) : null;</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    UrlParser.prototype.parseChildren = function () {</p><p>        if (this.remaining === '') {</p><p>            return {};</p><p>        }</p><p>        this.consumeOptional('/');</p><p>        var /** @type {?} */ segments = [];</p><p>        if (!this.peekStartsWith('(')) {</p><p>            segments.push(this.parseSegment());</p><p>        }</p><p>        while (this.peekStartsWith('/') && !this.peekStartsWith('//') && !this.peekStartsWith('/(')) {</p><p>            this.capture('/');</p><p>            segments.push(this.parseSegment());</p><p>        }</p><p>        var /** @type {?} */ children = {};</p><p>        if (this.peekStartsWith('/(')) {</p><p>            this.capture('/');</p><p>            children = this.parseParens(true);</p><p>        }</p><p>        var /** @type {?} */ res = {};</p><p>        if (this.peekStartsWith('(')) {</p><p>            res = this.parseParens(false);</p><p>        }</p><p>        if (segments.length > 0 || Object.keys(children).length > 0) {</p><p>            res[PRIMARY_OUTLET] = new UrlSegmentGroup(segments, children);</p><p>        }</p><p>        return res;</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    UrlParser.prototype.parseSegment = function () {</p><p>        var /** @type {?} */ path = matchSegments(this.remaining);</p><p>        if (path === '' && this.peekStartsWith(';')) {</p><p>            throw new Error("Empty path url segment cannot have parameters: '" + this.remaining + "'.");</p><p>        }</p><p>        this.capture(path);</p><p>        return new UrlSegment(decode(path), this.parseMatrixParams());</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    UrlParser.prototype.parseMatrixParams = function () {</p><p>        var /** @type {?} */ params = {};</p><p>        while (this.consumeOptional(';')) {</p><p>            this.parseParam(params);</p><p>        }</p><p>        return params;</p><p>    };</p><p>    /**</p><p>     * @param {?} params</p><p>     * @return {?}</p><p>     */</p><p>    UrlParser.prototype.parseParam = function (params) {</p><p>        var /** @type {?} */ key = matchSegments(this.remaining);</p><p>        if (!key) {</p><p>            return;</p><p>        }</p><p>        this.capture(key);</p><p>        var /** @type {?} */ value = '';</p><p>        if (this.consumeOptional('=')) {</p><p>            var /** @type {?} */ valueMatch = matchSegments(this.remaining);</p><p>            if (valueMatch) {</p><p>                value = valueMatch;</p><p>                this.capture(value);</p><p>            }</p><p>        }</p><p>        params[decode(key)] = decode(value);</p><p>    };</p><p>    /**</p><p>     * @param {?} params</p><p>     * @return {?}</p><p>     */</p><p>    UrlParser.prototype.parseQueryParam = function (params) {</p><p>        var /** @type {?} */ key = matchQueryParams(this.remaining);</p><p>        if (!key) {</p><p>            return;</p><p>        }</p><p>        this.capture(key);</p><p>        var /** @type {?} */ value = '';</p><p>        if (this.consumeOptional('=')) {</p><p>            var /** @type {?} */ valueMatch = matchUrlQueryParamValue(this.remaining);</p><p>            if (valueMatch) {</p><p>                value = valueMatch;</p><p>                this.capture(value);</p><p>            }</p><p>        }</p><p>        var /** @type {?} */ decodedKey = decode(key);</p><p>        var /** @type {?} */ decodedVal = decode(value);</p><p>        if (params.hasOwnProperty(decodedKey)) {</p><p>            // Append to existing values</p><p>            var /** @type {?} */ currentVal = params[decodedKey];</p><p>            if (!Array.isArray(currentVal)) {</p><p>                currentVal = [currentVal];</p><p>                params[decodedKey] = currentVal;</p><p>            }</p><p>            currentVal.push(decodedVal);</p><p>        }</p><p>        else {</p><p>            // Create a new value</p><p>            params[decodedKey] = decodedVal;</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @param {?} allowPrimary</p><p>     * @return {?}</p><p>     */</p><p>    UrlParser.prototype.parseParens = function (allowPrimary) {</p><p>        var /** @type {?} */ segments = {};</p><p>        this.capture('(');</p><p>        while (!this.consumeOptional(')') && this.remaining.length > 0) {</p><p>            var /** @type {?} */ path = matchSegments(this.remaining);</p><p>            var /** @type {?} */ next = this.remaining[path.length];</p><p>            // if is is not one of these characters, then the segment was unescaped</p><p>            // or the group was not closed</p><p>            if (next !== '/' && next !== ')' && next !== ';') {</p><p>                throw new Error("Cannot parse url '" + this.url + "'");</p><p>            }</p><p>            var /** @type {?} */ outletName = ((undefined));</p><p>            if (path.indexOf(':') > -1) {</p><p>                outletName = path.substr(0, path.indexOf(':'));</p><p>                this.capture(outletName);</p><p>                this.capture(':');</p><p>            }</p><p>            else if (allowPrimary) {</p><p>                outletName = PRIMARY_OUTLET;</p><p>            }</p><p>            var /** @type {?} */ children = this.parseChildren();</p><p>            segments[outletName] = Object.keys(children).length === 1 ? children[PRIMARY_OUTLET] :</p><p>                new UrlSegmentGroup([], children);</p><p>            this.consumeOptional('//');</p><p>        }</p><p>        return segments;</p><p>    };</p><p>    /**</p><p>     * @param {?} str</p><p>     * @return {?}</p><p>     */</p><p>    UrlParser.prototype.peekStartsWith = function (str) { return this.remaining.startsWith(str); };</p><p>    /**</p><p>     * @param {?} str</p><p>     * @return {?}</p><p>     */</p><p>    UrlParser.prototype.consumeOptional = function (str) {</p><p>        if (this.peekStartsWith(str)) {</p><p>            this.remaining = this.remaining.substring(str.length);</p><p>            return true;</p><p>        }</p><p>        return false;</p><p>    };</p><p>    /**</p><p>     * @param {?} str</p><p>     * @return {?}</p><p>     */</p><p>    UrlParser.prototype.capture = function (str) {</p><p>        if (!this.consumeOptional(str)) {</p><p>            throw new Error("Expected \"" + str + "\".");</p><p>        }</p><p>    };</p><p>    return UrlParser;</p><p>}());</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>var NoMatch = (function () {</p><p>    /**</p><p>     * @param {?=} segmentGroup</p><p>     */</p><p>    function NoMatch(segmentGroup) {</p><p>        this.segmentGroup = segmentGroup || null;</p><p>    }</p><p>    return NoMatch;</p><p>}());</p><p>var AbsoluteRedirect = (function () {</p><p>    /**</p><p>     * @param {?} urlTree</p><p>     */</p><p>    function AbsoluteRedirect(urlTree) {</p><p>        this.urlTree = urlTree;</p><p>    }</p><p>    return AbsoluteRedirect;</p><p>}());</p><p>/**</p><p> * @param {?} segmentGroup</p><p> * @return {?}</p><p> */</p><p>function noMatch(segmentGroup) {</p><p>    return new __WEBPACK_IMPORTED_MODULE_14_rxjs_Observable__["Observable"](function (obs) { return obs.error(new NoMatch(segmentGroup)); });</p><p>}</p><p>/**</p><p> * @param {?} newTree</p><p> * @return {?}</p><p> */</p><p>function absoluteRedirect(newTree) {</p><p>    return new __WEBPACK_IMPORTED_MODULE_14_rxjs_Observable__["Observable"](function (obs) { return obs.error(new AbsoluteRedirect(newTree)); });</p><p>}</p><p>/**</p><p> * @param {?} redirectTo</p><p> * @return {?}</p><p> */</p><p>function namedOutletsRedirect(redirectTo) {</p><p>    return new __WEBPACK_IMPORTED_MODULE_14_rxjs_Observable__["Observable"](function (obs) { return obs.error(new Error("Only absolute redirects can have named outlets. redirectTo: '" + redirectTo + "'")); });</p><p>}</p><p>/**</p><p> * @param {?} route</p><p> * @return {?}</p><p> */</p><p>function canLoadFails(route) {</p><p>    return new __WEBPACK_IMPORTED_MODULE_14_rxjs_Observable__["Observable"](function (obs) { return obs.error(navigationCancelingError("Cannot load children because the guard of the route \"path: '" + route.path + "'\" returned false")); });</p><p>}</p><p>/**</p><p> * Returns the `UrlTree` with the redirection applied.</p><p> *</p><p> * Lazy modules are loaded along the way.</p><p> * @param {?} moduleInjector</p><p> * @param {?} configLoader</p><p> * @param {?} urlSerializer</p><p> * @param {?} urlTree</p><p> * @param {?} config</p><p> * @return {?}</p><p> */</p><p>function applyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config) {</p><p>    return new ApplyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config).apply();</p><p>}</p><p>var ApplyRedirects = (function () {</p><p>    /**</p><p>     * @param {?} moduleInjector</p><p>     * @param {?} configLoader</p><p>     * @param {?} urlSerializer</p><p>     * @param {?} urlTree</p><p>     * @param {?} config</p><p>     */</p><p>    function ApplyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config) {</p><p>        this.configLoader = configLoader;</p><p>        this.urlSerializer = urlSerializer;</p><p>        this.urlTree = urlTree;</p><p>        this.config = config;</p><p>        this.allowRedirects = true;</p><p>        this.ngModule = moduleInjector.get(__WEBPACK_IMPORTED_MODULE_2__angular_core__["NgModuleRef"]);</p><p>    }</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    ApplyRedirects.prototype.apply = function () {</p><p>        var _this = this;</p><p>        var /** @type {?} */ expanded$ = this.expandSegmentGroup(this.ngModule, this.config, this.urlTree.root, PRIMARY_OUTLET);</p><p>        var /** @type {?} */ urlTrees$ = __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(expanded$, function (rootSegmentGroup) { return _this.createUrlTree(rootSegmentGroup, _this.urlTree.queryParams, /** @type {?} */ ((_this.urlTree.fragment))); });</p><p>        return __WEBPACK_IMPORTED_MODULE_15_rxjs_operator_catch__["_catch"].call(urlTrees$, function (e) {</p><p>            if (e instanceof AbsoluteRedirect) {</p><p>                // after an absolute redirect we do not apply any more redirects!</p><p>                _this.allowRedirects = false;</p><p>                // we need to run matching, so we can fetch all lazy-loaded modules</p><p>                return _this.match(e.urlTree);</p><p>            }</p><p>            if (e instanceof NoMatch) {</p><p>                throw _this.noMatchError(e);</p><p>            }</p><p>            throw e;</p><p>        });</p><p>    };</p><p>    /**</p><p>     * @param {?} tree</p><p>     * @return {?}</p><p>     */</p><p>    ApplyRedirects.prototype.match = function (tree) {</p><p>        var _this = this;</p><p>        var /** @type {?} */ expanded$ = this.expandSegmentGroup(this.ngModule, this.config, tree.root, PRIMARY_OUTLET);</p><p>        var /** @type {?} */ mapped$ = __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(expanded$, function (rootSegmentGroup) { return _this.createUrlTree(rootSegmentGroup, tree.queryParams, /** @type {?} */ ((tree.fragment))); });</p><p>        return __WEBPACK_IMPORTED_MODULE_15_rxjs_operator_catch__["_catch"].call(mapped$, function (e) {</p><p>            if (e instanceof NoMatch) {</p><p>                throw _this.noMatchError(e);</p><p>            }</p><p>            throw e;</p><p>        });</p><p>    };</p><p>    /**</p><p>     * @param {?} e</p><p>     * @return {?}</p><p>     */</p><p>    ApplyRedirects.prototype.noMatchError = function (e) {</p><p>        return new Error("Cannot match any routes. URL Segment: '" + e.segmentGroup + "'");</p><p>    };</p><p>    /**</p><p>     * @param {?} rootCandidate</p><p>     * @param {?} queryParams</p><p>     * @param {?} fragment</p><p>     * @return {?}</p><p>     */</p><p>    ApplyRedirects.prototype.createUrlTree = function (rootCandidate, queryParams, fragment) {</p><p>        var /** @type {?} */ root = rootCandidate.segments.length > 0 ?</p><p>            new UrlSegmentGroup([], (_a = {}, _a[PRIMARY_OUTLET] = rootCandidate, _a)) :</p><p>            rootCandidate;</p><p>        return new UrlTree(root, queryParams, fragment);</p><p>        var _a;</p><p>    };</p><p>    /**</p><p>     * @param {?} ngModule</p><p>     * @param {?} routes</p><p>     * @param {?} segmentGroup</p><p>     * @param {?} outlet</p><p>     * @return {?}</p><p>     */</p><p>    ApplyRedirects.prototype.expandSegmentGroup = function (ngModule, routes, segmentGroup, outlet) {</p><p>        if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {</p><p>            return __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(this.expandChildren(ngModule, routes, segmentGroup), function (children) { return new UrlSegmentGroup([], children); });</p><p>        }</p><p>        return this.expandSegment(ngModule, segmentGroup, routes, segmentGroup.segments, outlet, true);</p><p>    };</p><p>    /**</p><p>     * @param {?} ngModule</p><p>     * @param {?} routes</p><p>     * @param {?} segmentGroup</p><p>     * @return {?}</p><p>     */</p><p>    ApplyRedirects.prototype.expandChildren = function (ngModule, routes, segmentGroup) {</p><p>        var _this = this;</p><p>        return waitForMap(segmentGroup.children, function (childOutlet, child) { return _this.expandSegmentGroup(ngModule, routes, child, childOutlet); });</p><p>    };</p><p>    /**</p><p>     * @param {?} ngModule</p><p>     * @param {?} segmentGroup</p><p>     * @param {?} routes</p><p>     * @param {?} segments</p><p>     * @param {?} outlet</p><p>     * @param {?} allowRedirects</p><p>     * @return {?}</p><p>     */</p><p>    ApplyRedirects.prototype.expandSegment = function (ngModule, segmentGroup, routes, segments, outlet, allowRedirects) {</p><p>        var _this = this;</p><p>        var /** @type {?} */ routes$ = __WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"].apply(void 0, routes);</p><p>        var /** @type {?} */ processedRoutes$ = __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(routes$, function (r) {</p><p>            var /** @type {?} */ expanded$ = _this.expandSegmentAgainstRoute(ngModule, segmentGroup, routes, r, segments, outlet, allowRedirects);</p><p>            return __WEBPACK_IMPORTED_MODULE_15_rxjs_operator_catch__["_catch"].call(expanded$, function (e) {</p><p>                if (e instanceof NoMatch) {</p><p>                    return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(null);</p><p>                }</p><p>                throw e;</p><p>            });</p><p>        });</p><p>        var /** @type {?} */ concattedProcessedRoutes$ = __WEBPACK_IMPORTED_MODULE_16_rxjs_operator_concatAll__["concatAll"].call(processedRoutes$);</p><p>        var /** @type {?} */ first$ = __WEBPACK_IMPORTED_MODULE_9_rxjs_operator_first__["first"].call(concattedProcessedRoutes$, function (s) { return !!s; });</p><p>        return __WEBPACK_IMPORTED_MODULE_15_rxjs_operator_catch__["_catch"].call(first$, function (e, _) {</p><p>            if (e instanceof __WEBPACK_IMPORTED_MODULE_17_rxjs_util_EmptyError__["EmptyError"]) {</p><p>                if (_this.noLeftoversInUrl(segmentGroup, segments, outlet)) {</p><p>                    return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(new UrlSegmentGroup([], {}));</p><p>                }</p><p>                throw new NoMatch(segmentGroup);</p><p>            }</p><p>            throw e;</p><p>        });</p><p>    };</p><p>    /**</p><p>     * @param {?} segmentGroup</p><p>     * @param {?} segments</p><p>     * @param {?} outlet</p><p>     * @return {?}</p><p>     */</p><p>    ApplyRedirects.prototype.noLeftoversInUrl = function (segmentGroup, segments, outlet) {</p><p>        return segments.length === 0 && !segmentGroup.children[outlet];</p><p>    };</p><p>    /**</p><p>     * @param {?} ngModule</p><p>     * @param {?} segmentGroup</p><p>     * @param {?} routes</p><p>     * @param {?} route</p><p>     * @param {?} paths</p><p>     * @param {?} outlet</p><p>     * @param {?} allowRedirects</p><p>     * @return {?}</p><p>     */</p><p>    ApplyRedirects.prototype.expandSegmentAgainstRoute = function (ngModule, segmentGroup, routes, route, paths, outlet, allowRedirects) {</p><p>        if (getOutlet(route) !== outlet) {</p><p>            return noMatch(segmentGroup);</p><p>        }</p><p>        if (route.redirectTo === undefined) {</p><p>            return this.matchSegmentAgainstRoute(ngModule, segmentGroup, route, paths);</p><p>        }</p><p>        if (allowRedirects && this.allowRedirects) {</p><p>            return this.expandSegmentAgainstRouteUsingRedirect(ngModule, segmentGroup, routes, route, paths, outlet);</p><p>        }</p><p>        return noMatch(segmentGroup);</p><p>    };</p><p>    /**</p><p>     * @param {?} ngModule</p><p>     * @param {?} segmentGroup</p><p>     * @param {?} routes</p><p>     * @param {?} route</p><p>     * @param {?} segments</p><p>     * @param {?} outlet</p><p>     * @return {?}</p><p>     */</p><p>    ApplyRedirects.prototype.expandSegmentAgainstRouteUsingRedirect = function (ngModule, segmentGroup, routes, route, segments, outlet) {</p><p>        if (route.path === '**') {</p><p>            return this.expandWildCardWithParamsAgainstRouteUsingRedirect(ngModule, routes, route, outlet);</p><p>        }</p><p>        return this.expandRegularSegmentAgainstRouteUsingRedirect(ngModule, segmentGroup, routes, route, segments, outlet);</p><p>    };</p><p>    /**</p><p>     * @param {?} ngModule</p><p>     * @param {?} routes</p><p>     * @param {?} route</p><p>     * @param {?} outlet</p><p>     * @return {?}</p><p>     */</p><p>    ApplyRedirects.prototype.expandWildCardWithParamsAgainstRouteUsingRedirect = function (ngModule, routes, route, outlet) {</p><p>        var _this = this;</p><p>        var /** @type {?} */ newTree = this.applyRedirectCommands([], /** @type {?} */ ((route.redirectTo)), {});</p><p>        if (((route.redirectTo)).startsWith('/')) {</p><p>            return absoluteRedirect(newTree);</p><p>        }</p><p>        return __WEBPACK_IMPORTED_MODULE_12_rxjs_operator_mergeMap__["mergeMap"].call(this.lineralizeSegments(route, newTree), function (newSegments) {</p><p>            var /** @type {?} */ group = new UrlSegmentGroup(newSegments, {});</p><p>            return _this.expandSegment(ngModule, group, routes, newSegments, outlet, false);</p><p>        });</p><p>    };</p><p>    /**</p><p>     * @param {?} ngModule</p><p>     * @param {?} segmentGroup</p><p>     * @param {?} routes</p><p>     * @param {?} route</p><p>     * @param {?} segments</p><p>     * @param {?} outlet</p><p>     * @return {?}</p><p>     */</p><p>    ApplyRedirects.prototype.expandRegularSegmentAgainstRouteUsingRedirect = function (ngModule, segmentGroup, routes, route, segments, outlet) {</p><p>        var _this = this;</p><p>        var _a = match(segmentGroup, route, segments), matched = _a.matched, consumedSegments = _a.consumedSegments, lastChild = _a.lastChild, positionalParamSegments = _a.positionalParamSegments;</p><p>        if (!matched)</p><p>            return noMatch(segmentGroup);</p><p>        var /** @type {?} */ newTree = this.applyRedirectCommands(consumedSegments, /** @type {?} */ ((route.redirectTo)), /** @type {?} */ (positionalParamSegments));</p><p>        if (((route.redirectTo)).startsWith('/')) {</p><p>            return absoluteRedirect(newTree);</p><p>        }</p><p>        return __WEBPACK_IMPORTED_MODULE_12_rxjs_operator_mergeMap__["mergeMap"].call(this.lineralizeSegments(route, newTree), function (newSegments) {</p><p>            return _this.expandSegment(ngModule, segmentGroup, routes, newSegments.concat(segments.slice(lastChild)), outlet, false);</p><p>        });</p><p>    };</p><p>    /**</p><p>     * @param {?} ngModule</p><p>     * @param {?} rawSegmentGroup</p><p>     * @param {?} route</p><p>     * @param {?} segments</p><p>     * @return {?}</p><p>     */</p><p>    ApplyRedirects.prototype.matchSegmentAgainstRoute = function (ngModule, rawSegmentGroup, route, segments) {</p><p>        var _this = this;</p><p>        if (route.path === '**') {</p><p>            if (route.loadChildren) {</p><p>                return __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(this.configLoader.load(ngModule.injector, route), function (cfg) {</p><p>                    route._loadedConfig = cfg;</p><p>                    return new UrlSegmentGroup(segments, {});</p><p>                });</p><p>            }</p><p>            return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(new UrlSegmentGroup(segments, {}));</p><p>        }</p><p>        var _a = match(rawSegmentGroup, route, segments), matched = _a.matched, consumedSegments = _a.consumedSegments, lastChild = _a.lastChild;</p><p>        if (!matched)</p><p>            return noMatch(rawSegmentGroup);</p><p>        var /** @type {?} */ rawSlicedSegments = segments.slice(lastChild);</p><p>        var /** @type {?} */ childConfig$ = this.getChildConfig(ngModule, route);</p><p>        return __WEBPACK_IMPORTED_MODULE_12_rxjs_operator_mergeMap__["mergeMap"].call(childConfig$, function (routerConfig) {</p><p>            var /** @type {?} */ childModule = routerConfig.module;</p><p>            var /** @type {?} */ childConfig = routerConfig.routes;</p><p>            var _a = split(rawSegmentGroup, consumedSegments, rawSlicedSegments, childConfig), segmentGroup = _a.segmentGroup, slicedSegments = _a.slicedSegments;</p><p>            if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {</p><p>                var /** @type {?} */ expanded$_1 = _this.expandChildren(childModule, childConfig, segmentGroup);</p><p>                return __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(expanded$_1, function (children) { return new UrlSegmentGroup(consumedSegments, children); });</p><p>            }</p><p>            if (childConfig.length === 0 && slicedSegments.length === 0) {</p><p>                return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(new UrlSegmentGroup(consumedSegments, {}));</p><p>            }</p><p>            var /** @type {?} */ expanded$ = _this.expandSegment(childModule, segmentGroup, childConfig, slicedSegments, PRIMARY_OUTLET, true);</p><p>            return __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(expanded$, function (cs) { return new UrlSegmentGroup(consumedSegments.concat(cs.segments), cs.children); });</p><p>        });</p><p>    };</p><p>    /**</p><p>     * @param {?} ngModule</p><p>     * @param {?} route</p><p>     * @return {?}</p><p>     */</p><p>    ApplyRedirects.prototype.getChildConfig = function (ngModule, route) {</p><p>        var _this = this;</p><p>        if (route.children) {</p><p>            // The children belong to the same module</p><p>            return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(new LoadedRouterConfig(route.children, ngModule));</p><p>        }</p><p>        if (route.loadChildren) {</p><p>            // lazy children belong to the loaded module</p><p>            if (route._loadedConfig !== undefined) {</p><p>                return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(route._loadedConfig);</p><p>            }</p><p>            return __WEBPACK_IMPORTED_MODULE_12_rxjs_operator_mergeMap__["mergeMap"].call(runCanLoadGuard(ngModule.injector, route), function (shouldLoad) {</p><p>                if (shouldLoad) {</p><p>                    return __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(_this.configLoader.load(ngModule.injector, route), function (cfg) {</p><p>                        route._loadedConfig = cfg;</p><p>                        return cfg;</p><p>                    });</p><p>                }</p><p>                return canLoadFails(route);</p><p>            });</p><p>        }</p><p>        return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(new LoadedRouterConfig([], ngModule));</p><p>    };</p><p>    /**</p><p>     * @param {?} route</p><p>     * @param {?} urlTree</p><p>     * @return {?}</p><p>     */</p><p>    ApplyRedirects.prototype.lineralizeSegments = function (route, urlTree) {</p><p>        var /** @type {?} */ res = [];</p><p>        var /** @type {?} */ c = urlTree.root;</p><p>        while (true) {</p><p>            res = res.concat(c.segments);</p><p>            if (c.numberOfChildren === 0) {</p><p>                return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(res);</p><p>            }</p><p>            if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {</p><p>                return namedOutletsRedirect(/** @type {?} */ ((route.redirectTo)));</p><p>            }</p><p>            c = c.children[PRIMARY_OUTLET];</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @param {?} segments</p><p>     * @param {?} redirectTo</p><p>     * @param {?} posParams</p><p>     * @return {?}</p><p>     */</p><p>    ApplyRedirects.prototype.applyRedirectCommands = function (segments, redirectTo, posParams) {</p><p>        return this.applyRedirectCreatreUrlTree(redirectTo, this.urlSerializer.parse(redirectTo), segments, posParams);</p><p>    };</p><p>    /**</p><p>     * @param {?} redirectTo</p><p>     * @param {?} urlTree</p><p>     * @param {?} segments</p><p>     * @param {?} posParams</p><p>     * @return {?}</p><p>     */</p><p>    ApplyRedirects.prototype.applyRedirectCreatreUrlTree = function (redirectTo, urlTree, segments, posParams) {</p><p>        var /** @type {?} */ newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);</p><p>        return new UrlTree(newRoot, this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams), urlTree.fragment);</p><p>    };</p><p>    /**</p><p>     * @param {?} redirectToParams</p><p>     * @param {?} actualParams</p><p>     * @return {?}</p><p>     */</p><p>    ApplyRedirects.prototype.createQueryParams = function (redirectToParams, actualParams) {</p><p>        var /** @type {?} */ res = {};</p><p>        forEach(redirectToParams, function (v, k) {</p><p>            var /** @type {?} */ copySourceValue = typeof v === 'string' && v.startsWith(':');</p><p>            if (copySourceValue) {</p><p>                var /** @type {?} */ sourceName = v.substring(1);</p><p>                res[k] = actualParams[sourceName];</p><p>            }</p><p>            else {</p><p>                res[k] = v;</p><p>            }</p><p>        });</p><p>        return res;</p><p>    };</p><p>    /**</p><p>     * @param {?} redirectTo</p><p>     * @param {?} group</p><p>     * @param {?} segments</p><p>     * @param {?} posParams</p><p>     * @return {?}</p><p>     */</p><p>    ApplyRedirects.prototype.createSegmentGroup = function (redirectTo, group, segments, posParams) {</p><p>        var _this = this;</p><p>        var /** @type {?} */ updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);</p><p>        var /** @type {?} */ children = {};</p><p>        forEach(group.children, function (child, name) {</p><p>            children[name] = _this.createSegmentGroup(redirectTo, child, segments, posParams);</p><p>        });</p><p>        return new UrlSegmentGroup(updatedSegments, children);</p><p>    };</p><p>    /**</p><p>     * @param {?} redirectTo</p><p>     * @param {?} redirectToSegments</p><p>     * @param {?} actualSegments</p><p>     * @param {?} posParams</p><p>     * @return {?}</p><p>     */</p><p>    ApplyRedirects.prototype.createSegments = function (redirectTo, redirectToSegments, actualSegments, posParams) {</p><p>        var _this = this;</p><p>        return redirectToSegments.map(function (s) { return s.path.startsWith(':') ? _this.findPosParam(redirectTo, s, posParams) :</p><p>            _this.findOrReturn(s, actualSegments); });</p><p>    };</p><p>    /**</p><p>     * @param {?} redirectTo</p><p>     * @param {?} redirectToUrlSegment</p><p>     * @param {?} posParams</p><p>     * @return {?}</p><p>     */</p><p>    ApplyRedirects.prototype.findPosParam = function (redirectTo, redirectToUrlSegment, posParams) {</p><p>        var /** @type {?} */ pos = posParams[redirectToUrlSegment.path.substring(1)];</p><p>        if (!pos)</p><p>            throw new Error("Cannot redirect to '" + redirectTo + "'. Cannot find '" + redirectToUrlSegment.path + "'.");</p><p>        return pos;</p><p>    };</p><p>    /**</p><p>     * @param {?} redirectToUrlSegment</p><p>     * @param {?} actualSegments</p><p>     * @return {?}</p><p>     */</p><p>    ApplyRedirects.prototype.findOrReturn = function (redirectToUrlSegment, actualSegments) {</p><p>        var /** @type {?} */ idx = 0;</p><p>        for (var _i = 0, actualSegments_1 = actualSegments; _i < actualSegments_1.length; _i++) {</p><p>            var s = actualSegments_1[_i];</p><p>            if (s.path === redirectToUrlSegment.path) {</p><p>                actualSegments.splice(idx);</p><p>                return s;</p><p>            }</p><p>            idx++;</p><p>        }</p><p>        return redirectToUrlSegment;</p><p>    };</p><p>    return ApplyRedirects;</p><p>}());</p><p>/**</p><p> * @param {?} moduleInjector</p><p> * @param {?} route</p><p> * @return {?}</p><p> */</p><p>function runCanLoadGuard(moduleInjector, route) {</p><p>    var /** @type {?} */ canLoad = route.canLoad;</p><p>    if (!canLoad || canLoad.length === 0)</p><p>        return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(true);</p><p>    var /** @type {?} */ obs = __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_from__["from"])(canLoad), function (injectionToken) {</p><p>        var /** @type {?} */ guard = moduleInjector.get(injectionToken);</p><p>        return wrapIntoObservable(guard.canLoad ? guard.canLoad(route) : guard(route));</p><p>    });</p><p>    return andObservables(obs);</p><p>}</p><p>/**</p><p> * @param {?} segmentGroup</p><p> * @param {?} route</p><p> * @param {?} segments</p><p> * @return {?}</p><p> */</p><p>function match(segmentGroup, route, segments) {</p><p>    if (route.path === '') {</p><p>        if ((route.pathMatch === 'full') && (segmentGroup.hasChildren() || segments.length > 0)) {</p><p>            return { matched: false, consumedSegments: [], lastChild: 0, positionalParamSegments: {} };</p><p>        }</p><p>        return { matched: true, consumedSegments: [], lastChild: 0, positionalParamSegments: {} };</p><p>    }</p><p>    var /** @type {?} */ matcher = route.matcher || defaultUrlMatcher;</p><p>    var /** @type {?} */ res = matcher(segments, segmentGroup, route);</p><p>    if (!res) {</p><p>        return {</p><p>            matched: false,</p><p>            consumedSegments: /** @type {?} */ ([]),</p><p>            lastChild: 0,</p><p>            positionalParamSegments: {},</p><p>        };</p><p>    }</p><p>    return {</p><p>        matched: true,</p><p>        consumedSegments: /** @type {?} */ ((res.consumed)),</p><p>        lastChild: /** @type {?} */ ((res.consumed.length)),</p><p>        positionalParamSegments: /** @type {?} */ ((res.posParams)),</p><p>    };</p><p>}</p><p>/**</p><p> * @param {?} segmentGroup</p><p> * @param {?} consumedSegments</p><p> * @param {?} slicedSegments</p><p> * @param {?} config</p><p> * @return {?}</p><p> */</p><p>function split(segmentGroup, consumedSegments, slicedSegments, config) {</p><p>    if (slicedSegments.length > 0 &&</p><p>        containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, slicedSegments, config)) {</p><p>        var /** @type {?} */ s = new UrlSegmentGroup(consumedSegments, createChildrenForEmptySegments(config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));</p><p>        return { segmentGroup: mergeTrivialChildren(s), slicedSegments: [] };</p><p>    }</p><p>    if (slicedSegments.length === 0 &&</p><p>        containsEmptyPathRedirects(segmentGroup, slicedSegments, config)) {</p><p>        var /** @type {?} */ s = new UrlSegmentGroup(segmentGroup.segments, addEmptySegmentsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children));</p><p>        return { segmentGroup: mergeTrivialChildren(s), slicedSegments: slicedSegments };</p><p>    }</p><p>    return { segmentGroup: segmentGroup, slicedSegments: slicedSegments };</p><p>}</p><p>/**</p><p> * @param {?} s</p><p> * @return {?}</p><p> */</p><p>function mergeTrivialChildren(s) {</p><p>    if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {</p><p>        var /** @type {?} */ c = s.children[PRIMARY_OUTLET];</p><p>        return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);</p><p>    }</p><p>    return s;</p><p>}</p><p>/**</p><p> * @param {?} segmentGroup</p><p> * @param {?} slicedSegments</p><p> * @param {?} routes</p><p> * @param {?} children</p><p> * @return {?}</p><p> */</p><p>function addEmptySegmentsToChildrenIfNeeded(segmentGroup, slicedSegments, routes, children) {</p><p>    var /** @type {?} */ res = {};</p><p>    for (var _i = 0, routes_1 = routes; _i < routes_1.length; _i++) {</p><p>        var r = routes_1[_i];</p><p>        if (isEmptyPathRedirect(segmentGroup, slicedSegments, r) && !children[getOutlet(r)]) {</p><p>            res[getOutlet(r)] = new UrlSegmentGroup([], {});</p><p>        }</p><p>    }</p><p>    return Object.assign({}, children, res);</p><p>}</p><p>/**</p><p> * @param {?} routes</p><p> * @param {?} primarySegmentGroup</p><p> * @return {?}</p><p> */</p><p>function createChildrenForEmptySegments(routes, primarySegmentGroup) {</p><p>    var /** @type {?} */ res = {};</p><p>    res[PRIMARY_OUTLET] = primarySegmentGroup;</p><p>    for (var _i = 0, routes_2 = routes; _i < routes_2.length; _i++) {</p><p>        var r = routes_2[_i];</p><p>        if (r.path === '' && getOutlet(r) !== PRIMARY_OUTLET) {</p><p>            res[getOutlet(r)] = new UrlSegmentGroup([], {});</p><p>        }</p><p>    }</p><p>    return res;</p><p>}</p><p>/**</p><p> * @param {?} segmentGroup</p><p> * @param {?} segments</p><p> * @param {?} routes</p><p> * @return {?}</p><p> */</p><p>function containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, segments, routes) {</p><p>    return routes.some(function (r) { return isEmptyPathRedirect(segmentGroup, segments, r) && getOutlet(r) !== PRIMARY_OUTLET; });</p><p>}</p><p>/**</p><p> * @param {?} segmentGroup</p><p> * @param {?} segments</p><p> * @param {?} routes</p><p> * @return {?}</p><p> */</p><p>function containsEmptyPathRedirects(segmentGroup, segments, routes) {</p><p>    return routes.some(function (r) { return isEmptyPathRedirect(segmentGroup, segments, r); });</p><p>}</p><p>/**</p><p> * @param {?} segmentGroup</p><p> * @param {?} segments</p><p> * @param {?} r</p><p> * @return {?}</p><p> */</p><p>function isEmptyPathRedirect(segmentGroup, segments, r) {</p><p>    if ((segmentGroup.hasChildren() || segments.length > 0) && r.pathMatch === 'full') {</p><p>        return false;</p><p>    }</p><p>    return r.path === '' && r.redirectTo !== undefined;</p><p>}</p><p>/**</p><p> * @param {?} route</p><p> * @return {?}</p><p> */</p><p>function getOutlet(route) {</p><p>    return route.outlet || PRIMARY_OUTLET;</p><p>}</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>var Tree = (function () {</p><p>    /**</p><p>     * @param {?} root</p><p>     */</p><p>    function Tree(root) {</p><p>        this._root = root;</p><p>    }</p><p>    Object.defineProperty(Tree.prototype, "root", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this._root.value; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    /**</p><p>     * \@internal</p><p>     * @param {?} t</p><p>     * @return {?}</p><p>     */</p><p>    Tree.prototype.parent = function (t) {</p><p>        var /** @type {?} */ p = this.pathFromRoot(t);</p><p>        return p.length > 1 ? p[p.length - 2] : null;</p><p>    };</p><p>    /**</p><p>     * \@internal</p><p>     * @param {?} t</p><p>     * @return {?}</p><p>     */</p><p>    Tree.prototype.children = function (t) {</p><p>        var /** @type {?} */ n = findNode(t, this._root);</p><p>        return n ? n.children.map(function (t) { return t.value; }) : [];</p><p>    };</p><p>    /**</p><p>     * \@internal</p><p>     * @param {?} t</p><p>     * @return {?}</p><p>     */</p><p>    Tree.prototype.firstChild = function (t) {</p><p>        var /** @type {?} */ n = findNode(t, this._root);</p><p>        return n && n.children.length > 0 ? n.children[0].value : null;</p><p>    };</p><p>    /**</p><p>     * \@internal</p><p>     * @param {?} t</p><p>     * @return {?}</p><p>     */</p><p>    Tree.prototype.siblings = function (t) {</p><p>        var /** @type {?} */ p = findPath(t, this._root);</p><p>        if (p.length < 2)</p><p>            return [];</p><p>        var /** @type {?} */ c = p[p.length - 2].children.map(function (c) { return c.value; });</p><p>        return c.filter(function (cc) { return cc !== t; });</p><p>    };</p><p>    /**</p><p>     * \@internal</p><p>     * @param {?} t</p><p>     * @return {?}</p><p>     */</p><p>    Tree.prototype.pathFromRoot = function (t) { return findPath(t, this._root).map(function (s) { return s.value; }); };</p><p>    return Tree;</p><p>}());</p><p>/**</p><p> * @template T</p><p> * @param {?} value</p><p> * @param {?} node</p><p> * @return {?}</p><p> */</p><p>function findNode(value, node) {</p><p>    if (value === node.value)</p><p>        return node;</p><p>    for (var _i = 0, _a = node.children; _i < _a.length; _i++) {</p><p>        var child = _a[_i];</p><p>        var /** @type {?} */ node_1 = findNode(value, child);</p><p>        if (node_1)</p><p>            return node_1;</p><p>    }</p><p>    return null;</p><p>}</p><p>/**</p><p> * @template T</p><p> * @param {?} value</p><p> * @param {?} node</p><p> * @return {?}</p><p> */</p><p>function findPath(value, node) {</p><p>    if (value === node.value)</p><p>        return [node];</p><p>    for (var _i = 0, _a = node.children; _i < _a.length; _i++) {</p><p>        var child = _a[_i];</p><p>        var /** @type {?} */ path = findPath(value, child);</p><p>        if (path.length) {</p><p>            path.unshift(node);</p><p>            return path;</p><p>        }</p><p>    }</p><p>    return [];</p><p>}</p><p>var TreeNode = (function () {</p><p>    /**</p><p>     * @param {?} value</p><p>     * @param {?} children</p><p>     */</p><p>    function TreeNode(value, children) {</p><p>        this.value = value;</p><p>        this.children = children;</p><p>    }</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    TreeNode.prototype.toString = function () { return "TreeNode(" + this.value + ")"; };</p><p>    return TreeNode;</p><p>}());</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * \@whatItDoes Represents the state of the router.</p><p> *</p><p> * \@howToUse</p><p> *</p><p> * ```</p><p> * \@Component({templateUrl:'template.html'})</p><p> * class MyComponent {</p><p> *   constructor(router: Router) {</p><p> *     const state: RouterState = router.routerState;</p><p> *     const root: ActivatedRoute = state.root;</p><p> *     const child = root.firstChild;</p><p> *     const id: Observable<string> = child.params.map(p => p.id);</p><p> *     //...</p><p> *   }</p><p> * }</p><p> * ```</p><p> *</p><p> * \@description</p><p> * RouterState is a tree of activated routes. Every node in this tree knows about the "consumed" URL</p><p> * segments, the extracted parameters, and the resolved data.</p><p> *</p><p> * See {\@link ActivatedRoute} for more information.</p><p> *</p><p> * \@stable</p><p> */</p><p>var RouterState = (function (_super) {</p><p>    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](RouterState, _super);</p><p>    /**</p><p>     * \@internal</p><p>     * @param {?} root</p><p>     * @param {?} snapshot</p><p>     */</p><p>    function RouterState(root, snapshot) {</p><p>        var _this = _super.call(this, root) || this;</p><p>        _this.snapshot = snapshot;</p><p>        setRouterState(_this, root);</p><p>        return _this;</p><p>    }</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    RouterState.prototype.toString = function () { return this.snapshot.toString(); };</p><p>    return RouterState;</p><p>}(Tree));</p><p>/**</p><p> * @param {?} urlTree</p><p> * @param {?} rootComponent</p><p> * @return {?}</p><p> */</p><p>function createEmptyState(urlTree, rootComponent) {</p><p>    var /** @type {?} */ snapshot = createEmptyStateSnapshot(urlTree, rootComponent);</p><p>    var /** @type {?} */ emptyUrl = new __WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject__["BehaviorSubject"]([new UrlSegment('', {})]);</p><p>    var /** @type {?} */ emptyParams = new __WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject__["BehaviorSubject"]({});</p><p>    var /** @type {?} */ emptyData = new __WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject__["BehaviorSubject"]({});</p><p>    var /** @type {?} */ emptyQueryParams = new __WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject__["BehaviorSubject"]({});</p><p>    var /** @type {?} */ fragment = new __WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject__["BehaviorSubject"]('');</p><p>    var /** @type {?} */ activated = new ActivatedRoute(emptyUrl, emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, snapshot.root);</p><p>    activated.snapshot = snapshot.root;</p><p>    return new RouterState(new TreeNode(activated, []), snapshot);</p><p>}</p><p>/**</p><p> * @param {?} urlTree</p><p> * @param {?} rootComponent</p><p> * @return {?}</p><p> */</p><p>function createEmptyStateSnapshot(urlTree, rootComponent) {</p><p>    var /** @type {?} */ emptyParams = {};</p><p>    var /** @type {?} */ emptyData = {};</p><p>    var /** @type {?} */ emptyQueryParams = {};</p><p>    var /** @type {?} */ fragment = '';</p><p>    var /** @type {?} */ activated = new ActivatedRouteSnapshot([], emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, null, urlTree.root, -1, {});</p><p>    return new RouterStateSnapshot('', new TreeNode(activated, []));</p><p>}</p><p>/**</p><p> * \@whatItDoes Contains the information about a route associated with a component loaded in an</p><p> * outlet.</p><p> * An `ActivatedRoute` can also be used to traverse the router state tree.</p><p> *</p><p> * \@howToUse</p><p> *</p><p> * ```</p><p> * \@Component({...})</p><p> * class MyComponent {</p><p> *   constructor(route: ActivatedRoute) {</p><p> *     const id: Observable<string> = route.params.map(p => p.id);</p><p> *     const url: Observable<string> = route.url.map(segments => segments.join(''));</p><p> *     // route.data includes both `data` and `resolve`</p><p> *     const user = route.data.map(d => d.user);</p><p> *   }</p><p> * }</p><p> * ```</p><p> *</p><p> * \@stable</p><p> */</p><p>var ActivatedRoute = (function () {</p><p>    /**</p><p>     * \@internal</p><p>     * @param {?} url</p><p>     * @param {?} params</p><p>     * @param {?} queryParams</p><p>     * @param {?} fragment</p><p>     * @param {?} data</p><p>     * @param {?} outlet</p><p>     * @param {?} component</p><p>     * @param {?} futureSnapshot</p><p>     */</p><p>    function ActivatedRoute(url, params, queryParams, fragment, data, outlet, component, futureSnapshot) {</p><p>        this.url = url;</p><p>        this.params = params;</p><p>        this.queryParams = queryParams;</p><p>        this.fragment = fragment;</p><p>        this.data = data;</p><p>        this.outlet = outlet;</p><p>        this.component = component;</p><p>        this._futureSnapshot = futureSnapshot;</p><p>    }</p><p>    Object.defineProperty(ActivatedRoute.prototype, "routeConfig", {</p><p>        /**</p><p>         * The configuration used to match this route</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this._futureSnapshot.routeConfig; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(ActivatedRoute.prototype, "root", {</p><p>        /**</p><p>         * The root of the router state</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this._routerState.root; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(ActivatedRoute.prototype, "parent", {</p><p>        /**</p><p>         * The parent of this route in the router state tree</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this._routerState.parent(this); },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(ActivatedRoute.prototype, "firstChild", {</p><p>        /**</p><p>         * The first child of this route in the router state tree</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this._routerState.firstChild(this); },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(ActivatedRoute.prototype, "children", {</p><p>        /**</p><p>         * The children of this route in the router state tree</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this._routerState.children(this); },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(ActivatedRoute.prototype, "pathFromRoot", {</p><p>        /**</p><p>         * The path from the root of the router state tree to this route</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this._routerState.pathFromRoot(this); },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(ActivatedRoute.prototype, "paramMap", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () {</p><p>            if (!this._paramMap) {</p><p>                this._paramMap = __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(this.params, function (p) { return convertToParamMap(p); });</p><p>            }</p><p>            return this._paramMap;</p><p>        },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(ActivatedRoute.prototype, "queryParamMap", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () {</p><p>            if (!this._queryParamMap) {</p><p>                this._queryParamMap =</p><p>                    __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(this.queryParams, function (p) { return convertToParamMap(p); });</p><p>            }</p><p>            return this._queryParamMap;</p><p>        },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    ActivatedRoute.prototype.toString = function () {</p><p>        return this.snapshot ? this.snapshot.toString() : "Future(" + this._futureSnapshot + ")";</p><p>    };</p><p>    return ActivatedRoute;</p><p>}());</p><p>/**</p><p> * \@internal</p><p> * @param {?} route</p><p> * @return {?}</p><p> */</p><p>function inheritedParamsDataResolve(route) {</p><p>    var /** @type {?} */ pathToRoot = route.pathFromRoot;</p><p>    var /** @type {?} */ inhertingStartingFrom = pathToRoot.length - 1;</p><p>    while (inhertingStartingFrom >= 1) {</p><p>        var /** @type {?} */ current = pathToRoot[inhertingStartingFrom];</p><p>        var /** @type {?} */ parent = pathToRoot[inhertingStartingFrom - 1];</p><p>        // current route is an empty path => inherits its parent's params and data</p><p>        if (current.routeConfig && current.routeConfig.path === '') {</p><p>            inhertingStartingFrom--;</p><p>            // parent is componentless => current route should inherit its params and data</p><p>        }</p><p>        else if (!parent.component) {</p><p>            inhertingStartingFrom--;</p><p>        }</p><p>        else {</p><p>            break;</p><p>        }</p><p>    }</p><p>    return pathToRoot.slice(inhertingStartingFrom).reduce(function (res, curr) {</p><p>        var /** @type {?} */ params = Object.assign({}, res.params, curr.params);</p><p>        var /** @type {?} */ data = Object.assign({}, res.data, curr.data);</p><p>        var /** @type {?} */ resolve = Object.assign({}, res.resolve, curr._resolvedData);</p><p>        return { params: params, data: data, resolve: resolve };</p><p>    }, /** @type {?} */ ({ params: {}, data: {}, resolve: {} }));</p><p>}</p><p>/**</p><p> * \@whatItDoes Contains the information about a route associated with a component loaded in an</p><p> * outlet</p><p> * at a particular moment in time. ActivatedRouteSnapshot can also be used to traverse the router</p><p> * state tree.</p><p> *</p><p> * \@howToUse</p><p> *</p><p> * ```</p><p> * \@Component({templateUrl:'./my-component.html'})</p><p> * class MyComponent {</p><p> *   constructor(route: ActivatedRoute) {</p><p> *     const id: string = route.snapshot.params.id;</p><p> *     const url: string = route.snapshot.url.join('');</p><p> *     const user = route.snapshot.data.user;</p><p> *   }</p><p> * }</p><p> * ```</p><p> *</p><p> * \@stable</p><p> */</p><p>var ActivatedRouteSnapshot = (function () {</p><p>    /**</p><p>     * \@internal</p><p>     * @param {?} url</p><p>     * @param {?} params</p><p>     * @param {?} queryParams</p><p>     * @param {?} fragment</p><p>     * @param {?} data</p><p>     * @param {?} outlet</p><p>     * @param {?} component</p><p>     * @param {?} routeConfig</p><p>     * @param {?} urlSegment</p><p>     * @param {?} lastPathIndex</p><p>     * @param {?} resolve</p><p>     */</p><p>    function ActivatedRouteSnapshot(url, params, queryParams, fragment, data, outlet, component, routeConfig, urlSegment, lastPathIndex, resolve) {</p><p>        this.url = url;</p><p>        this.params = params;</p><p>        this.queryParams = queryParams;</p><p>        this.fragment = fragment;</p><p>        this.data = data;</p><p>        this.outlet = outlet;</p><p>        this.component = component;</p><p>        this._routeConfig = routeConfig;</p><p>        this._urlSegment = urlSegment;</p><p>        this._lastPathIndex = lastPathIndex;</p><p>        this._resolve = resolve;</p><p>    }</p><p>    Object.defineProperty(ActivatedRouteSnapshot.prototype, "routeConfig", {</p><p>        /**</p><p>         * The configuration used to match this route</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this._routeConfig; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(ActivatedRouteSnapshot.prototype, "root", {</p><p>        /**</p><p>         * The root of the router state</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this._routerState.root; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(ActivatedRouteSnapshot.prototype, "parent", {</p><p>        /**</p><p>         * The parent of this route in the router state tree</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this._routerState.parent(this); },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(ActivatedRouteSnapshot.prototype, "firstChild", {</p><p>        /**</p><p>         * The first child of this route in the router state tree</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this._routerState.firstChild(this); },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(ActivatedRouteSnapshot.prototype, "children", {</p><p>        /**</p><p>         * The children of this route in the router state tree</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this._routerState.children(this); },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(ActivatedRouteSnapshot.prototype, "pathFromRoot", {</p><p>        /**</p><p>         * The path from the root of the router state tree to this route</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this._routerState.pathFromRoot(this); },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(ActivatedRouteSnapshot.prototype, "paramMap", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () {</p><p>            if (!this._paramMap) {</p><p>                this._paramMap = convertToParamMap(this.params);</p><p>            }</p><p>            return this._paramMap;</p><p>        },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(ActivatedRouteSnapshot.prototype, "queryParamMap", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () {</p><p>            if (!this._queryParamMap) {</p><p>                this._queryParamMap = convertToParamMap(this.queryParams);</p><p>            }</p><p>            return this._queryParamMap;</p><p>        },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    ActivatedRouteSnapshot.prototype.toString = function () {</p><p>        var /** @type {?} */ url = this.url.map(function (segment) { return segment.toString(); }).join('/');</p><p>        var /** @type {?} */ matched = this._routeConfig ? this._routeConfig.path : '';</p><p>        return "Route(url:'" + url + "', path:'" + matched + "')";</p><p>    };</p><p>    return ActivatedRouteSnapshot;</p><p>}());</p><p>/**</p><p> * \@whatItDoes Represents the state of the router at a moment in time.</p><p> *</p><p> * \@howToUse</p><p> *</p><p> * ```</p><p> * \@Component({templateUrl:'template.html'})</p><p> * class MyComponent {</p><p> *   constructor(router: Router) {</p><p> *     const state: RouterState = router.routerState;</p><p> *     const snapshot: RouterStateSnapshot = state.snapshot;</p><p> *     const root: ActivatedRouteSnapshot = snapshot.root;</p><p> *     const child = root.firstChild;</p><p> *     const id: Observable<string> = child.params.map(p => p.id);</p><p> *     //...</p><p> *   }</p><p> * }</p><p> * ```</p><p> *</p><p> * \@description</p><p> * RouterStateSnapshot is a tree of activated route snapshots. Every node in this tree knows about</p><p> * the "consumed" URL segments, the extracted parameters, and the resolved data.</p><p> *</p><p> * \@stable</p><p> */</p><p>var RouterStateSnapshot = (function (_super) {</p><p>    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](RouterStateSnapshot, _super);</p><p>    /**</p><p>     * \@internal</p><p>     * @param {?} url</p><p>     * @param {?} root</p><p>     */</p><p>    function RouterStateSnapshot(url, root) {</p><p>        var _this = _super.call(this, root) || this;</p><p>        _this.url = url;</p><p>        setRouterState(_this, root);</p><p>        return _this;</p><p>    }</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    RouterStateSnapshot.prototype.toString = function () { return serializeNode(this._root); };</p><p>    return RouterStateSnapshot;</p><p>}(Tree));</p><p>/**</p><p> * @template U, T</p><p> * @param {?} state</p><p> * @param {?} node</p><p> * @return {?}</p><p> */</p><p>function setRouterState(state, node) {</p><p>    node.value._routerState = state;</p><p>    node.children.forEach(function (c) { return setRouterState(state, c); });</p><p>}</p><p>/**</p><p> * @param {?} node</p><p> * @return {?}</p><p> */</p><p>function serializeNode(node) {</p><p>    var /** @type {?} */ c = node.children.length > 0 ? " { " + node.children.map(serializeNode).join(", ") + " } " : '';</p><p>    return "" + node.value + c;</p><p>}</p><p>/**</p><p> * The expectation is that the activate route is created with the right set of parameters.</p><p> * So we push new values into the observables only when they are not the initial values.</p><p> * And we detect that by checking if the snapshot field is set.</p><p> * @param {?} route</p><p> * @return {?}</p><p> */</p><p>function advanceActivatedRoute(route) {</p><p>    if (route.snapshot) {</p><p>        var /** @type {?} */ currentSnapshot = route.snapshot;</p><p>        var /** @type {?} */ nextSnapshot = route._futureSnapshot;</p><p>        route.snapshot = nextSnapshot;</p><p>        if (!shallowEqual(currentSnapshot.queryParams, nextSnapshot.queryParams)) {</p><p>            ((route.queryParams)).next(nextSnapshot.queryParams);</p><p>        }</p><p>        if (currentSnapshot.fragment !== nextSnapshot.fragment) {</p><p>            ((route.fragment)).next(nextSnapshot.fragment);</p><p>        }</p><p>        if (!shallowEqual(currentSnapshot.params, nextSnapshot.params)) {</p><p>            ((route.params)).next(nextSnapshot.params);</p><p>        }</p><p>        if (!shallowEqualArrays(currentSnapshot.url, nextSnapshot.url)) {</p><p>            ((route.url)).next(nextSnapshot.url);</p><p>        }</p><p>        if (!shallowEqual(currentSnapshot.data, nextSnapshot.data)) {</p><p>            ((route.data)).next(nextSnapshot.data);</p><p>        }</p><p>    }</p><p>    else {</p><p>        route.snapshot = route._futureSnapshot;</p><p>        // this is for resolved data</p><p>        ((route.data)).next(route._futureSnapshot.data);</p><p>    }</p><p>}</p><p>/**</p><p> * @param {?} a</p><p> * @param {?} b</p><p> * @return {?}</p><p> */</p><p>function equalParamsAndUrlSegments(a, b) {</p><p>    var /** @type {?} */ equalUrlParams = shallowEqual(a.params, b.params) && equalSegments(a.url, b.url);</p><p>    var /** @type {?} */ parentsMismatch = !a.parent !== !b.parent;</p><p>    return equalUrlParams && !parentsMismatch &&</p><p>        (!a.parent || equalParamsAndUrlSegments(a.parent, /** @type {?} */ ((b.parent))));</p><p>}</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * @param {?} routeReuseStrategy</p><p> * @param {?} curr</p><p> * @param {?} prevState</p><p> * @return {?}</p><p> */</p><p>function createRouterState(routeReuseStrategy, curr, prevState) {</p><p>    var /** @type {?} */ root = createNode(routeReuseStrategy, curr._root, prevState ? prevState._root : undefined);</p><p>    return new RouterState(root, curr);</p><p>}</p><p>/**</p><p> * @param {?} routeReuseStrategy</p><p> * @param {?} curr</p><p> * @param {?=} prevState</p><p> * @return {?}</p><p> */</p><p>function createNode(routeReuseStrategy, curr, prevState) {</p><p>    // reuse an activated route that is currently displayed on the screen</p><p>    if (prevState && routeReuseStrategy.shouldReuseRoute(curr.value, prevState.value.snapshot)) {</p><p>        var /** @type {?} */ value = prevState.value;</p><p>        value._futureSnapshot = curr.value;</p><p>        var /** @type {?} */ children = createOrReuseChildren(routeReuseStrategy, curr, prevState);</p><p>        return new TreeNode(value, children);</p><p>        // retrieve an activated route that is used to be displayed, but is not currently displayed</p><p>    }</p><p>    else if (routeReuseStrategy.retrieve(curr.value)) {</p><p>        var /** @type {?} */ tree_1 = ((routeReuseStrategy.retrieve(curr.value))).route;</p><p>        setFutureSnapshotsOfActivatedRoutes(curr, tree_1);</p><p>        return tree_1;</p><p>    }</p><p>    else {</p><p>        var /** @type {?} */ value = createActivatedRoute(curr.value);</p><p>        var /** @type {?} */ children = curr.children.map(function (c) { return createNode(routeReuseStrategy, c); });</p><p>        return new TreeNode(value, children);</p><p>    }</p><p>}</p><p>/**</p><p> * @param {?} curr</p><p> * @param {?} result</p><p> * @return {?}</p><p> */</p><p>function setFutureSnapshotsOfActivatedRoutes(curr, result) {</p><p>    if (curr.value.routeConfig !== result.value.routeConfig) {</p><p>        throw new Error('Cannot reattach ActivatedRouteSnapshot created from a different route');</p><p>    }</p><p>    if (curr.children.length !== result.children.length) {</p><p>        throw new Error('Cannot reattach ActivatedRouteSnapshot with a different number of children');</p><p>    }</p><p>    result.value._futureSnapshot = curr.value;</p><p>    for (var /** @type {?} */ i = 0; i < curr.children.length; ++i) {</p><p>        setFutureSnapshotsOfActivatedRoutes(curr.children[i], result.children[i]);</p><p>    }</p><p>}</p><p>/**</p><p> * @param {?} routeReuseStrategy</p><p> * @param {?} curr</p><p> * @param {?} prevState</p><p> * @return {?}</p><p> */</p><p>function createOrReuseChildren(routeReuseStrategy, curr, prevState) {</p><p>    return curr.children.map(function (child) {</p><p>        for (var _i = 0, _a = prevState.children; _i < _a.length; _i++) {</p><p>            var p = _a[_i];</p><p>            if (routeReuseStrategy.shouldReuseRoute(p.value.snapshot, child.value)) {</p><p>                return createNode(routeReuseStrategy, child, p);</p><p>            }</p><p>        }</p><p>        return createNode(routeReuseStrategy, child);</p><p>    });</p><p>}</p><p>/**</p><p> * @param {?} c</p><p> * @return {?}</p><p> */</p><p>function createActivatedRoute(c) {</p><p>    return new ActivatedRoute(new __WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject__["BehaviorSubject"](c.url), new __WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject__["BehaviorSubject"](c.params), new __WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject__["BehaviorSubject"](c.queryParams), new __WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject__["BehaviorSubject"](c.fragment), new __WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject__["BehaviorSubject"](c.data), c.outlet, c.component, c);</p><p>}</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * @param {?} route</p><p> * @param {?} urlTree</p><p> * @param {?} commands</p><p> * @param {?} queryParams</p><p> * @param {?} fragment</p><p> * @return {?}</p><p> */</p><p>function createUrlTree(route, urlTree, commands, queryParams, fragment) {</p><p>    if (commands.length === 0) {</p><p>        return tree(urlTree.root, urlTree.root, urlTree, queryParams, fragment);</p><p>    }</p><p>    var /** @type {?} */ nav = computeNavigation(commands);</p><p>    if (nav.toRoot()) {</p><p>        return tree(urlTree.root, new UrlSegmentGroup([], {}), urlTree, queryParams, fragment);</p><p>    }</p><p>    var /** @type {?} */ startingPosition = findStartingPosition(nav, urlTree, route);</p><p>    var /** @type {?} */ segmentGroup = startingPosition.processChildren ?</p><p>        updateSegmentGroupChildren(startingPosition.segmentGroup, startingPosition.index, nav.commands) :</p><p>        updateSegmentGroup(startingPosition.segmentGroup, startingPosition.index, nav.commands);</p><p>    return tree(startingPosition.segmentGroup, segmentGroup, urlTree, queryParams, fragment);</p><p>}</p><p>/**</p><p> * @param {?} command</p><p> * @return {?}</p><p> */</p><p>function isMatrixParams(command) {</p><p>    return typeof command === 'object' && command != null && !command.outlets && !command.segmentPath;</p><p>}</p><p>/**</p><p> * @param {?} oldSegmentGroup</p><p> * @param {?} newSegmentGroup</p><p> * @param {?} urlTree</p><p> * @param {?} queryParams</p><p> * @param {?} fragment</p><p> * @return {?}</p><p> */</p><p>function tree(oldSegmentGroup, newSegmentGroup, urlTree, queryParams, fragment) {</p><p>    var /** @type {?} */ qp = {};</p><p>    if (queryParams) {</p><p>        forEach(queryParams, function (value, name) {</p><p>            qp[name] = Array.isArray(value) ? value.map(function (v) { return "" + v; }) : "" + value;</p><p>        });</p><p>    }</p><p>    if (urlTree.root === oldSegmentGroup) {</p><p>        return new UrlTree(newSegmentGroup, qp, fragment);</p><p>    }</p><p>    return new UrlTree(replaceSegment(urlTree.root, oldSegmentGroup, newSegmentGroup), qp, fragment);</p><p>}</p><p>/**</p><p> * @param {?} current</p><p> * @param {?} oldSegment</p><p> * @param {?} newSegment</p><p> * @return {?}</p><p> */</p><p>function replaceSegment(current, oldSegment, newSegment) {</p><p>    var /** @type {?} */ children = {};</p><p>    forEach(current.children, function (c, outletName) {</p><p>        if (c === oldSegment) {</p><p>            children[outletName] = newSegment;</p><p>        }</p><p>        else {</p><p>            children[outletName] = replaceSegment(c, oldSegment, newSegment);</p><p>        }</p><p>    });</p><p>    return new UrlSegmentGroup(current.segments, children);</p><p>}</p><p>var Navigation = (function () {</p><p>    /**</p><p>     * @param {?} isAbsolute</p><p>     * @param {?} numberOfDoubleDots</p><p>     * @param {?} commands</p><p>     */</p><p>    function Navigation(isAbsolute, numberOfDoubleDots, commands) {</p><p>        this.isAbsolute = isAbsolute;</p><p>        this.numberOfDoubleDots = numberOfDoubleDots;</p><p>        this.commands = commands;</p><p>        if (isAbsolute && commands.length > 0 && isMatrixParams(commands[0])) {</p><p>            throw new Error('Root segment cannot have matrix parameters');</p><p>        }</p><p>        var cmdWithOutlet = commands.find(function (c) { return typeof c === 'object' && c != null && c.outlets; });</p><p>        if (cmdWithOutlet && cmdWithOutlet !== last$1(commands)) {</p><p>            throw new Error('{outlets:{}} has to be the last command');</p><p>        }</p><p>    }</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    Navigation.prototype.toRoot = function () {</p><p>        return this.isAbsolute && this.commands.length === 1 && this.commands[0] == '/';</p><p>    };</p><p>    return Navigation;</p><p>}());</p><p>/**</p><p> * Transforms commands to a normalized `Navigation`</p><p> * @param {?} commands</p><p> * @return {?}</p><p> */</p><p>function computeNavigation(commands) {</p><p>    if ((typeof commands[0] === 'string') && commands.length === 1 && commands[0] === '/') {</p><p>        return new Navigation(true, 0, commands);</p><p>    }</p><p>    var /** @type {?} */ numberOfDoubleDots = 0;</p><p>    var /** @type {?} */ isAbsolute = false;</p><p>    var /** @type {?} */ res = commands.reduce(function (res, cmd, cmdIdx) {</p><p>        if (typeof cmd === 'object' && cmd != null) {</p><p>            if (cmd.outlets) {</p><p>                var /** @type {?} */ outlets_1 = {};</p><p>                forEach(cmd.outlets, function (commands, name) {</p><p>                    outlets_1[name] = typeof commands === 'string' ? commands.split('/') : commands;</p><p>                });</p><p>                return res.concat([{ outlets: outlets_1 }]);</p><p>            }</p><p>            if (cmd.segmentPath) {</p><p>                return res.concat([cmd.segmentPath]);</p><p>            }</p><p>        }</p><p>        if (!(typeof cmd === 'string')) {</p><p>            return res.concat([cmd]);</p><p>        }</p><p>        if (cmdIdx === 0) {</p><p>            cmd.split('/').forEach(function (urlPart, partIndex) {</p><p>                if (partIndex == 0 && urlPart === '.') {</p><p>                    // skip './a'</p><p>                }</p><p>                else if (partIndex == 0 && urlPart === '') {</p><p>                    isAbsolute = true;</p><p>                }</p><p>                else if (urlPart === '..') {</p><p>                    numberOfDoubleDots++;</p><p>                }</p><p>                else if (urlPart != '') {</p><p>                    res.push(urlPart);</p><p>                }</p><p>            });</p><p>            return res;</p><p>        }</p><p>        return res.concat([cmd]);</p><p>    }, []);</p><p>    return new Navigation(isAbsolute, numberOfDoubleDots, res);</p><p>}</p><p>var Position = (function () {</p><p>    /**</p><p>     * @param {?} segmentGroup</p><p>     * @param {?} processChildren</p><p>     * @param {?} index</p><p>     */</p><p>    function Position(segmentGroup, processChildren, index) {</p><p>        this.segmentGroup = segmentGroup;</p><p>        this.processChildren = processChildren;</p><p>        this.index = index;</p><p>    }</p><p>    return Position;</p><p>}());</p><p>/**</p><p> * @param {?} nav</p><p> * @param {?} tree</p><p> * @param {?} route</p><p> * @return {?}</p><p> */</p><p>function findStartingPosition(nav, tree, route) {</p><p>    if (nav.isAbsolute) {</p><p>        return new Position(tree.root, true, 0);</p><p>    }</p><p>    if (route.snapshot._lastPathIndex === -1) {</p><p>        return new Position(route.snapshot._urlSegment, true, 0);</p><p>    }</p><p>    var /** @type {?} */ modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;</p><p>    var /** @type {?} */ index = route.snapshot._lastPathIndex + modifier;</p><p>    return createPositionApplyingDoubleDots(route.snapshot._urlSegment, index, nav.numberOfDoubleDots);</p><p>}</p><p>/**</p><p> * @param {?} group</p><p> * @param {?} index</p><p> * @param {?} numberOfDoubleDots</p><p> * @return {?}</p><p> */</p><p>function createPositionApplyingDoubleDots(group, index, numberOfDoubleDots) {</p><p>    var /** @type {?} */ g = group;</p><p>    var /** @type {?} */ ci = index;</p><p>    var /** @type {?} */ dd = numberOfDoubleDots;</p><p>    while (dd > ci) {</p><p>        dd -= ci;</p><p>        g = ((g.parent));</p><p>        if (!g) {</p><p>            throw new Error('Invalid number of \'../\'');</p><p>        }</p><p>        ci = g.segments.length;</p><p>    }</p><p>    return new Position(g, false, ci - dd);</p><p>}</p><p>/**</p><p> * @param {?} command</p><p> * @return {?}</p><p> */</p><p>function getPath(command) {</p><p>    if (typeof command === 'object' && command != null && command.outlets) {</p><p>        return command.outlets[PRIMARY_OUTLET];</p><p>    }</p><p>    return "" + command;</p><p>}</p><p>/**</p><p> * @param {?} commands</p><p> * @return {?}</p><p> */</p><p>function getOutlets(commands) {</p><p>    if (!(typeof commands[0] === 'object'))</p><p>        return _a = {}, _a[PRIMARY_OUTLET] = commands, _a;</p><p>    if (commands[0].outlets === undefined)</p><p>        return _b = {}, _b[PRIMARY_OUTLET] = commands, _b;</p><p>    return commands[0].outlets;</p><p>    var _a, _b;</p><p>}</p><p>/**</p><p> * @param {?} segmentGroup</p><p> * @param {?} startIndex</p><p> * @param {?} commands</p><p> * @return {?}</p><p> */</p><p>function updateSegmentGroup(segmentGroup, startIndex, commands) {</p><p>    if (!segmentGroup) {</p><p>        segmentGroup = new UrlSegmentGroup([], {});</p><p>    }</p><p>    if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {</p><p>        return updateSegmentGroupChildren(segmentGroup, startIndex, commands);</p><p>    }</p><p>    var /** @type {?} */ m = prefixedWith(segmentGroup, startIndex, commands);</p><p>    var /** @type {?} */ slicedCommands = commands.slice(m.commandIndex);</p><p>    if (m.match && m.pathIndex < segmentGroup.segments.length) {</p><p>        var /** @type {?} */ g = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});</p><p>        g.children[PRIMARY_OUTLET] =</p><p>            new UrlSegmentGroup(segmentGroup.segments.slice(m.pathIndex), segmentGroup.children);</p><p>        return updateSegmentGroupChildren(g, 0, slicedCommands);</p><p>    }</p><p>    else if (m.match && slicedCommands.length === 0) {</p><p>        return new UrlSegmentGroup(segmentGroup.segments, {});</p><p>    }</p><p>    else if (m.match && !segmentGroup.hasChildren()) {</p><p>        return createNewSegmentGroup(segmentGroup, startIndex, commands);</p><p>    }</p><p>    else if (m.match) {</p><p>        return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);</p><p>    }</p><p>    else {</p><p>        return createNewSegmentGroup(segmentGroup, startIndex, commands);</p><p>    }</p><p>}</p><p>/**</p><p> * @param {?} segmentGroup</p><p> * @param {?} startIndex</p><p> * @param {?} commands</p><p> * @return {?}</p><p> */</p><p>function updateSegmentGroupChildren(segmentGroup, startIndex, commands) {</p><p>    if (commands.length === 0) {</p><p>        return new UrlSegmentGroup(segmentGroup.segments, {});</p><p>    }</p><p>    else {</p><p>        var /** @type {?} */ outlets_2 = getOutlets(commands);</p><p>        var /** @type {?} */ children_2 = {};</p><p>        forEach(outlets_2, function (commands, outlet) {</p><p>            if (commands !== null) {</p><p>                children_2[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands);</p><p>            }</p><p>        });</p><p>        forEach(segmentGroup.children, function (child, childOutlet) {</p><p>            if (outlets_2[childOutlet] === undefined) {</p><p>                children_2[childOutlet] = child;</p><p>            }</p><p>        });</p><p>        return new UrlSegmentGroup(segmentGroup.segments, children_2);</p><p>    }</p><p>}</p><p>/**</p><p> * @param {?} segmentGroup</p><p> * @param {?} startIndex</p><p> * @param {?} commands</p><p> * @return {?}</p><p> */</p><p>function prefixedWith(segmentGroup, startIndex, commands) {</p><p>    var /** @type {?} */ currentCommandIndex = 0;</p><p>    var /** @type {?} */ currentPathIndex = startIndex;</p><p>    var /** @type {?} */ noMatch = { match: false, pathIndex: 0, commandIndex: 0 };</p><p>    while (currentPathIndex < segmentGroup.segments.length) {</p><p>        if (currentCommandIndex >= commands.length)</p><p>            return noMatch;</p><p>        var /** @type {?} */ path = segmentGroup.segments[currentPathIndex];</p><p>        var /** @type {?} */ curr = getPath(commands[currentCommandIndex]);</p><p>        var /** @type {?} */ next = currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;</p><p>        if (currentPathIndex > 0 && curr === undefined)</p><p>            break;</p><p>        if (curr && next && (typeof next === 'object') && next.outlets === undefined) {</p><p>            if (!compare(curr, next, path))</p><p>                return noMatch;</p><p>            currentCommandIndex += 2;</p><p>        }</p><p>        else {</p><p>            if (!compare(curr, {}, path))</p><p>                return noMatch;</p><p>            currentCommandIndex++;</p><p>        }</p><p>        currentPathIndex++;</p><p>    }</p><p>    return { match: true, pathIndex: currentPathIndex, commandIndex: currentCommandIndex };</p><p>}</p><p>/**</p><p> * @param {?} segmentGroup</p><p> * @param {?} startIndex</p><p> * @param {?} commands</p><p> * @return {?}</p><p> */</p><p>function createNewSegmentGroup(segmentGroup, startIndex, commands) {</p><p>    var /** @type {?} */ paths = segmentGroup.segments.slice(0, startIndex);</p><p>    var /** @type {?} */ i = 0;</p><p>    while (i < commands.length) {</p><p>        if (typeof commands[i] === 'object' && commands[i].outlets !== undefined) {</p><p>            var /** @type {?} */ children = createNewSegmentChildren(commands[i].outlets);</p><p>            return new UrlSegmentGroup(paths, children);</p><p>        }</p><p>        // if we start with an object literal, we need to reuse the path part from the segment</p><p>        if (i === 0 && isMatrixParams(commands[0])) {</p><p>            var /** @type {?} */ p = segmentGroup.segments[startIndex];</p><p>            paths.push(new UrlSegment(p.path, commands[0]));</p><p>            i++;</p><p>            continue;</p><p>        }</p><p>        var /** @type {?} */ curr = getPath(commands[i]);</p><p>        var /** @type {?} */ next = (i < commands.length - 1) ? commands[i + 1] : null;</p><p>        if (curr && next && isMatrixParams(next)) {</p><p>            paths.push(new UrlSegment(curr, stringify(next)));</p><p>            i += 2;</p><p>        }</p><p>        else {</p><p>            paths.push(new UrlSegment(curr, {}));</p><p>            i++;</p><p>        }</p><p>    }</p><p>    return new UrlSegmentGroup(paths, {});</p><p>}</p><p>/**</p><p> * @param {?} outlets</p><p> * @return {?}</p><p> */</p><p>function createNewSegmentChildren(outlets) {</p><p>    var /** @type {?} */ children = {};</p><p>    forEach(outlets, function (commands, outlet) {</p><p>        if (commands !== null) {</p><p>            children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);</p><p>        }</p><p>    });</p><p>    return children;</p><p>}</p><p>/**</p><p> * @param {?} params</p><p> * @return {?}</p><p> */</p><p>function stringify(params) {</p><p>    var /** @type {?} */ res = {};</p><p>    forEach(params, function (v, k) { return res[k] = "" + v; });</p><p>    return res;</p><p>}</p><p>/**</p><p> * @param {?} path</p><p> * @param {?} params</p><p> * @param {?} segment</p><p> * @return {?}</p><p> */</p><p>function compare(path, params, segment) {</p><p>    return path == segment.path && shallowEqual(params, segment.parameters);</p><p>}</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>var NoMatch$1 = (function () {</p><p>    function NoMatch$1() {</p><p>    }</p><p>    return NoMatch$1;</p><p>}());</p><p>/**</p><p> * @param {?} rootComponentType</p><p> * @param {?} config</p><p> * @param {?} urlTree</p><p> * @param {?} url</p><p> * @return {?}</p><p> */</p><p>function recognize(rootComponentType, config, urlTree, url) {</p><p>    return new Recognizer(rootComponentType, config, urlTree, url).recognize();</p><p>}</p><p>var Recognizer = (function () {</p><p>    /**</p><p>     * @param {?} rootComponentType</p><p>     * @param {?} config</p><p>     * @param {?} urlTree</p><p>     * @param {?} url</p><p>     */</p><p>    function Recognizer(rootComponentType, config, urlTree, url) {</p><p>        this.rootComponentType = rootComponentType;</p><p>        this.config = config;</p><p>        this.urlTree = urlTree;</p><p>        this.url = url;</p><p>    }</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    Recognizer.prototype.recognize = function () {</p><p>        try {</p><p>            var /** @type {?} */ rootSegmentGroup = split$1(this.urlTree.root, [], [], this.config).segmentGroup;</p><p>            var /** @type {?} */ children = this.processSegmentGroup(this.config, rootSegmentGroup, PRIMARY_OUTLET);</p><p>            var /** @type {?} */ root = new ActivatedRouteSnapshot([], Object.freeze({}), Object.freeze(this.urlTree.queryParams), /** @type {?} */ ((this.urlTree.fragment)), {}, PRIMARY_OUTLET, this.rootComponentType, null, this.urlTree.root, -1, {});</p><p>            var /** @type {?} */ rootNode = new TreeNode(root, children);</p><p>            var /** @type {?} */ routeState = new RouterStateSnapshot(this.url, rootNode);</p><p>            this.inheritParamsAndData(routeState._root);</p><p>            return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(routeState);</p><p>        }</p><p>        catch (e) {</p><p>            return new __WEBPACK_IMPORTED_MODULE_14_rxjs_Observable__["Observable"](function (obs) { return obs.error(e); });</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @param {?} routeNode</p><p>     * @return {?}</p><p>     */</p><p>    Recognizer.prototype.inheritParamsAndData = function (routeNode) {</p><p>        var _this = this;</p><p>        var /** @type {?} */ route = routeNode.value;</p><p>        var /** @type {?} */ i = inheritedParamsDataResolve(route);</p><p>        route.params = Object.freeze(i.params);</p><p>        route.data = Object.freeze(i.data);</p><p>        routeNode.children.forEach(function (n) { return _this.inheritParamsAndData(n); });</p><p>    };</p><p>    /**</p><p>     * @param {?} config</p><p>     * @param {?} segmentGroup</p><p>     * @param {?} outlet</p><p>     * @return {?}</p><p>     */</p><p>    Recognizer.prototype.processSegmentGroup = function (config, segmentGroup, outlet) {</p><p>        if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {</p><p>            return this.processChildren(config, segmentGroup);</p><p>        }</p><p>        return this.processSegment(config, segmentGroup, segmentGroup.segments, outlet);</p><p>    };</p><p>    /**</p><p>     * @param {?} config</p><p>     * @param {?} segmentGroup</p><p>     * @return {?}</p><p>     */</p><p>    Recognizer.prototype.processChildren = function (config, segmentGroup) {</p><p>        var _this = this;</p><p>        var /** @type {?} */ children = mapChildrenIntoArray(segmentGroup, function (child, childOutlet) { return _this.processSegmentGroup(config, child, childOutlet); });</p><p>        checkOutletNameUniqueness(children);</p><p>        sortActivatedRouteSnapshots(children);</p><p>        return children;</p><p>    };</p><p>    /**</p><p>     * @param {?} config</p><p>     * @param {?} segmentGroup</p><p>     * @param {?} segments</p><p>     * @param {?} outlet</p><p>     * @return {?}</p><p>     */</p><p>    Recognizer.prototype.processSegment = function (config, segmentGroup, segments, outlet) {</p><p>        for (var _i = 0, config_1 = config; _i < config_1.length; _i++) {</p><p>            var r = config_1[_i];</p><p>            try {</p><p>                return this.processSegmentAgainstRoute(r, segmentGroup, segments, outlet);</p><p>            }</p><p>            catch (e) {</p><p>                if (!(e instanceof NoMatch$1))</p><p>                    throw e;</p><p>            }</p><p>        }</p><p>        if (this.noLeftoversInUrl(segmentGroup, segments, outlet)) {</p><p>            return [];</p><p>        }</p><p>        throw new NoMatch$1();</p><p>    };</p><p>    /**</p><p>     * @param {?} segmentGroup</p><p>     * @param {?} segments</p><p>     * @param {?} outlet</p><p>     * @return {?}</p><p>     */</p><p>    Recognizer.prototype.noLeftoversInUrl = function (segmentGroup, segments, outlet) {</p><p>        return segments.length === 0 && !segmentGroup.children[outlet];</p><p>    };</p><p>    /**</p><p>     * @param {?} route</p><p>     * @param {?} rawSegment</p><p>     * @param {?} segments</p><p>     * @param {?} outlet</p><p>     * @return {?}</p><p>     */</p><p>    Recognizer.prototype.processSegmentAgainstRoute = function (route, rawSegment, segments, outlet) {</p><p>        if (route.redirectTo)</p><p>            throw new NoMatch$1();</p><p>        if ((route.outlet || PRIMARY_OUTLET) !== outlet)</p><p>            throw new NoMatch$1();</p><p>        if (route.path === '**') {</p><p>            var /** @type {?} */ params = segments.length > 0 ? ((last$1(segments))).parameters : {};</p><p>            var /** @type {?} */ snapshot_1 = new ActivatedRouteSnapshot(segments, params, Object.freeze(this.urlTree.queryParams), /** @type {?} */ ((this.urlTree.fragment)), getData(route), outlet, /** @type {?} */ ((route.component)), route, getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + segments.length, getResolve(route));</p><p>            return [new TreeNode(snapshot_1, [])];</p><p>        }</p><p>        var _a = match$1(rawSegment, route, segments), consumedSegments = _a.consumedSegments, parameters = _a.parameters, lastChild = _a.lastChild;</p><p>        var /** @type {?} */ rawSlicedSegments = segments.slice(lastChild);</p><p>        var /** @type {?} */ childConfig = getChildConfig(route);</p><p>        var _b = split$1(rawSegment, consumedSegments, rawSlicedSegments, childConfig), segmentGroup = _b.segmentGroup, slicedSegments = _b.slicedSegments;</p><p>        var /** @type {?} */ snapshot = new ActivatedRouteSnapshot(consumedSegments, parameters, Object.freeze(this.urlTree.queryParams), /** @type {?} */ ((this.urlTree.fragment)), getData(route), outlet, /** @type {?} */ ((route.component)), route, getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + consumedSegments.length, getResolve(route));</p><p>        if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {</p><p>            var /** @type {?} */ children_3 = this.processChildren(childConfig, segmentGroup);</p><p>            return [new TreeNode(snapshot, children_3)];</p><p>        }</p><p>        if (childConfig.length === 0 && slicedSegments.length === 0) {</p><p>            return [new TreeNode(snapshot, [])];</p><p>        }</p><p>        var /** @type {?} */ children = this.processSegment(childConfig, segmentGroup, slicedSegments, PRIMARY_OUTLET);</p><p>        return [new TreeNode(snapshot, children)];</p><p>    };</p><p>    return Recognizer;</p><p>}());</p><p>/**</p><p> * @param {?} nodes</p><p> * @return {?}</p><p> */</p><p>function sortActivatedRouteSnapshots(nodes) {</p><p>    nodes.sort(function (a, b) {</p><p>        if (a.value.outlet === PRIMARY_OUTLET)</p><p>            return -1;</p><p>        if (b.value.outlet === PRIMARY_OUTLET)</p><p>            return 1;</p><p>        return a.value.outlet.localeCompare(b.value.outlet);</p><p>    });</p><p>}</p><p>/**</p><p> * @param {?} route</p><p> * @return {?}</p><p> */</p><p>function getChildConfig(route) {</p><p>    if (route.children) {</p><p>        return route.children;</p><p>    }</p><p>    if (route.loadChildren) {</p><p>        return ((route._loadedConfig)).routes;</p><p>    }</p><p>    return [];</p><p>}</p><p>/**</p><p> * @param {?} segmentGroup</p><p> * @param {?} route</p><p> * @param {?} segments</p><p> * @return {?}</p><p> */</p><p>function match$1(segmentGroup, route, segments) {</p><p>    if (route.path === '') {</p><p>        if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || segments.length > 0)) {</p><p>            throw new NoMatch$1();</p><p>        }</p><p>        return { consumedSegments: [], lastChild: 0, parameters: {} };</p><p>    }</p><p>    var /** @type {?} */ matcher = route.matcher || defaultUrlMatcher;</p><p>    var /** @type {?} */ res = matcher(segments, segmentGroup, route);</p><p>    if (!res)</p><p>        throw new NoMatch$1();</p><p>    var /** @type {?} */ posParams = {};</p><p>    forEach(/** @type {?} */ ((res.posParams)), function (v, k) { posParams[k] = v.path; });</p><p>    var /** @type {?} */ parameters = res.consumed.length > 0 ? Object.assign({}, posParams, res.consumed[res.consumed.length - 1].parameters) :</p><p>        posParams;</p><p>    return { consumedSegments: res.consumed, lastChild: res.consumed.length, parameters: parameters };</p><p>}</p><p>/**</p><p> * @param {?} nodes</p><p> * @return {?}</p><p> */</p><p>function checkOutletNameUniqueness(nodes) {</p><p>    var /** @type {?} */ names = {};</p><p>    nodes.forEach(function (n) {</p><p>        var /** @type {?} */ routeWithSameOutletName = names[n.value.outlet];</p><p>        if (routeWithSameOutletName) {</p><p>            var /** @type {?} */ p = routeWithSameOutletName.url.map(function (s) { return s.toString(); }).join('/');</p><p>            var /** @type {?} */ c = n.value.url.map(function (s) { return s.toString(); }).join('/');</p><p>            throw new Error("Two segments cannot have the same outlet name: '" + p + "' and '" + c + "'.");</p><p>        }</p><p>        names[n.value.outlet] = n.value;</p><p>    });</p><p>}</p><p>/**</p><p> * @param {?} segmentGroup</p><p> * @return {?}</p><p> */</p><p>function getSourceSegmentGroup(segmentGroup) {</p><p>    var /** @type {?} */ s = segmentGroup;</p><p>    while (s._sourceSegment) {</p><p>        s = s._sourceSegment;</p><p>    }</p><p>    return s;</p><p>}</p><p>/**</p><p> * @param {?} segmentGroup</p><p> * @return {?}</p><p> */</p><p>function getPathIndexShift(segmentGroup) {</p><p>    var /** @type {?} */ s = segmentGroup;</p><p>    var /** @type {?} */ res = (s._segmentIndexShift ? s._segmentIndexShift : 0);</p><p>    while (s._sourceSegment) {</p><p>        s = s._sourceSegment;</p><p>        res += (s._segmentIndexShift ? s._segmentIndexShift : 0);</p><p>    }</p><p>    return res - 1;</p><p>}</p><p>/**</p><p> * @param {?} segmentGroup</p><p> * @param {?} consumedSegments</p><p> * @param {?} slicedSegments</p><p> * @param {?} config</p><p> * @return {?}</p><p> */</p><p>function split$1(segmentGroup, consumedSegments, slicedSegments, config) {</p><p>    if (slicedSegments.length > 0 &&</p><p>        containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config)) {</p><p>        var /** @type {?} */ s_1 = new UrlSegmentGroup(consumedSegments, createChildrenForEmptyPaths(segmentGroup, consumedSegments, config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));</p><p>        s_1._sourceSegment = segmentGroup;</p><p>        s_1._segmentIndexShift = consumedSegments.length;</p><p>        return { segmentGroup: s_1, slicedSegments: [] };</p><p>    }</p><p>    if (slicedSegments.length === 0 &&</p><p>        containsEmptyPathMatches(segmentGroup, slicedSegments, config)) {</p><p>        var /** @type {?} */ s_2 = new UrlSegmentGroup(segmentGroup.segments, addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children));</p><p>        s_2._sourceSegment = segmentGroup;</p><p>        s_2._segmentIndexShift = consumedSegments.length;</p><p>        return { segmentGroup: s_2, slicedSegments: slicedSegments };</p><p>    }</p><p>    var /** @type {?} */ s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);</p><p>    s._sourceSegment = segmentGroup;</p><p>    s._segmentIndexShift = consumedSegments.length;</p><p>    return { segmentGroup: s, slicedSegments: slicedSegments };</p><p>}</p><p>/**</p><p> * @param {?} segmentGroup</p><p> * @param {?} slicedSegments</p><p> * @param {?} routes</p><p> * @param {?} children</p><p> * @return {?}</p><p> */</p><p>function addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, routes, children) {</p><p>    var /** @type {?} */ res = {};</p><p>    for (var _i = 0, routes_3 = routes; _i < routes_3.length; _i++) {</p><p>        var r = routes_3[_i];</p><p>        if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet$1(r)]) {</p><p>            var /** @type {?} */ s = new UrlSegmentGroup([], {});</p><p>            s._sourceSegment = segmentGroup;</p><p>            s._segmentIndexShift = segmentGroup.segments.length;</p><p>            res[getOutlet$1(r)] = s;</p><p>        }</p><p>    }</p><p>    return Object.assign({}, children, res);</p><p>}</p><p>/**</p><p> * @param {?} segmentGroup</p><p> * @param {?} consumedSegments</p><p> * @param {?} routes</p><p> * @param {?} primarySegment</p><p> * @return {?}</p><p> */</p><p>function createChildrenForEmptyPaths(segmentGroup, consumedSegments, routes, primarySegment) {</p><p>    var /** @type {?} */ res = {};</p><p>    res[PRIMARY_OUTLET] = primarySegment;</p><p>    primarySegment._sourceSegment = segmentGroup;</p><p>    primarySegment._segmentIndexShift = consumedSegments.length;</p><p>    for (var _i = 0, routes_4 = routes; _i < routes_4.length; _i++) {</p><p>        var r = routes_4[_i];</p><p>        if (r.path === '' && getOutlet$1(r) !== PRIMARY_OUTLET) {</p><p>            var /** @type {?} */ s = new UrlSegmentGroup([], {});</p><p>            s._sourceSegment = segmentGroup;</p><p>            s._segmentIndexShift = consumedSegments.length;</p><p>            res[getOutlet$1(r)] = s;</p><p>        }</p><p>    }</p><p>    return res;</p><p>}</p><p>/**</p><p> * @param {?} segmentGroup</p><p> * @param {?} slicedSegments</p><p> * @param {?} routes</p><p> * @return {?}</p><p> */</p><p>function containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, routes) {</p><p>    return routes.some(function (r) { return emptyPathMatch(segmentGroup, slicedSegments, r) && getOutlet$1(r) !== PRIMARY_OUTLET; });</p><p>}</p><p>/**</p><p> * @param {?} segmentGroup</p><p> * @param {?} slicedSegments</p><p> * @param {?} routes</p><p> * @return {?}</p><p> */</p><p>function containsEmptyPathMatches(segmentGroup, slicedSegments, routes) {</p><p>    return routes.some(function (r) { return emptyPathMatch(segmentGroup, slicedSegments, r); });</p><p>}</p><p>/**</p><p> * @param {?} segmentGroup</p><p> * @param {?} slicedSegments</p><p> * @param {?} r</p><p> * @return {?}</p><p> */</p><p>function emptyPathMatch(segmentGroup, slicedSegments, r) {</p><p>    if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === 'full') {</p><p>        return false;</p><p>    }</p><p>    return r.path === '' && r.redirectTo === undefined;</p><p>}</p><p>/**</p><p> * @param {?} route</p><p> * @return {?}</p><p> */</p><p>function getOutlet$1(route) {</p><p>    return route.outlet || PRIMARY_OUTLET;</p><p>}</p><p>/**</p><p> * @param {?} route</p><p> * @return {?}</p><p> */</p><p>function getData(route) {</p><p>    return route.data || {};</p><p>}</p><p>/**</p><p> * @param {?} route</p><p> * @return {?}</p><p> */</p><p>function getResolve(route) {</p><p>    return route.resolve || {};</p><p>}</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * \@whatItDoes Provides a way to customize when activated routes get reused.</p><p> *</p><p> * \@experimental</p><p> * @abstract</p><p> */</p><p>var RouteReuseStrategy = (function () {</p><p>    function RouteReuseStrategy() {</p><p>    }</p><p>    /**</p><p>     * Determines if this route (and its subtree) should be detached to be reused later</p><p>     * @abstract</p><p>     * @param {?} route</p><p>     * @return {?}</p><p>     */</p><p>    RouteReuseStrategy.prototype.shouldDetach = function (route) { };</p><p>    /**</p><p>     * Stores the detached route.</p><p>     *</p><p>     * Storing a `null` value should erase the previously stored value.</p><p>     * @abstract</p><p>     * @param {?} route</p><p>     * @param {?} handle</p><p>     * @return {?}</p><p>     */</p><p>    RouteReuseStrategy.prototype.store = function (route, handle) { };</p><p>    /**</p><p>     * Determines if this route (and its subtree) should be reattached</p><p>     * @abstract</p><p>     * @param {?} route</p><p>     * @return {?}</p><p>     */</p><p>    RouteReuseStrategy.prototype.shouldAttach = function (route) { };</p><p>    /**</p><p>     * Retrieves the previously stored route</p><p>     * @abstract</p><p>     * @param {?} route</p><p>     * @return {?}</p><p>     */</p><p>    RouteReuseStrategy.prototype.retrieve = function (route) { };</p><p>    /**</p><p>     * Determines if a route should be reused</p><p>     * @abstract</p><p>     * @param {?} future</p><p>     * @param {?} curr</p><p>     * @return {?}</p><p>     */</p><p>    RouteReuseStrategy.prototype.shouldReuseRoute = function (future, curr) { };</p><p>    return RouteReuseStrategy;</p><p>}());</p><p>/**</p><p> * Does not detach any subtrees. Reuses routes as long as their route config is the same.</p><p> */</p><p>var DefaultRouteReuseStrategy = (function () {</p><p>    function DefaultRouteReuseStrategy() {</p><p>    }</p><p>    /**</p><p>     * @param {?} route</p><p>     * @return {?}</p><p>     */</p><p>    DefaultRouteReuseStrategy.prototype.shouldDetach = function (route) { return false; };</p><p>    /**</p><p>     * @param {?} route</p><p>     * @param {?} detachedTree</p><p>     * @return {?}</p><p>     */</p><p>    DefaultRouteReuseStrategy.prototype.store = function (route, detachedTree) { };</p><p>    /**</p><p>     * @param {?} route</p><p>     * @return {?}</p><p>     */</p><p>    DefaultRouteReuseStrategy.prototype.shouldAttach = function (route) { return false; };</p><p>    /**</p><p>     * @param {?} route</p><p>     * @return {?}</p><p>     */</p><p>    DefaultRouteReuseStrategy.prototype.retrieve = function (route) { return null; };</p><p>    /**</p><p>     * @param {?} future</p><p>     * @param {?} curr</p><p>     * @return {?}</p><p>     */</p><p>    DefaultRouteReuseStrategy.prototype.shouldReuseRoute = function (future, curr) {</p><p>        return future.routeConfig === curr.routeConfig;</p><p>    };</p><p>    return DefaultRouteReuseStrategy;</p><p>}());</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * \@docsNotRequired</p><p> * \@experimental</p><p> */</p><p>var ROUTES = new __WEBPACK_IMPORTED_MODULE_2__angular_core__["InjectionToken"]('ROUTES');</p><p>var RouterConfigLoader = (function () {</p><p>    /**</p><p>     * @param {?} loader</p><p>     * @param {?} compiler</p><p>     * @param {?=} onLoadStartListener</p><p>     * @param {?=} onLoadEndListener</p><p>     */</p><p>    function RouterConfigLoader(loader, compiler, onLoadStartListener, onLoadEndListener) {</p><p>        this.loader = loader;</p><p>        this.compiler = compiler;</p><p>        this.onLoadStartListener = onLoadStartListener;</p><p>        this.onLoadEndListener = onLoadEndListener;</p><p>    }</p><p>    /**</p><p>     * @param {?} parentInjector</p><p>     * @param {?} route</p><p>     * @return {?}</p><p>     */</p><p>    RouterConfigLoader.prototype.load = function (parentInjector, route) {</p><p>        var _this = this;</p><p>        if (this.onLoadStartListener) {</p><p>            this.onLoadStartListener(route);</p><p>        }</p><p>        var /** @type {?} */ moduleFactory$ = this.loadModuleFactory(/** @type {?} */ ((route.loadChildren)));</p><p>        return __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(moduleFactory$, function (factory) {</p><p>            if (_this.onLoadEndListener) {</p><p>                _this.onLoadEndListener(route);</p><p>            }</p><p>            var /** @type {?} */ module = factory.create(parentInjector);</p><p>            return new LoadedRouterConfig(flatten(module.injector.get(ROUTES)), module);</p><p>        });</p><p>    };</p><p>    /**</p><p>     * @param {?} loadChildren</p><p>     * @return {?}</p><p>     */</p><p>    RouterConfigLoader.prototype.loadModuleFactory = function (loadChildren) {</p><p>        var _this = this;</p><p>        if (typeof loadChildren === 'string') {</p><p>            return Object(__WEBPACK_IMPORTED_MODULE_18_rxjs_observable_fromPromise__["fromPromise"])(this.loader.load(loadChildren));</p><p>        }</p><p>        else {</p><p>            return __WEBPACK_IMPORTED_MODULE_12_rxjs_operator_mergeMap__["mergeMap"].call(wrapIntoObservable(loadChildren()), function (t) {</p><p>                if (t instanceof __WEBPACK_IMPORTED_MODULE_2__angular_core__["NgModuleFactory"]) {</p><p>                    return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(t);</p><p>                }</p><p>                else {</p><p>                    return Object(__WEBPACK_IMPORTED_MODULE_18_rxjs_observable_fromPromise__["fromPromise"])(_this.compiler.compileModuleAsync(t));</p><p>                }</p><p>            });</p><p>        }</p><p>    };</p><p>    return RouterConfigLoader;</p><p>}());</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * \@whatItDoes Provides a way to migrate AngularJS applications to Angular.</p><p> *</p><p> * \@experimental</p><p> * @abstract</p><p> */</p><p>var UrlHandlingStrategy = (function () {</p><p>    function UrlHandlingStrategy() {</p><p>    }</p><p>    /**</p><p>     * Tells the router if this URL should be processed.</p><p>     *</p><p>     * When it returns true, the router will execute the regular navigation.</p><p>     * When it returns false, the router will set the router state to an empty state.</p><p>     * As a result, all the active components will be destroyed.</p><p>     *</p><p>     * @abstract</p><p>     * @param {?} url</p><p>     * @return {?}</p><p>     */</p><p>    UrlHandlingStrategy.prototype.shouldProcessUrl = function (url) { };</p><p>    /**</p><p>     * Extracts the part of the URL that should be handled by the router.</p><p>     * The rest of the URL will remain untouched.</p><p>     * @abstract</p><p>     * @param {?} url</p><p>     * @return {?}</p><p>     */</p><p>    UrlHandlingStrategy.prototype.extract = function (url) { };</p><p>    /**</p><p>     * Merges the URL fragment with the rest of the URL.</p><p>     * @abstract</p><p>     * @param {?} newUrlPart</p><p>     * @param {?} rawUrl</p><p>     * @return {?}</p><p>     */</p><p>    UrlHandlingStrategy.prototype.merge = function (newUrlPart, rawUrl) { };</p><p>    return UrlHandlingStrategy;</p><p>}());</p><p>/**</p><p> * \@experimental</p><p> */</p><p>var DefaultUrlHandlingStrategy = (function () {</p><p>    function DefaultUrlHandlingStrategy() {</p><p>    }</p><p>    /**</p><p>     * @param {?} url</p><p>     * @return {?}</p><p>     */</p><p>    DefaultUrlHandlingStrategy.prototype.shouldProcessUrl = function (url) { return true; };</p><p>    /**</p><p>     * @param {?} url</p><p>     * @return {?}</p><p>     */</p><p>    DefaultUrlHandlingStrategy.prototype.extract = function (url) { return url; };</p><p>    /**</p><p>     * @param {?} newUrlPart</p><p>     * @param {?} wholeUrl</p><p>     * @return {?}</p><p>     */</p><p>    DefaultUrlHandlingStrategy.prototype.merge = function (newUrlPart, wholeUrl) { return newUrlPart; };</p><p>    return DefaultUrlHandlingStrategy;</p><p>}());</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * @param {?} error</p><p> * @return {?}</p><p> */</p><p>function defaultErrorHandler(error) {</p><p>    throw error;</p><p>}</p><p>/**</p><p> * \@internal</p><p> * @param {?} snapshot</p><p> * @return {?}</p><p> */</p><p>function defaultRouterHook(snapshot) {</p><p>    return (Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(null));</p><p>}</p><p>/**</p><p> * \@whatItDoes Provides the navigation and url manipulation capabilities.</p><p> *</p><p> * See {\@link Routes} for more details and examples.</p><p> *</p><p> * \@ngModule RouterModule</p><p> *</p><p> * \@stable</p><p> */</p><p>var Router = (function () {</p><p>    /**</p><p>     * @param {?} rootComponentType</p><p>     * @param {?} urlSerializer</p><p>     * @param {?} rootContexts</p><p>     * @param {?} location</p><p>     * @param {?} injector</p><p>     * @param {?} loader</p><p>     * @param {?} compiler</p><p>     * @param {?} config</p><p>     */</p><p>    function Router(rootComponentType, urlSerializer, rootContexts, location, injector, loader, compiler, config) {</p><p>        var _this = this;</p><p>        this.rootComponentType = rootComponentType;</p><p>        this.urlSerializer = urlSerializer;</p><p>        this.rootContexts = rootContexts;</p><p>        this.location = location;</p><p>        this.config = config;</p><p>        this.navigations = new __WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject__["BehaviorSubject"](/** @type {?} */ ((null)));</p><p>        this.routerEvents = new __WEBPACK_IMPORTED_MODULE_4_rxjs_Subject__["Subject"]();</p><p>        this.navigationId = 0;</p><p>        /**</p><p>         * Error handler that is invoked when a navigation errors.</p><p>         *</p><p>         * See {\@link ErrorHandler} for more information.</p><p>         */</p><p>        this.errorHandler = defaultErrorHandler;</p><p>        /**</p><p>         * Indicates if at least one navigation happened.</p><p>         */</p><p>        this.navigated = false;</p><p>        /**</p><p>         * Used by RouterModule. This allows us to</p><p>         * pause the navigation either before preactivation or after it.</p><p>         * \@internal</p><p>         */</p><p>        this.hooks = {</p><p>            beforePreactivation: defaultRouterHook,</p><p>            afterPreactivation: defaultRouterHook</p><p>        };</p><p>        /**</p><p>         * Extracts and merges URLs. Used for AngularJS to Angular migrations.</p><p>         */</p><p>        this.urlHandlingStrategy = new DefaultUrlHandlingStrategy();</p><p>        this.routeReuseStrategy = new DefaultRouteReuseStrategy();</p><p>        var onLoadStart = function (r) { return _this.triggerEvent(new RouteConfigLoadStart(r)); };</p><p>        var onLoadEnd = function (r) { return _this.triggerEvent(new RouteConfigLoadEnd(r)); };</p><p>        this.ngModule = injector.get(__WEBPACK_IMPORTED_MODULE_2__angular_core__["NgModuleRef"]);</p><p>        this.resetConfig(config);</p><p>        this.currentUrlTree = createEmptyUrlTree();</p><p>        this.rawUrlTree = this.currentUrlTree;</p><p>        this.configLoader = new RouterConfigLoader(loader, compiler, onLoadStart, onLoadEnd);</p><p>        this.currentRouterState = createEmptyState(this.currentUrlTree, this.rootComponentType);</p><p>        this.processNavigations();</p><p>    }</p><p>    /**</p><p>     * \@internal</p><p>     * TODO: this should be removed once the constructor of the router made internal</p><p>     * @param {?} rootComponentType</p><p>     * @return {?}</p><p>     */</p><p>    Router.prototype.resetRootComponentType = function (rootComponentType) {</p><p>        this.rootComponentType = rootComponentType;</p><p>        // TODO: vsavkin router 4.0 should make the root component set to null</p><p>        // this will simplify the lifecycle of the router.</p><p>        this.currentRouterState.root.component = this.rootComponentType;</p><p>    };</p><p>    /**</p><p>     * Sets up the location change listener and performs the initial navigation.</p><p>     * @return {?}</p><p>     */</p><p>    Router.prototype.initialNavigation = function () {</p><p>        this.setUpLocationChangeListener();</p><p>        if (this.navigationId === 0) {</p><p>            this.navigateByUrl(this.location.path(true), { replaceUrl: true });</p><p>        }</p><p>    };</p><p>    /**</p><p>     * Sets up the location change listener.</p><p>     * @return {?}</p><p>     */</p><p>    Router.prototype.setUpLocationChangeListener = function () {</p><p>        var _this = this;</p><p>        // Zone.current.wrap is needed because of the issue with RxJS scheduler,</p><p>        // which does not work properly with zone.js in IE and Safari</p><p>        if (!this.locationSubscription) {</p><p>            this.locationSubscription = (this.location.subscribe(Zone.current.wrap(function (change) {</p><p>                var /** @type {?} */ rawUrlTree = _this.urlSerializer.parse(change['url']);</p><p>                var /** @type {?} */ source = change['type'] === 'popstate' ? 'popstate' : 'hashchange';</p><p>                setTimeout(function () { _this.scheduleNavigation(rawUrlTree, source, { replaceUrl: true }); }, 0);</p><p>            })));</p><p>        }</p><p>    };</p><p>    Object.defineProperty(Router.prototype, "routerState", {</p><p>        /**</p><p>         * The current route state</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this.currentRouterState; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(Router.prototype, "url", {</p><p>        /**</p><p>         * The current url</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this.serializeUrl(this.currentUrlTree); },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(Router.prototype, "events", {</p><p>        /**</p><p>         * An observable of router events</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this.routerEvents; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    /**</p><p>     * \@internal</p><p>     * @param {?} e</p><p>     * @return {?}</p><p>     */</p><p>    Router.prototype.triggerEvent = function (e) { this.routerEvents.next(e); };</p><p>    /**</p><p>     * Resets the configuration used for navigation and generating links.</p><p>     *</p><p>     * ### Usage</p><p>     *</p><p>     * ```</p><p>     * router.resetConfig([</p><p>     *  { path: 'team/:id', component: TeamCmp, children: [</p><p>     *    { path: 'simple', component: SimpleCmp },</p><p>     *    { path: 'user/:name', component: UserCmp }</p><p>     *  ]}</p><p>     * ]);</p><p>     * ```</p><p>     * @param {?} config</p><p>     * @return {?}</p><p>     */</p><p>    Router.prototype.resetConfig = function (config) {</p><p>        validateConfig(config);</p><p>        this.config = config;</p><p>        this.navigated = false;</p><p>    };</p><p>    /**</p><p>     * \@docsNotRequired</p><p>     * @return {?}</p><p>     */</p><p>    Router.prototype.ngOnDestroy = function () { this.dispose(); };</p><p>    /**</p><p>     * Disposes of the router</p><p>     * @return {?}</p><p>     */</p><p>    Router.prototype.dispose = function () {</p><p>        if (this.locationSubscription) {</p><p>            this.locationSubscription.unsubscribe();</p><p>            this.locationSubscription = ((null));</p><p>        }</p><p>    };</p><p>    /**</p><p>     * Applies an array of commands to the current url tree and creates a new url tree.</p><p>     *</p><p>     * When given an activate route, applies the given commands starting from the route.</p><p>     * When not given a route, applies the given command starting from the root.</p><p>     *</p><p>     * ### Usage</p><p>     *</p><p>     * ```</p><p>     * // create /team/33/user/11</p><p>     * router.createUrlTree(['/team', 33, 'user', 11]);</p><p>     *</p><p>     * // create /team/33;expand=true/user/11</p><p>     * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);</p><p>     *</p><p>     * // you can collapse static segments like this (this works only with the first passed-in value):</p><p>     * router.createUrlTree(['/team/33/user', userId]);</p><p>     *</p><p>     * // If the first segment can contain slashes, and you do not want the router to split it, you</p><p>     * // can do the following:</p><p>     *</p><p>     * router.createUrlTree([{segmentPath: '/one/two'}]);</p><p>     *</p><p>     * // create /team/33/(user/11//right:chat)</p><p>     * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);</p><p>     *</p><p>     * // remove the right secondary node</p><p>     * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);</p><p>     *</p><p>     * // assuming the current url is `/team/33/user/11` and the route points to `user/11`</p><p>     *</p><p>     * // navigate to /team/33/user/11/details</p><p>     * router.createUrlTree(['details'], {relativeTo: route});</p><p>     *</p><p>     * // navigate to /team/33/user/22</p><p>     * router.createUrlTree(['../22'], {relativeTo: route});</p><p>     *</p><p>     * // navigate to /team/44/user/22</p><p>     * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});</p><p>     * ```</p><p>     * @param {?} commands</p><p>     * @param {?=} navigationExtras</p><p>     * @return {?}</p><p>     */</p><p>    Router.prototype.createUrlTree = function (commands, navigationExtras) {</p><p>        if (navigationExtras === void 0) { navigationExtras = {}; }</p><p>        var relativeTo = navigationExtras.relativeTo, queryParams = navigationExtras.queryParams, fragment = navigationExtras.fragment, preserveQueryParams = navigationExtras.preserveQueryParams, queryParamsHandling = navigationExtras.queryParamsHandling, preserveFragment = navigationExtras.preserveFragment;</p><p>        if (Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["isDevMode"])() && preserveQueryParams && (console) && (console.warn)) {</p><p>            console.warn('preserveQueryParams is deprecated, use queryParamsHandling instead.');</p><p>        }</p><p>        var /** @type {?} */ a = relativeTo || this.routerState.root;</p><p>        var /** @type {?} */ f = preserveFragment ? this.currentUrlTree.fragment : fragment;</p><p>        var /** @type {?} */ q = null;</p><p>        if (queryParamsHandling) {</p><p>            switch (queryParamsHandling) {</p><p>                case 'merge':</p><p>                    q = Object.assign({}, this.currentUrlTree.queryParams, queryParams);</p><p>                    break;</p><p>                case 'preserve':</p><p>                    q = this.currentUrlTree.queryParams;</p><p>                    break;</p><p>                default:</p><p>                    q = queryParams || null;</p><p>            }</p><p>        }</p><p>        else {</p><p>            q = preserveQueryParams ? this.currentUrlTree.queryParams : queryParams || null;</p><p>        }</p><p>        return createUrlTree(a, this.currentUrlTree, commands, /** @type {?} */ ((q)), /** @type {?} */ ((f)));</p><p>    };</p><p>    /**</p><p>     * Navigate based on the provided url. This navigation is always absolute.</p><p>     *</p><p>     * Returns a promise that:</p><p>     * - resolves to 'true' when navigation succeeds,</p><p>     * - resolves to 'false' when navigation fails,</p><p>     * - is rejected when an error happens.</p><p>     *</p><p>     * ### Usage</p><p>     *</p><p>     * ```</p><p>     * router.navigateByUrl("/team/33/user/11");</p><p>     *</p><p>     * // Navigate without updating the URL</p><p>     * router.navigateByUrl("/team/33/user/11", { skipLocationChange: true });</p><p>     * ```</p><p>     *</p><p>     * In opposite to `navigate`, `navigateByUrl` takes a whole URL</p><p>     * and does not apply any delta to the current one.</p><p>     * @param {?} url</p><p>     * @param {?=} extras</p><p>     * @return {?}</p><p>     */</p><p>    Router.prototype.navigateByUrl = function (url, extras) {</p><p>        if (extras === void 0) { extras = { skipLocationChange: false }; }</p><p>        var /** @type {?} */ urlTree = url instanceof UrlTree ? url : this.parseUrl(url);</p><p>        var /** @type {?} */ mergedTree = this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree);</p><p>        return this.scheduleNavigation(mergedTree, 'imperative', extras);</p><p>    };</p><p>    /**</p><p>     * Navigate based on the provided array of commands and a starting point.</p><p>     * If no starting route is provided, the navigation is absolute.</p><p>     *</p><p>     * Returns a promise that:</p><p>     * - resolves to 'true' when navigation succeeds,</p><p>     * - resolves to 'false' when navigation fails,</p><p>     * - is rejected when an error happens.</p><p>     *</p><p>     * ### Usage</p><p>     *</p><p>     * ```</p><p>     * router.navigate(['team', 33, 'user', 11], {relativeTo: route});</p><p>     *</p><p>     * // Navigate without updating the URL</p><p>     * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});</p><p>     * ```</p><p>     *</p><p>     * In opposite to `navigateByUrl`, `navigate` always takes a delta that is applied to the current</p><p>     * URL.</p><p>     * @param {?} commands</p><p>     * @param {?=} extras</p><p>     * @return {?}</p><p>     */</p><p>    Router.prototype.navigate = function (commands, extras) {</p><p>        if (extras === void 0) { extras = { skipLocationChange: false }; }</p><p>        validateCommands(commands);</p><p>        if (typeof extras.queryParams === 'object' && extras.queryParams !== null) {</p><p>            extras.queryParams = this.removeEmptyProps(extras.queryParams);</p><p>        }</p><p>        return this.navigateByUrl(this.createUrlTree(commands, extras), extras);</p><p>    };</p><p>    /**</p><p>     * Serializes a {\@link UrlTree} into a string</p><p>     * @param {?} url</p><p>     * @return {?}</p><p>     */</p><p>    Router.prototype.serializeUrl = function (url) { return this.urlSerializer.serialize(url); };</p><p>    /**</p><p>     * Parses a string into a {\@link UrlTree}</p><p>     * @param {?} url</p><p>     * @return {?}</p><p>     */</p><p>    Router.prototype.parseUrl = function (url) { return this.urlSerializer.parse(url); };</p><p>    /**</p><p>     * Returns whether the url is activated</p><p>     * @param {?} url</p><p>     * @param {?} exact</p><p>     * @return {?}</p><p>     */</p><p>    Router.prototype.isActive = function (url, exact) {</p><p>        if (url instanceof UrlTree) {</p><p>            return containsTree(this.currentUrlTree, url, exact);</p><p>        }</p><p>        var /** @type {?} */ urlTree = this.urlSerializer.parse(url);</p><p>        return containsTree(this.currentUrlTree, urlTree, exact);</p><p>    };</p><p>    /**</p><p>     * @param {?} params</p><p>     * @return {?}</p><p>     */</p><p>    Router.prototype.removeEmptyProps = function (params) {</p><p>        return Object.keys(params).reduce(function (result, key) {</p><p>            var /** @type {?} */ value = params[key];</p><p>            if (value !== null && value !== undefined) {</p><p>                result[key] = value;</p><p>            }</p><p>            return result;</p><p>        }, {});</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    Router.prototype.processNavigations = function () {</p><p>        var _this = this;</p><p>        __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_concatMap__["concatMap"]</p><p>            .call(this.navigations, function (nav) {</p><p>            if (nav) {</p><p>                _this.executeScheduledNavigation(nav);</p><p>                // a failed navigation should not stop the router from processing</p><p>                // further navigations => the catch</p><p>                return nav.promise.catch(function () { });</p><p>            }</p><p>            else {</p><p>                return (Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(null));</p><p>            }</p><p>        })</p><p>            .subscribe(function () { });</p><p>    };</p><p>    /**</p><p>     * @param {?} rawUrl</p><p>     * @param {?} source</p><p>     * @param {?} extras</p><p>     * @return {?}</p><p>     */</p><p>    Router.prototype.scheduleNavigation = function (rawUrl, source, extras) {</p><p>        var /** @type {?} */ lastNavigation = this.navigations.value;</p><p>        // If the user triggers a navigation imperatively (e.g., by using navigateByUrl),</p><p>        // and that navigation results in 'replaceState' that leads to the same URL,</p><p>        // we should skip those.</p><p>        if (lastNavigation && source !== 'imperative' && lastNavigation.source === 'imperative' &&</p><p>            lastNavigation.rawUrl.toString() === rawUrl.toString()) {</p><p>            return Promise.resolve(true); // return value is not used</p><p>        }</p><p>        // Because of a bug in IE and Edge, the location class fires two events (popstate and</p><p>        // hashchange) every single time. The second one should be ignored. Otherwise, the URL will</p><p>        // flicker.</p><p>        if (lastNavigation && source == 'hashchange' && lastNavigation.source === 'popstate' &&</p><p>            lastNavigation.rawUrl.toString() === rawUrl.toString()) {</p><p>            return Promise.resolve(true); // return value is not used</p><p>        }</p><p>        var /** @type {?} */ resolve = null;</p><p>        var /** @type {?} */ reject = null;</p><p>        var /** @type {?} */ promise = new Promise(function (res, rej) {</p><p>            resolve = res;</p><p>            reject = rej;</p><p>        });</p><p>        var /** @type {?} */ id = ++this.navigationId;</p><p>        this.navigations.next({ id: id, source: source, rawUrl: rawUrl, extras: extras, resolve: resolve, reject: reject, promise: promise });</p><p>        // Make sure that the error is propagated even though `processNavigations` catch</p><p>        // handler does not rethrow</p><p>        return promise.catch(function (e) { return Promise.reject(e); });</p><p>    };</p><p>    /**</p><p>     * @param {?} __0</p><p>     * @return {?}</p><p>     */</p><p>    Router.prototype.executeScheduledNavigation = function (_a) {</p><p>        var _this = this;</p><p>        var id = _a.id, rawUrl = _a.rawUrl, extras = _a.extras, resolve = _a.resolve, reject = _a.reject;</p><p>        var /** @type {?} */ url = this.urlHandlingStrategy.extract(rawUrl);</p><p>        var /** @type {?} */ urlTransition = !this.navigated || url.toString() !== this.currentUrlTree.toString();</p><p>        if (urlTransition && this.urlHandlingStrategy.shouldProcessUrl(rawUrl)) {</p><p>            this.routerEvents.next(new NavigationStart(id, this.serializeUrl(url)));</p><p>            Promise.resolve()</p><p>                .then(function (_) { return _this.runNavigate(url, rawUrl, !!extras.skipLocationChange, !!extras.replaceUrl, id, null); })</p><p>                .then(resolve, reject);</p><p>            // we cannot process the current URL, but we could process the previous one =></p><p>            // we need to do some cleanup</p><p>        }</p><p>        else if (urlTransition && this.rawUrlTree &&</p><p>            this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)) {</p><p>            this.routerEvents.next(new NavigationStart(id, this.serializeUrl(url)));</p><p>            Promise.resolve()</p><p>                .then(function (_) { return _this.runNavigate(url, rawUrl, false, false, id, createEmptyState(url, _this.rootComponentType).snapshot); })</p><p>                .then(resolve, reject);</p><p>        }</p><p>        else {</p><p>            this.rawUrlTree = rawUrl;</p><p>            resolve(null);</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @param {?} url</p><p>     * @param {?} rawUrl</p><p>     * @param {?} shouldPreventPushState</p><p>     * @param {?} shouldReplaceUrl</p><p>     * @param {?} id</p><p>     * @param {?} precreatedState</p><p>     * @return {?}</p><p>     */</p><p>    Router.prototype.runNavigate = function (url, rawUrl, shouldPreventPushState, shouldReplaceUrl, id, precreatedState) {</p><p>        var _this = this;</p><p>        if (id !== this.navigationId) {</p><p>            this.location.go(this.urlSerializer.serialize(this.currentUrlTree));</p><p>            this.routerEvents.next(new NavigationCancel(id, this.serializeUrl(url), "Navigation ID " + id + " is not equal to the current navigation id " + this.navigationId));</p><p>            return Promise.resolve(false);</p><p>        }</p><p>        return new Promise(function (resolvePromise, rejectPromise) {</p><p>            // create an observable of the url and route state snapshot</p><p>            // this operation do not result in any side effects</p><p>            var /** @type {?} */ urlAndSnapshot$;</p><p>            if (!precreatedState) {</p><p>                var /** @type {?} */ moduleInjector = _this.ngModule.injector;</p><p>                var /** @type {?} */ redirectsApplied$ = applyRedirects(moduleInjector, _this.configLoader, _this.urlSerializer, url, _this.config);</p><p>                urlAndSnapshot$ = __WEBPACK_IMPORTED_MODULE_12_rxjs_operator_mergeMap__["mergeMap"].call(redirectsApplied$, function (appliedUrl) {</p><p>                    return __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(recognize(_this.rootComponentType, _this.config, appliedUrl, _this.serializeUrl(appliedUrl)), function (snapshot) {</p><p>                        _this.routerEvents.next(new RoutesRecognized(id, _this.serializeUrl(url), _this.serializeUrl(appliedUrl), snapshot));</p><p>                        return { appliedUrl: appliedUrl, snapshot: snapshot };</p><p>                    });</p><p>                });</p><p>            }</p><p>            else {</p><p>                urlAndSnapshot$ = Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])({ appliedUrl: url, snapshot: precreatedState });</p><p>            }</p><p>            var /** @type {?} */ beforePreactivationDone$ = __WEBPACK_IMPORTED_MODULE_12_rxjs_operator_mergeMap__["mergeMap"].call(urlAndSnapshot$, function (p) {</p><p>                return __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(_this.hooks.beforePreactivation(p.snapshot), function () { return p; });</p><p>            });</p><p>            // run preactivation: guards and data resolvers</p><p>            var /** @type {?} */ preActivation;</p><p>            var /** @type {?} */ preactivationTraverse$ = __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(beforePreactivationDone$, function (_a) {</p><p>                var appliedUrl = _a.appliedUrl, snapshot = _a.snapshot;</p><p>                var /** @type {?} */ moduleInjector = _this.ngModule.injector;</p><p>                preActivation =</p><p>                    new PreActivation(snapshot, _this.currentRouterState.snapshot, moduleInjector);</p><p>                preActivation.traverse(_this.rootContexts);</p><p>                return { appliedUrl: appliedUrl, snapshot: snapshot };</p><p>            });</p><p>            var /** @type {?} */ preactivationCheckGuards$ = __WEBPACK_IMPORTED_MODULE_12_rxjs_operator_mergeMap__["mergeMap"].call(preactivationTraverse$, function (_a) {</p><p>                var appliedUrl = _a.appliedUrl, snapshot = _a.snapshot;</p><p>                if (_this.navigationId !== id)</p><p>                    return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(false);</p><p>                _this.triggerEvent(new GuardsCheckStart(id, _this.serializeUrl(url), appliedUrl, snapshot));</p><p>                return __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(preActivation.checkGuards(), function (shouldActivate) {</p><p>                    _this.triggerEvent(new GuardsCheckEnd(id, _this.serializeUrl(url), appliedUrl, snapshot, shouldActivate));</p><p>                    return { appliedUrl: appliedUrl, snapshot: snapshot, shouldActivate: shouldActivate };</p><p>                });</p><p>            });</p><p>            var /** @type {?} */ preactivationResolveData$ = __WEBPACK_IMPORTED_MODULE_12_rxjs_operator_mergeMap__["mergeMap"].call(preactivationCheckGuards$, function (p) {</p><p>                if (_this.navigationId !== id)</p><p>                    return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(false);</p><p>                if (p.shouldActivate && preActivation.isActivating()) {</p><p>                    _this.triggerEvent(new ResolveStart(id, _this.serializeUrl(url), p.appliedUrl, p.snapshot));</p><p>                    return __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(preActivation.resolveData(), function () {</p><p>                        _this.triggerEvent(new ResolveEnd(id, _this.serializeUrl(url), p.appliedUrl, p.snapshot));</p><p>                        return p;</p><p>                    });</p><p>                }</p><p>                else {</p><p>                    return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(p);</p><p>                }</p><p>            });</p><p>            var /** @type {?} */ preactivationDone$ = __WEBPACK_IMPORTED_MODULE_12_rxjs_operator_mergeMap__["mergeMap"].call(preactivationResolveData$, function (p) {</p><p>                return __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(_this.hooks.afterPreactivation(p.snapshot), function () { return p; });</p><p>            });</p><p>            // create router state</p><p>            // this operation has side effects => route state is being affected</p><p>            var /** @type {?} */ routerState$ = __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(preactivationDone$, function (_a) {</p><p>                var appliedUrl = _a.appliedUrl, snapshot = _a.snapshot, shouldActivate = _a.shouldActivate;</p><p>                if (shouldActivate) {</p><p>                    var /** @type {?} */ state = createRouterState(_this.routeReuseStrategy, snapshot, _this.currentRouterState);</p><p>                    return { appliedUrl: appliedUrl, state: state, shouldActivate: shouldActivate };</p><p>                }</p><p>                else {</p><p>                    return { appliedUrl: appliedUrl, state: null, shouldActivate: shouldActivate };</p><p>                }</p><p>            });</p><p>            // applied the new router state</p><p>            // this operation has side effects</p><p>            var /** @type {?} */ navigationIsSuccessful;</p><p>            var /** @type {?} */ storedState = _this.currentRouterState;</p><p>            var /** @type {?} */ storedUrl = _this.currentUrlTree;</p><p>            routerState$</p><p>                .forEach(function (_a) {</p><p>                var appliedUrl = _a.appliedUrl, state = _a.state, shouldActivate = _a.shouldActivate;</p><p>                if (!shouldActivate || id !== _this.navigationId) {</p><p>                    navigationIsSuccessful = false;</p><p>                    return;</p><p>                }</p><p>                _this.currentUrlTree = appliedUrl;</p><p>                _this.rawUrlTree = _this.urlHandlingStrategy.merge(_this.currentUrlTree, rawUrl);</p><p>                _this.currentRouterState = state;</p><p>                if (!shouldPreventPushState) {</p><p>                    var /** @type {?} */ path = _this.urlSerializer.serialize(_this.rawUrlTree);</p><p>                    if (_this.location.isCurrentPathEqualTo(path) || shouldReplaceUrl) {</p><p>                        _this.location.replaceState(path);</p><p>                    }</p><p>                    else {</p><p>                        _this.location.go(path);</p><p>                    }</p><p>                }</p><p>                new ActivateRoutes(_this.routeReuseStrategy, state, storedState)</p><p>                    .activate(_this.rootContexts);</p><p>                navigationIsSuccessful = true;</p><p>            })</p><p>                .then(function () {</p><p>                if (navigationIsSuccessful) {</p><p>                    _this.navigated = true;</p><p>                    _this.routerEvents.next(new NavigationEnd(id, _this.serializeUrl(url), _this.serializeUrl(_this.currentUrlTree)));</p><p>                    resolvePromise(true);</p><p>                }</p><p>                else {</p><p>                    _this.resetUrlToCurrentUrlTree();</p><p>                    _this.routerEvents.next(new NavigationCancel(id, _this.serializeUrl(url), ''));</p><p>                    resolvePromise(false);</p><p>                }</p><p>            }, function (e) {</p><p>                if (isNavigationCancelingError(e)) {</p><p>                    _this.resetUrlToCurrentUrlTree();</p><p>                    _this.navigated = true;</p><p>                    _this.routerEvents.next(new NavigationCancel(id, _this.serializeUrl(url), e.message));</p><p>                    resolvePromise(false);</p><p>                }</p><p>                else {</p><p>                    _this.routerEvents.next(new NavigationError(id, _this.serializeUrl(url), e));</p><p>                    try {</p><p>                        resolvePromise(_this.errorHandler(e));</p><p>                    }</p><p>                    catch (ee) {</p><p>                        rejectPromise(ee);</p><p>                    }</p><p>                }</p><p>                _this.currentRouterState = storedState;</p><p>                _this.currentUrlTree = storedUrl;</p><p>                _this.rawUrlTree = _this.urlHandlingStrategy.merge(_this.currentUrlTree, rawUrl);</p><p>                _this.location.replaceState(_this.serializeUrl(_this.rawUrlTree));</p><p>            });</p><p>        });</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    Router.prototype.resetUrlToCurrentUrlTree = function () {</p><p>        var /** @type {?} */ path = this.urlSerializer.serialize(this.rawUrlTree);</p><p>        this.location.replaceState(path);</p><p>    };</p><p>    return Router;</p><p>}());</p><p>var CanActivate = (function () {</p><p>    /**</p><p>     * @param {?} path</p><p>     */</p><p>    function CanActivate(path) {</p><p>        this.path = path;</p><p>    }</p><p>    Object.defineProperty(CanActivate.prototype, "route", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this.path[this.path.length - 1]; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    return CanActivate;</p><p>}());</p><p>var CanDeactivate = (function () {</p><p>    /**</p><p>     * @param {?} component</p><p>     * @param {?} route</p><p>     */</p><p>    function CanDeactivate(component, route) {</p><p>        this.component = component;</p><p>        this.route = route;</p><p>    }</p><p>    return CanDeactivate;</p><p>}());</p><p>var PreActivation = (function () {</p><p>    /**</p><p>     * @param {?} future</p><p>     * @param {?} curr</p><p>     * @param {?} moduleInjector</p><p>     */</p><p>    function PreActivation(future, curr, moduleInjector) {</p><p>        this.future = future;</p><p>        this.curr = curr;</p><p>        this.moduleInjector = moduleInjector;</p><p>        this.canActivateChecks = [];</p><p>        this.canDeactivateChecks = [];</p><p>    }</p><p>    /**</p><p>     * @param {?} parentContexts</p><p>     * @return {?}</p><p>     */</p><p>    PreActivation.prototype.traverse = function (parentContexts) {</p><p>        var /** @type {?} */ futureRoot = this.future._root;</p><p>        var /** @type {?} */ currRoot = this.curr ? this.curr._root : null;</p><p>        this.traverseChildRoutes(futureRoot, currRoot, parentContexts, [futureRoot.value]);</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    PreActivation.prototype.checkGuards = function () {</p><p>        var _this = this;</p><p>        if (!this.isDeactivating() && !this.isActivating()) {</p><p>            return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(true);</p><p>        }</p><p>        var /** @type {?} */ canDeactivate$ = this.runCanDeactivateChecks();</p><p>        return __WEBPACK_IMPORTED_MODULE_12_rxjs_operator_mergeMap__["mergeMap"].call(canDeactivate$, function (canDeactivate) { return canDeactivate ? _this.runCanActivateChecks() : Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(false); });</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    PreActivation.prototype.resolveData = function () {</p><p>        var _this = this;</p><p>        if (!this.isActivating())</p><p>            return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(null);</p><p>        var /** @type {?} */ checks$ = Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_from__["from"])(this.canActivateChecks);</p><p>        var /** @type {?} */ runningChecks$ = __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_concatMap__["concatMap"].call(checks$, function (check) { return _this.runResolve(check.route); });</p><p>        return __WEBPACK_IMPORTED_MODULE_13_rxjs_operator_reduce__["reduce"].call(runningChecks$, function (_, __) { return _; });</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    PreActivation.prototype.isDeactivating = function () { return this.canDeactivateChecks.length !== 0; };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    PreActivation.prototype.isActivating = function () { return this.canActivateChecks.length !== 0; };</p><p>    /**</p><p>     * @param {?} futureNode</p><p>     * @param {?} currNode</p><p>     * @param {?} contexts</p><p>     * @param {?} futurePath</p><p>     * @return {?}</p><p>     */</p><p>    PreActivation.prototype.traverseChildRoutes = function (futureNode, currNode, contexts, futurePath) {</p><p>        var _this = this;</p><p>        var /** @type {?} */ prevChildren = nodeChildrenAsMap(currNode);</p><p>        // Process the children of the future route</p><p>        futureNode.children.forEach(function (c) {</p><p>            _this.traverseRoutes(c, prevChildren[c.value.outlet], contexts, futurePath.concat([c.value]));</p><p>            delete prevChildren[c.value.outlet];</p><p>        });</p><p>        // Process any children left from the current route (not active for the future route)</p><p>        forEach(prevChildren, function (v, k) { return _this.deactivateRouteAndItsChildren(v, /** @type {?} */ ((contexts)).getContext(k)); });</p><p>    };</p><p>    /**</p><p>     * @param {?} futureNode</p><p>     * @param {?} currNode</p><p>     * @param {?} parentContexts</p><p>     * @param {?} futurePath</p><p>     * @return {?}</p><p>     */</p><p>    PreActivation.prototype.traverseRoutes = function (futureNode, currNode, parentContexts, futurePath) {</p><p>        var /** @type {?} */ future = futureNode.value;</p><p>        var /** @type {?} */ curr = currNode ? currNode.value : null;</p><p>        var /** @type {?} */ context = parentContexts ? parentContexts.getContext(futureNode.value.outlet) : null;</p><p>        // reusing the node</p><p>        if (curr && future._routeConfig === curr._routeConfig) {</p><p>            var /** @type {?} */ shouldRunGuardsAndResolvers = this.shouldRunGuardsAndResolvers(curr, future, /** @type {?} */ ((future._routeConfig)).runGuardsAndResolvers);</p><p>            if (shouldRunGuardsAndResolvers) {</p><p>                this.canActivateChecks.push(new CanActivate(futurePath));</p><p>            }</p><p>            else {</p><p>                // we need to set the data</p><p>                future.data = curr.data;</p><p>                future._resolvedData = curr._resolvedData;</p><p>            }</p><p>            // If we have a component, we need to go through an outlet.</p><p>            if (future.component) {</p><p>                this.traverseChildRoutes(futureNode, currNode, context ? context.children : null, futurePath);</p><p>                // if we have a componentless route, we recurse but keep the same outlet map.</p><p>            }</p><p>            else {</p><p>                this.traverseChildRoutes(futureNode, currNode, parentContexts, futurePath);</p><p>            }</p><p>            if (shouldRunGuardsAndResolvers) {</p><p>                var /** @type {?} */ outlet = ((((context)).outlet));</p><p>                this.canDeactivateChecks.push(new CanDeactivate(outlet.component, curr));</p><p>            }</p><p>        }</p><p>        else {</p><p>            if (curr) {</p><p>                this.deactivateRouteAndItsChildren(currNode, context);</p><p>            }</p><p>            this.canActivateChecks.push(new CanActivate(futurePath));</p><p>            // If we have a component, we need to go through an outlet.</p><p>            if (future.component) {</p><p>                this.traverseChildRoutes(futureNode, null, context ? context.children : null, futurePath);</p><p>                // if we have a componentless route, we recurse but keep the same outlet map.</p><p>            }</p><p>            else {</p><p>                this.traverseChildRoutes(futureNode, null, parentContexts, futurePath);</p><p>            }</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @param {?} curr</p><p>     * @param {?} future</p><p>     * @param {?} mode</p><p>     * @return {?}</p><p>     */</p><p>    PreActivation.prototype.shouldRunGuardsAndResolvers = function (curr, future, mode) {</p><p>        switch (mode) {</p><p>            case 'always':</p><p>                return true;</p><p>            case 'paramsOrQueryParamsChange':</p><p>                return !equalParamsAndUrlSegments(curr, future) ||</p><p>                    !shallowEqual(curr.queryParams, future.queryParams);</p><p>            case 'paramsChange':</p><p>            default:</p><p>                return !equalParamsAndUrlSegments(curr, future);</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @param {?} route</p><p>     * @param {?} context</p><p>     * @return {?}</p><p>     */</p><p>    PreActivation.prototype.deactivateRouteAndItsChildren = function (route, context) {</p><p>        var _this = this;</p><p>        var /** @type {?} */ children = nodeChildrenAsMap(route);</p><p>        var /** @type {?} */ r = route.value;</p><p>        forEach(children, function (node, childName) {</p><p>            if (!r.component) {</p><p>                _this.deactivateRouteAndItsChildren(node, context);</p><p>            }</p><p>            else if (context) {</p><p>                _this.deactivateRouteAndItsChildren(node, context.children.getContext(childName));</p><p>            }</p><p>            else {</p><p>                _this.deactivateRouteAndItsChildren(node, null);</p><p>            }</p><p>        });</p><p>        if (!r.component) {</p><p>            this.canDeactivateChecks.push(new CanDeactivate(null, r));</p><p>        }</p><p>        else if (context && context.outlet && context.outlet.isActivated) {</p><p>            this.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, r));</p><p>        }</p><p>        else {</p><p>            this.canDeactivateChecks.push(new CanDeactivate(null, r));</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    PreActivation.prototype.runCanDeactivateChecks = function () {</p><p>        var _this = this;</p><p>        var /** @type {?} */ checks$ = Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_from__["from"])(this.canDeactivateChecks);</p><p>        var /** @type {?} */ runningChecks$ = __WEBPACK_IMPORTED_MODULE_12_rxjs_operator_mergeMap__["mergeMap"].call(checks$, function (check) { return _this.runCanDeactivate(check.component, check.route); });</p><p>        return __WEBPACK_IMPORTED_MODULE_8_rxjs_operator_every__["every"].call(runningChecks$, function (result) { return result === true; });</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    PreActivation.prototype.runCanActivateChecks = function () {</p><p>        var _this = this;</p><p>        var /** @type {?} */ checks$ = Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_from__["from"])(this.canActivateChecks);</p><p>        var /** @type {?} */ runningChecks$ = __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_concatMap__["concatMap"].call(checks$, function (check) { return andObservables(Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_from__["from"])([_this.runCanActivateChild(check.path), _this.runCanActivate(check.route)])); });</p><p>        return __WEBPACK_IMPORTED_MODULE_8_rxjs_operator_every__["every"].call(runningChecks$, function (result) { return result === true; });</p><p>    };</p><p>    /**</p><p>     * @param {?} future</p><p>     * @return {?}</p><p>     */</p><p>    PreActivation.prototype.runCanActivate = function (future) {</p><p>        var _this = this;</p><p>        var /** @type {?} */ canActivate = future._routeConfig ? future._routeConfig.canActivate : null;</p><p>        if (!canActivate || canActivate.length === 0)</p><p>            return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(true);</p><p>        var /** @type {?} */ obs = __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_from__["from"])(canActivate), function (c) {</p><p>            var /** @type {?} */ guard = _this.getToken(c, future);</p><p>            var /** @type {?} */ observable;</p><p>            if (guard.canActivate) {</p><p>                observable = wrapIntoObservable(guard.canActivate(future, _this.future));</p><p>            }</p><p>            else {</p><p>                observable = wrapIntoObservable(guard(future, _this.future));</p><p>            }</p><p>            return __WEBPACK_IMPORTED_MODULE_9_rxjs_operator_first__["first"].call(observable);</p><p>        });</p><p>        return andObservables(obs);</p><p>    };</p><p>    /**</p><p>     * @param {?} path</p><p>     * @return {?}</p><p>     */</p><p>    PreActivation.prototype.runCanActivateChild = function (path) {</p><p>        var _this = this;</p><p>        var /** @type {?} */ future = path[path.length - 1];</p><p>        var /** @type {?} */ canActivateChildGuards = path.slice(0, path.length - 1)</p><p>            .reverse()</p><p>            .map(function (p) { return _this.extractCanActivateChild(p); })</p><p>            .filter(function (_) { return _ !== null; });</p><p>        return andObservables(__WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_from__["from"])(canActivateChildGuards), function (d) {</p><p>            var /** @type {?} */ obs = __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_from__["from"])(d.guards), function (c) {</p><p>                var /** @type {?} */ guard = _this.getToken(c, d.node);</p><p>                var /** @type {?} */ observable;</p><p>                if (guard.canActivateChild) {</p><p>                    observable = wrapIntoObservable(guard.canActivateChild(future, _this.future));</p><p>                }</p><p>                else {</p><p>                    observable = wrapIntoObservable(guard(future, _this.future));</p><p>                }</p><p>                return __WEBPACK_IMPORTED_MODULE_9_rxjs_operator_first__["first"].call(observable);</p><p>            });</p><p>            return andObservables(obs);</p><p>        }));</p><p>    };</p><p>    /**</p><p>     * @param {?} p</p><p>     * @return {?}</p><p>     */</p><p>    PreActivation.prototype.extractCanActivateChild = function (p) {</p><p>        var /** @type {?} */ canActivateChild = p._routeConfig ? p._routeConfig.canActivateChild : null;</p><p>        if (!canActivateChild || canActivateChild.length === 0)</p><p>            return null;</p><p>        return { node: p, guards: canActivateChild };</p><p>    };</p><p>    /**</p><p>     * @param {?} component</p><p>     * @param {?} curr</p><p>     * @return {?}</p><p>     */</p><p>    PreActivation.prototype.runCanDeactivate = function (component, curr) {</p><p>        var _this = this;</p><p>        var /** @type {?} */ canDeactivate = curr && curr._routeConfig ? curr._routeConfig.canDeactivate : null;</p><p>        if (!canDeactivate || canDeactivate.length === 0)</p><p>            return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(true);</p><p>        var /** @type {?} */ canDeactivate$ = __WEBPACK_IMPORTED_MODULE_12_rxjs_operator_mergeMap__["mergeMap"].call(Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_from__["from"])(canDeactivate), function (c) {</p><p>            var /** @type {?} */ guard = _this.getToken(c, curr);</p><p>            var /** @type {?} */ observable;</p><p>            if (guard.canDeactivate) {</p><p>                observable =</p><p>                    wrapIntoObservable(guard.canDeactivate(component, curr, _this.curr, _this.future));</p><p>            }</p><p>            else {</p><p>                observable = wrapIntoObservable(guard(component, curr, _this.curr, _this.future));</p><p>            }</p><p>            return __WEBPACK_IMPORTED_MODULE_9_rxjs_operator_first__["first"].call(observable);</p><p>        });</p><p>        return __WEBPACK_IMPORTED_MODULE_8_rxjs_operator_every__["every"].call(canDeactivate$, function (result) { return result === true; });</p><p>    };</p><p>    /**</p><p>     * @param {?} future</p><p>     * @return {?}</p><p>     */</p><p>    PreActivation.prototype.runResolve = function (future) {</p><p>        var /** @type {?} */ resolve = future._resolve;</p><p>        return __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(this.resolveNode(resolve, future), function (resolvedData) {</p><p>            future._resolvedData = resolvedData;</p><p>            future.data = Object.assign({}, future.data, inheritedParamsDataResolve(future).resolve);</p><p>            return null;</p><p>        });</p><p>    };</p><p>    /**</p><p>     * @param {?} resolve</p><p>     * @param {?} future</p><p>     * @return {?}</p><p>     */</p><p>    PreActivation.prototype.resolveNode = function (resolve, future) {</p><p>        var _this = this;</p><p>        var /** @type {?} */ keys = Object.keys(resolve);</p><p>        if (keys.length === 0) {</p><p>            return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])({});</p><p>        }</p><p>        if (keys.length === 1) {</p><p>            var /** @type {?} */ key_1 = keys[0];</p><p>            return __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(this.getResolver(resolve[key_1], future), function (value) {</p><p>                return _a = {}, _a[key_1] = value, _a;</p><p>                var _a;</p><p>            });</p><p>        }</p><p>        var /** @type {?} */ data = {};</p><p>        var /** @type {?} */ runningResolvers$ = __WEBPACK_IMPORTED_MODULE_12_rxjs_operator_mergeMap__["mergeMap"].call(Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_from__["from"])(keys), function (key) {</p><p>            return __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(_this.getResolver(resolve[key], future), function (value) {</p><p>                data[key] = value;</p><p>                return value;</p><p>            });</p><p>        });</p><p>        return __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_map__["map"].call(__WEBPACK_IMPORTED_MODULE_10_rxjs_operator_last__["last"].call(runningResolvers$), function () { return data; });</p><p>    };</p><p>    /**</p><p>     * @param {?} injectionToken</p><p>     * @param {?} future</p><p>     * @return {?}</p><p>     */</p><p>    PreActivation.prototype.getResolver = function (injectionToken, future) {</p><p>        var /** @type {?} */ resolver = this.getToken(injectionToken, future);</p><p>        return resolver.resolve ? wrapIntoObservable(resolver.resolve(future, this.future)) :</p><p>            wrapIntoObservable(resolver(future, this.future));</p><p>    };</p><p>    /**</p><p>     * @param {?} token</p><p>     * @param {?} snapshot</p><p>     * @return {?}</p><p>     */</p><p>    PreActivation.prototype.getToken = function (token, snapshot) {</p><p>        var /** @type {?} */ config = closestLoadedConfig(snapshot);</p><p>        var /** @type {?} */ injector = config ? config.module.injector : this.moduleInjector;</p><p>        return injector.get(token);</p><p>    };</p><p>    return PreActivation;</p><p>}());</p><p>var ActivateRoutes = (function () {</p><p>    /**</p><p>     * @param {?} routeReuseStrategy</p><p>     * @param {?} futureState</p><p>     * @param {?} currState</p><p>     */</p><p>    function ActivateRoutes(routeReuseStrategy, futureState, currState) {</p><p>        this.routeReuseStrategy = routeReuseStrategy;</p><p>        this.futureState = futureState;</p><p>        this.currState = currState;</p><p>    }</p><p>    /**</p><p>     * @param {?} parentContexts</p><p>     * @return {?}</p><p>     */</p><p>    ActivateRoutes.prototype.activate = function (parentContexts) {</p><p>        var /** @type {?} */ futureRoot = this.futureState._root;</p><p>        var /** @type {?} */ currRoot = this.currState ? this.currState._root : null;</p><p>        this.deactivateChildRoutes(futureRoot, currRoot, parentContexts);</p><p>        advanceActivatedRoute(this.futureState.root);</p><p>        this.activateChildRoutes(futureRoot, currRoot, parentContexts);</p><p>    };</p><p>    /**</p><p>     * @param {?} futureNode</p><p>     * @param {?} currNode</p><p>     * @param {?} contexts</p><p>     * @return {?}</p><p>     */</p><p>    ActivateRoutes.prototype.deactivateChildRoutes = function (futureNode, currNode, contexts) {</p><p>        var _this = this;</p><p>        var /** @type {?} */ children = nodeChildrenAsMap(currNode);</p><p>        // Recurse on the routes active in the future state to de-activate deeper children</p><p>        futureNode.children.forEach(function (futureChild) {</p><p>            var /** @type {?} */ childOutletName = futureChild.value.outlet;</p><p>            _this.deactivateRoutes(futureChild, children[childOutletName], contexts);</p><p>            delete children[childOutletName];</p><p>        });</p><p>        // De-activate the routes that will not be re-used</p><p>        forEach(children, function (v, childName) {</p><p>            _this.deactivateRouteAndItsChildren(v, contexts);</p><p>        });</p><p>    };</p><p>    /**</p><p>     * @param {?} futureNode</p><p>     * @param {?} currNode</p><p>     * @param {?} parentContext</p><p>     * @return {?}</p><p>     */</p><p>    ActivateRoutes.prototype.deactivateRoutes = function (futureNode, currNode, parentContext) {</p><p>        var /** @type {?} */ future = futureNode.value;</p><p>        var /** @type {?} */ curr = currNode ? currNode.value : null;</p><p>        if (future === curr) {</p><p>            // Reusing the node, check to see if the children need to be de-activated</p><p>            if (future.component) {</p><p>                // If we have a normal route, we need to go through an outlet.</p><p>                var /** @type {?} */ context = parentContext.getContext(future.outlet);</p><p>                if (context) {</p><p>                    this.deactivateChildRoutes(futureNode, currNode, context.children);</p><p>                }</p><p>            }</p><p>            else {</p><p>                // if we have a componentless route, we recurse but keep the same outlet map.</p><p>                this.deactivateChildRoutes(futureNode, currNode, parentContext);</p><p>            }</p><p>        }</p><p>        else {</p><p>            if (curr) {</p><p>                // Deactivate the current route which will not be re-used</p><p>                this.deactivateRouteAndItsChildren(currNode, parentContext);</p><p>            }</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @param {?} route</p><p>     * @param {?} parentContexts</p><p>     * @return {?}</p><p>     */</p><p>    ActivateRoutes.prototype.deactivateRouteAndItsChildren = function (route, parentContexts) {</p><p>        if (this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {</p><p>            this.detachAndStoreRouteSubtree(route, parentContexts);</p><p>        }</p><p>        else {</p><p>            this.deactivateRouteAndOutlet(route, parentContexts);</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @param {?} route</p><p>     * @param {?} parentContexts</p><p>     * @return {?}</p><p>     */</p><p>    ActivateRoutes.prototype.detachAndStoreRouteSubtree = function (route, parentContexts) {</p><p>        var /** @type {?} */ context = parentContexts.getContext(route.value.outlet);</p><p>        if (context && context.outlet) {</p><p>            var /** @type {?} */ componentRef = context.outlet.detach();</p><p>            var /** @type {?} */ contexts = context.children.onOutletDeactivated();</p><p>            this.routeReuseStrategy.store(route.value.snapshot, { componentRef: componentRef, route: route, contexts: contexts });</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @param {?} route</p><p>     * @param {?} parentContexts</p><p>     * @return {?}</p><p>     */</p><p>    ActivateRoutes.prototype.deactivateRouteAndOutlet = function (route, parentContexts) {</p><p>        var _this = this;</p><p>        var /** @type {?} */ context = parentContexts.getContext(route.value.outlet);</p><p>        if (context) {</p><p>            var /** @type {?} */ children = nodeChildrenAsMap(route);</p><p>            var /** @type {?} */ contexts_1 = route.value.component ? context.children : parentContexts;</p><p>            forEach(children, function (v, k) { return _this.deactivateRouteAndItsChildren(v, contexts_1); });</p><p>            if (context.outlet) {</p><p>                // Destroy the component</p><p>                context.outlet.deactivate();</p><p>                // Destroy the contexts for all the outlets that were in the component</p><p>                context.children.onOutletDeactivated();</p><p>            }</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @param {?} futureNode</p><p>     * @param {?} currNode</p><p>     * @param {?} contexts</p><p>     * @return {?}</p><p>     */</p><p>    ActivateRoutes.prototype.activateChildRoutes = function (futureNode, currNode, contexts) {</p><p>        var _this = this;</p><p>        var /** @type {?} */ children = nodeChildrenAsMap(currNode);</p><p>        futureNode.children.forEach(function (c) { _this.activateRoutes(c, children[c.value.outlet], contexts); });</p><p>    };</p><p>    /**</p><p>     * @param {?} futureNode</p><p>     * @param {?} currNode</p><p>     * @param {?} parentContexts</p><p>     * @return {?}</p><p>     */</p><p>    ActivateRoutes.prototype.activateRoutes = function (futureNode, currNode, parentContexts) {</p><p>        var /** @type {?} */ future = futureNode.value;</p><p>        var /** @type {?} */ curr = currNode ? currNode.value : null;</p><p>        advanceActivatedRoute(future);</p><p>        // reusing the node</p><p>        if (future === curr) {</p><p>            if (future.component) {</p><p>                // If we have a normal route, we need to go through an outlet.</p><p>                var /** @type {?} */ context = parentContexts.getOrCreateContext(future.outlet);</p><p>                this.activateChildRoutes(futureNode, currNode, context.children);</p><p>            }</p><p>            else {</p><p>                // if we have a componentless route, we recurse but keep the same outlet map.</p><p>                this.activateChildRoutes(futureNode, currNode, parentContexts);</p><p>            }</p><p>        }</p><p>        else {</p><p>            if (future.component) {</p><p>                // if we have a normal route, we need to place the component into the outlet and recurse.</p><p>                var /** @type {?} */ context = parentContexts.getOrCreateContext(future.outlet);</p><p>                if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {</p><p>                    var /** @type {?} */ stored = ((this.routeReuseStrategy.retrieve(future.snapshot)));</p><p>                    this.routeReuseStrategy.store(future.snapshot, null);</p><p>                    context.children.onOutletReAttached(stored.contexts);</p><p>                    context.attachRef = stored.componentRef;</p><p>                    context.route = stored.route.value;</p><p>                    if (context.outlet) {</p><p>                        // Attach right away when the outlet has already been instantiated</p><p>                        // Otherwise attach from `RouterOutlet.ngOnInit` when it is instantiated</p><p>                        context.outlet.attach(stored.componentRef, stored.route.value);</p><p>                    }</p><p>                    advanceActivatedRouteNodeAndItsChildren(stored.route);</p><p>                }</p><p>                else {</p><p>                    var /** @type {?} */ config = parentLoadedConfig(future.snapshot);</p><p>                    var /** @type {?} */ cmpFactoryResolver = config ? config.module.componentFactoryResolver : null;</p><p>                    context.route = future;</p><p>                    context.resolver = cmpFactoryResolver;</p><p>                    if (context.outlet) {</p><p>                        // Activate the outlet when it has already been instantiated</p><p>                        // Otherwise it will get activated from its `ngOnInit` when instantiated</p><p>                        context.outlet.activateWith(future, cmpFactoryResolver);</p><p>                    }</p><p>                    this.activateChildRoutes(futureNode, null, context.children);</p><p>                }</p><p>            }</p><p>            else {</p><p>                // if we have a componentless route, we recurse but keep the same outlet map.</p><p>                this.activateChildRoutes(futureNode, null, parentContexts);</p><p>            }</p><p>        }</p><p>    };</p><p>    return ActivateRoutes;</p><p>}());</p><p>/**</p><p> * @param {?} node</p><p> * @return {?}</p><p> */</p><p>function advanceActivatedRouteNodeAndItsChildren(node) {</p><p>    advanceActivatedRoute(node.value);</p><p>    node.children.forEach(advanceActivatedRouteNodeAndItsChildren);</p><p>}</p><p>/**</p><p> * @param {?} snapshot</p><p> * @return {?}</p><p> */</p><p>function parentLoadedConfig(snapshot) {</p><p>    for (var /** @type {?} */ s = snapshot.parent; s; s = s.parent) {</p><p>        var /** @type {?} */ route = s._routeConfig;</p><p>        if (route && route._loadedConfig)</p><p>            return route._loadedConfig;</p><p>        if (route && route.component)</p><p>            return null;</p><p>    }</p><p>    return null;</p><p>}</p><p>/**</p><p> * @param {?} snapshot</p><p> * @return {?}</p><p> */</p><p>function closestLoadedConfig(snapshot) {</p><p>    if (!snapshot)</p><p>        return null;</p><p>    for (var /** @type {?} */ s = snapshot.parent; s; s = s.parent) {</p><p>        var /** @type {?} */ route = s._routeConfig;</p><p>        if (route && route._loadedConfig)</p><p>            return route._loadedConfig;</p><p>    }</p><p>    return null;</p><p>}</p><p>/**</p><p> * @template T</p><p> * @param {?} node</p><p> * @return {?}</p><p> */</p><p>function nodeChildrenAsMap(node) {</p><p>    var /** @type {?} */ map$$1 = {};</p><p>    if (node) {</p><p>        node.children.forEach(function (child) { return map$$1[child.value.outlet] = child; });</p><p>    }</p><p>    return map$$1;</p><p>}</p><p>/**</p><p> * @param {?} commands</p><p> * @return {?}</p><p> */</p><p>function validateCommands(commands) {</p><p>    for (var /** @type {?} */ i = 0; i < commands.length; i++) {</p><p>        var /** @type {?} */ cmd = commands[i];</p><p>        if (cmd == null) {</p><p>            throw new Error("The requested path contains " + cmd + " segment at index " + i);</p><p>        }</p><p>    }</p><p>}</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * \@whatItDoes Lets you link to specific parts of your app.</p><p> *</p><p> * \@howToUse</p><p> *</p><p> * Consider the following route configuration:</p><p> * `[{ path: 'user/:name', component: UserCmp }]`</p><p> *</p><p> * When linking to this `user/:name` route, you can write:</p><p> * `<a routerLink='/user/bob'>link to user component</a>`</p><p> *</p><p> * \@description</p><p> *</p><p> * The RouterLink directives let you link to specific parts of your app.</p><p> *</p><p> * When the link is static, you can use the directive as follows:</p><p> * `<a routerLink="/user/bob">link to user component</a>`</p><p> *</p><p> * If you use dynamic values to generate the link, you can pass an array of path</p><p> * segments, followed by the params for each segment.</p><p> *</p><p> * For instance `['/team', teamId, 'user', userName, {details: true}]`</p><p> * means that we want to generate a link to `/team/11/user/bob;details=true`.</p><p> *</p><p> * Multiple static segments can be merged into one</p><p> * (e.g., `['/team/11/user', userName, {details: true}]`).</p><p> *</p><p> * The first segment name can be prepended with `/`, `./`, or `../`:</p><p> * * If the first segment begins with `/`, the router will look up the route from the root of the</p><p> *   app.</p><p> * * If the first segment begins with `./`, or doesn't begin with a slash, the router will</p><p> *   instead look in the children of the current activated route.</p><p> * * And if the first segment begins with `../`, the router will go up one level.</p><p> *</p><p> * You can set query params and fragment as follows:</p><p> *</p><p> * ```</p><p> * <a [routerLink]="['/user/bob']" [queryParams]="{debug: true}" fragment="education"></p><p> *   link to user component</p><p> * </a></p><p> * ```</p><p> * RouterLink will use these to generate this link: `/user/bob#education?debug=true`.</p><p> *</p><p> * (Deprecated in v4.0.0 use `queryParamsHandling` instead) You can also tell the</p><p> * directive to preserve the current query params and fragment:</p><p> *</p><p> * ```</p><p> * <a [routerLink]="['/user/bob']" preserveQueryParams preserveFragment></p><p> *   link to user component</p><p> * </a></p><p> * ```</p><p> *</p><p> * You can tell the directive to how to handle queryParams, available options are:</p><p> *  - 'merge' merge the queryParams into the current queryParams</p><p> *  - 'preserve' preserve the current queryParams</p><p> *  - default / '' use the queryParams only</p><p> *  same options for {\@link NavigationExtras#queryParamsHandling}</p><p> *</p><p> * ```</p><p> * <a [routerLink]="['/user/bob']" [queryParams]="{debug: true}" queryParamsHandling="merge"></p><p> *   link to user component</p><p> * </a></p><p> * ```</p><p> *</p><p> * The router link directive always treats the provided input as a delta to the current url.</p><p> *</p><p> * For instance, if the current url is `/user/(box//aux:team)`.</p><p> *</p><p> * Then the following link `<a [routerLink]="['/user/jim']">Jim</a>` will generate the link</p><p> * `/user/(jim//aux:team)`.</p><p> *</p><p> * \@ngModule RouterModule</p><p> *</p><p> * See {\@link Router#createUrlTree} for more information.</p><p> *</p><p> * \@stable</p><p> */</p><p>var RouterLink = (function () {</p><p>    /**</p><p>     * @param {?} router</p><p>     * @param {?} route</p><p>     * @param {?} tabIndex</p><p>     * @param {?} renderer</p><p>     * @param {?} el</p><p>     */</p><p>    function RouterLink(router, route, tabIndex, renderer, el) {</p><p>        this.router = router;</p><p>        this.route = route;</p><p>        this.commands = [];</p><p>        if (tabIndex == null) {</p><p>            renderer.setAttribute(el.nativeElement, 'tabindex', '0');</p><p>        }</p><p>    }</p><p>    Object.defineProperty(RouterLink.prototype, "routerLink", {</p><p>        /**</p><p>         * @param {?} commands</p><p>         * @return {?}</p><p>         */</p><p>        set: function (commands) {</p><p>            if (commands != null) {</p><p>                this.commands = Array.isArray(commands) ? commands : [commands];</p><p>            }</p><p>            else {</p><p>                this.commands = [];</p><p>            }</p><p>        },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(RouterLink.prototype, "preserveQueryParams", {</p><p>        /**</p><p>         * @deprecated 4.0.0 use `queryParamsHandling` instead.</p><p>         * @param {?} value</p><p>         * @return {?}</p><p>         */</p><p>        set: function (value) {</p><p>            if (Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["isDevMode"])() && (console) && (console.warn)) {</p><p>                console.warn('preserveQueryParams is deprecated!, use queryParamsHandling instead.');</p><p>            }</p><p>            this.preserve = value;</p><p>        },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    RouterLink.prototype.onClick = function () {</p><p>        var /** @type {?} */ extras = {</p><p>            skipLocationChange: attrBoolValue(this.skipLocationChange),</p><p>            replaceUrl: attrBoolValue(this.replaceUrl),</p><p>        };</p><p>        this.router.navigateByUrl(this.urlTree, extras);</p><p>        return true;</p><p>    };</p><p>    Object.defineProperty(RouterLink.prototype, "urlTree", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () {</p><p>            return this.router.createUrlTree(this.commands, {</p><p>                relativeTo: this.route,</p><p>                queryParams: this.queryParams,</p><p>                fragment: this.fragment,</p><p>                preserveQueryParams: attrBoolValue(this.preserve),</p><p>                queryParamsHandling: this.queryParamsHandling,</p><p>                preserveFragment: attrBoolValue(this.preserveFragment),</p><p>            });</p><p>        },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    return RouterLink;</p><p>}());</p><p>RouterLink.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Directive"], args: [{ selector: ':not(a)[routerLink]' },] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>RouterLink.ctorParameters = function () { return [</p><p>    { type: Router, },</p><p>    { type: ActivatedRoute, },</p><p>    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Attribute"], args: ['tabindex',] },] },</p><p>    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Renderer2"], },</p><p>    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["ElementRef"], },</p><p>]; };</p><p>RouterLink.propDecorators = {</p><p>    'queryParams': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Input"] },],</p><p>    'fragment': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Input"] },],</p><p>    'queryParamsHandling': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Input"] },],</p><p>    'preserveFragment': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Input"] },],</p><p>    'skipLocationChange': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Input"] },],</p><p>    'replaceUrl': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Input"] },],</p><p>    'routerLink': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Input"] },],</p><p>    'preserveQueryParams': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Input"] },],</p><p>    'onClick': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["HostListener"], args: ['click',] },],</p><p>};</p><p>/**</p><p> * \@whatItDoes Lets you link to specific parts of your app.</p><p> *</p><p> * See {\@link RouterLink} for more information.</p><p> *</p><p> * \@ngModule RouterModule</p><p> *</p><p> * \@stable</p><p> */</p><p>var RouterLinkWithHref = (function () {</p><p>    /**</p><p>     * @param {?} router</p><p>     * @param {?} route</p><p>     * @param {?} locationStrategy</p><p>     */</p><p>    function RouterLinkWithHref(router, route, locationStrategy) {</p><p>        var _this = this;</p><p>        this.router = router;</p><p>        this.route = route;</p><p>        this.locationStrategy = locationStrategy;</p><p>        this.commands = [];</p><p>        this.subscription = router.events.subscribe(function (s) {</p><p>            if (s instanceof NavigationEnd) {</p><p>                _this.updateTargetUrlAndHref();</p><p>            }</p><p>        });</p><p>    }</p><p>    Object.defineProperty(RouterLinkWithHref.prototype, "routerLink", {</p><p>        /**</p><p>         * @param {?} commands</p><p>         * @return {?}</p><p>         */</p><p>        set: function (commands) {</p><p>            if (commands != null) {</p><p>                this.commands = Array.isArray(commands) ? commands : [commands];</p><p>            }</p><p>            else {</p><p>                this.commands = [];</p><p>            }</p><p>        },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(RouterLinkWithHref.prototype, "preserveQueryParams", {</p><p>        /**</p><p>         * @param {?} value</p><p>         * @return {?}</p><p>         */</p><p>        set: function (value) {</p><p>            if (Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["isDevMode"])() && (console) && (console.warn)) {</p><p>                console.warn('preserveQueryParams is deprecated, use queryParamsHandling instead.');</p><p>            }</p><p>            this.preserve = value;</p><p>        },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    /**</p><p>     * @param {?} changes</p><p>     * @return {?}</p><p>     */</p><p>    RouterLinkWithHref.prototype.ngOnChanges = function (changes) { this.updateTargetUrlAndHref(); };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    RouterLinkWithHref.prototype.ngOnDestroy = function () { this.subscription.unsubscribe(); };</p><p>    /**</p><p>     * @param {?} button</p><p>     * @param {?} ctrlKey</p><p>     * @param {?} metaKey</p><p>     * @param {?} shiftKey</p><p>     * @return {?}</p><p>     */</p><p>    RouterLinkWithHref.prototype.onClick = function (button, ctrlKey, metaKey, shiftKey) {</p><p>        if (button !== 0 || ctrlKey || metaKey || shiftKey) {</p><p>            return true;</p><p>        }</p><p>        if (typeof this.target === 'string' && this.target != '_self') {</p><p>            return true;</p><p>        }</p><p>        var /** @type {?} */ extras = {</p><p>            skipLocationChange: attrBoolValue(this.skipLocationChange),</p><p>            replaceUrl: attrBoolValue(this.replaceUrl),</p><p>        };</p><p>        this.router.navigateByUrl(this.urlTree, extras);</p><p>        return false;</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    RouterLinkWithHref.prototype.updateTargetUrlAndHref = function () {</p><p>        this.href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree));</p><p>    };</p><p>    Object.defineProperty(RouterLinkWithHref.prototype, "urlTree", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () {</p><p>            return this.router.createUrlTree(this.commands, {</p><p>                relativeTo: this.route,</p><p>                queryParams: this.queryParams,</p><p>                fragment: this.fragment,</p><p>                preserveQueryParams: attrBoolValue(this.preserve),</p><p>                queryParamsHandling: this.queryParamsHandling,</p><p>                preserveFragment: attrBoolValue(this.preserveFragment),</p><p>            });</p><p>        },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    return RouterLinkWithHref;</p><p>}());</p><p>RouterLinkWithHref.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Directive"], args: [{ selector: 'a[routerLink]' },] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>RouterLinkWithHref.ctorParameters = function () { return [</p><p>    { type: Router, },</p><p>    { type: ActivatedRoute, },</p><p>    { type: __WEBPACK_IMPORTED_MODULE_1__angular_common__["LocationStrategy"], },</p><p>]; };</p><p>RouterLinkWithHref.propDecorators = {</p><p>    'target': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["HostBinding"], args: ['attr.target',] }, { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Input"] },],</p><p>    'queryParams': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Input"] },],</p><p>    'fragment': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Input"] },],</p><p>    'queryParamsHandling': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Input"] },],</p><p>    'preserveFragment': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Input"] },],</p><p>    'skipLocationChange': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Input"] },],</p><p>    'replaceUrl': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Input"] },],</p><p>    'href': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["HostBinding"] },],</p><p>    'routerLink': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Input"] },],</p><p>    'preserveQueryParams': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Input"] },],</p><p>    'onClick': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["HostListener"], args: ['click', ['$event.button', '$event.ctrlKey', '$event.metaKey', '$event.shiftKey'],] },],</p><p>};</p><p>/**</p><p> * @param {?} s</p><p> * @return {?}</p><p> */</p><p>function attrBoolValue(s) {</p><p>    return s === '' || !!s;</p><p>}</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * \@whatItDoes Lets you add a CSS class to an element when the link's route becomes active.</p><p> *</p><p> * \@howToUse</p><p> *</p><p> * ```</p><p> * <a routerLink="/user/bob" routerLinkActive="active-link">Bob</a></p><p> * ```</p><p> *</p><p> * \@description</p><p> *</p><p> * The RouterLinkActive directive lets you add a CSS class to an element when the link's route</p><p> * becomes active.</p><p> *</p><p> * Consider the following example:</p><p> *</p><p> * ```</p><p> * <a routerLink="/user/bob" routerLinkActive="active-link">Bob</a></p><p> * ```</p><p> *</p><p> * When the url is either '/user' or '/user/bob', the active-link class will</p><p> * be added to the `a` tag. If the url changes, the class will be removed.</p><p> *</p><p> * You can set more than one class, as follows:</p><p> *</p><p> * ```</p><p> * <a routerLink="/user/bob" routerLinkActive="class1 class2">Bob</a></p><p> * <a routerLink="/user/bob" [routerLinkActive]="['class1', 'class2']">Bob</a></p><p> * ```</p><p> *</p><p> * You can configure RouterLinkActive by passing `exact: true`. This will add the classes</p><p> * only when the url matches the link exactly.</p><p> *</p><p> * ```</p><p> * <a routerLink="/user/bob" routerLinkActive="active-link" [routerLinkActiveOptions]="{exact:</p><p> * true}">Bob</a></p><p> * ```</p><p> *</p><p> * You can assign the RouterLinkActive instance to a template variable and directly check</p><p> * the `isActive` status.</p><p> * ```</p><p> * <a routerLink="/user/bob" routerLinkActive #rla="routerLinkActive"></p><p> *   Bob {{ rla.isActive ? '(already open)' : ''}}</p><p> * </a></p><p> * ```</p><p> *</p><p> * Finally, you can apply the RouterLinkActive directive to an ancestor of a RouterLink.</p><p> *</p><p> * ```</p><p> * <div routerLinkActive="active-link" [routerLinkActiveOptions]="{exact: true}"></p><p> *   <a routerLink="/user/jim">Jim</a></p><p> *   <a routerLink="/user/bob">Bob</a></p><p> * </div></p><p> * ```</p><p> *</p><p> * This will set the active-link class on the div tag if the url is either '/user/jim' or</p><p> * '/user/bob'.</p><p> *</p><p> * \@ngModule RouterModule</p><p> *</p><p> * \@stable</p><p> */</p><p>var RouterLinkActive = (function () {</p><p>    /**</p><p>     * @param {?} router</p><p>     * @param {?} element</p><p>     * @param {?} renderer</p><p>     * @param {?} cdr</p><p>     */</p><p>    function RouterLinkActive(router, element, renderer, cdr) {</p><p>        var _this = this;</p><p>        this.router = router;</p><p>        this.element = element;</p><p>        this.renderer = renderer;</p><p>        this.cdr = cdr;</p><p>        this.classes = [];</p><p>        this.active = false;</p><p>        this.routerLinkActiveOptions = { exact: false };</p><p>        this.subscription = router.events.subscribe(function (s) {</p><p>            if (s instanceof NavigationEnd) {</p><p>                _this.update();</p><p>            }</p><p>        });</p><p>    }</p><p>    Object.defineProperty(RouterLinkActive.prototype, "isActive", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this.active; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    RouterLinkActive.prototype.ngAfterContentInit = function () {</p><p>        var _this = this;</p><p>        this.links.changes.subscribe(function (_) { return _this.update(); });</p><p>        this.linksWithHrefs.changes.subscribe(function (_) { return _this.update(); });</p><p>        this.update();</p><p>    };</p><p>    Object.defineProperty(RouterLinkActive.prototype, "routerLinkActive", {</p><p>        /**</p><p>         * @param {?} data</p><p>         * @return {?}</p><p>         */</p><p>        set: function (data) {</p><p>            var /** @type {?} */ classes = Array.isArray(data) ? data : data.split(' ');</p><p>            this.classes = classes.filter(function (c) { return !!c; });</p><p>        },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    /**</p><p>     * @param {?} changes</p><p>     * @return {?}</p><p>     */</p><p>    RouterLinkActive.prototype.ngOnChanges = function (changes) { this.update(); };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    RouterLinkActive.prototype.ngOnDestroy = function () { this.subscription.unsubscribe(); };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    RouterLinkActive.prototype.update = function () {</p><p>        var _this = this;</p><p>        if (!this.links || !this.linksWithHrefs || !this.router.navigated)</p><p>            return;</p><p>        var /** @type {?} */ hasActiveLinks = this.hasActiveLinks();</p><p>        // react only when status has changed to prevent unnecessary dom updates</p><p>        if (this.active !== hasActiveLinks) {</p><p>            this.classes.forEach(function (c) {</p><p>                if (hasActiveLinks) {</p><p>                    _this.renderer.addClass(_this.element.nativeElement, c);</p><p>                }</p><p>                else {</p><p>                    _this.renderer.removeClass(_this.element.nativeElement, c);</p><p>                }</p><p>            });</p><p>            Promise.resolve(hasActiveLinks).then(function (active) { return _this.active = active; });</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @param {?} router</p><p>     * @return {?}</p><p>     */</p><p>    RouterLinkActive.prototype.isLinkActive = function (router) {</p><p>        var _this = this;</p><p>        return function (link) { return router.isActive(link.urlTree, _this.routerLinkActiveOptions.exact); };</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    RouterLinkActive.prototype.hasActiveLinks = function () {</p><p>        return this.links.some(this.isLinkActive(this.router)) ||</p><p>            this.linksWithHrefs.some(this.isLinkActive(this.router));</p><p>    };</p><p>    return RouterLinkActive;</p><p>}());</p><p>RouterLinkActive.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Directive"], args: [{</p><p>                selector: '[routerLinkActive]',</p><p>                exportAs: 'routerLinkActive',</p><p>            },] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>RouterLinkActive.ctorParameters = function () { return [</p><p>    { type: Router, },</p><p>    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["ElementRef"], },</p><p>    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Renderer2"], },</p><p>    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["ChangeDetectorRef"], },</p><p>]; };</p><p>RouterLinkActive.propDecorators = {</p><p>    'links': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["ContentChildren"], args: [RouterLink, { descendants: true },] },],</p><p>    'linksWithHrefs': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["ContentChildren"], args: [RouterLinkWithHref, { descendants: true },] },],</p><p>    'routerLinkActiveOptions': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Input"] },],</p><p>    'routerLinkActive': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Input"] },],</p><p>};</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * Store contextual information about a {\@link RouterOutlet}</p><p> *</p><p> * \@stable</p><p> */</p><p>var OutletContext = (function () {</p><p>    function OutletContext() {</p><p>        this.outlet = null;</p><p>        this.route = null;</p><p>        this.resolver = null;</p><p>        this.children = new ChildrenOutletContexts();</p><p>        this.attachRef = null;</p><p>    }</p><p>    return OutletContext;</p><p>}());</p><p>/**</p><p> * Store contextual information about the children (= nested) {\@link RouterOutlet}</p><p> *</p><p> * \@stable</p><p> */</p><p>var ChildrenOutletContexts = (function () {</p><p>    function ChildrenOutletContexts() {</p><p>        this.contexts = new Map();</p><p>    }</p><p>    /**</p><p>     * Called when a `RouterOutlet` directive is instantiated</p><p>     * @param {?} childName</p><p>     * @param {?} outlet</p><p>     * @return {?}</p><p>     */</p><p>    ChildrenOutletContexts.prototype.onChildOutletCreated = function (childName, outlet) {</p><p>        var /** @type {?} */ context = this.getOrCreateContext(childName);</p><p>        context.outlet = outlet;</p><p>        this.contexts.set(childName, context);</p><p>    };</p><p>    /**</p><p>     * Called when a `RouterOutlet` directive is destroyed.</p><p>     * We need to keep the context as the outlet could be destroyed inside a NgIf and might be</p><p>     * re-created later.</p><p>     * @param {?} childName</p><p>     * @return {?}</p><p>     */</p><p>    ChildrenOutletContexts.prototype.onChildOutletDestroyed = function (childName) {</p><p>        var /** @type {?} */ context = this.getContext(childName);</p><p>        if (context) {</p><p>            context.outlet = null;</p><p>        }</p><p>    };</p><p>    /**</p><p>     * Called when the corresponding route is deactivated during navigation.</p><p>     * Because the component get destroyed, all children outlet are destroyed.</p><p>     * @return {?}</p><p>     */</p><p>    ChildrenOutletContexts.prototype.onOutletDeactivated = function () {</p><p>        var /** @type {?} */ contexts = this.contexts;</p><p>        this.contexts = new Map();</p><p>        return contexts;</p><p>    };</p><p>    /**</p><p>     * @param {?} contexts</p><p>     * @return {?}</p><p>     */</p><p>    ChildrenOutletContexts.prototype.onOutletReAttached = function (contexts) { this.contexts = contexts; };</p><p>    /**</p><p>     * @param {?} childName</p><p>     * @return {?}</p><p>     */</p><p>    ChildrenOutletContexts.prototype.getOrCreateContext = function (childName) {</p><p>        var /** @type {?} */ context = this.getContext(childName);</p><p>        if (!context) {</p><p>            context = new OutletContext();</p><p>            this.contexts.set(childName, context);</p><p>        }</p><p>        return context;</p><p>    };</p><p>    /**</p><p>     * @param {?} childName</p><p>     * @return {?}</p><p>     */</p><p>    ChildrenOutletContexts.prototype.getContext = function (childName) { return this.contexts.get(childName) || null; };</p><p>    return ChildrenOutletContexts;</p><p>}());</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * \@whatItDoes Acts as a placeholder that Angular dynamically fills based on the current router</p><p> * state.</p><p> *</p><p> * \@howToUse</p><p> *</p><p> * ```</p><p> * <router-outlet></router-outlet></p><p> * <router-outlet name='left'></router-outlet></p><p> * <router-outlet name='right'></router-outlet></p><p> * ```</p><p> *</p><p> * A router outlet will emit an activate event any time a new component is being instantiated,</p><p> * and a deactivate event when it is being destroyed.</p><p> *</p><p> * ```</p><p> * <router-outlet</p><p> *   (activate)='onActivate($event)'</p><p> *   (deactivate)='onDeactivate($event)'></router-outlet></p><p> * ```</p><p> * \@ngModule RouterModule</p><p> *</p><p> * \@stable</p><p> */</p><p>var RouterOutlet = (function () {</p><p>    /**</p><p>     * @param {?} parentContexts</p><p>     * @param {?} location</p><p>     * @param {?} resolver</p><p>     * @param {?} name</p><p>     * @param {?} changeDetector</p><p>     */</p><p>    function RouterOutlet(parentContexts, location, resolver, name, changeDetector) {</p><p>        this.parentContexts = parentContexts;</p><p>        this.location = location;</p><p>        this.resolver = resolver;</p><p>        this.changeDetector = changeDetector;</p><p>        this.activated = null;</p><p>        this._activatedRoute = null;</p><p>        this.activateEvents = new __WEBPACK_IMPORTED_MODULE_2__angular_core__["EventEmitter"]();</p><p>        this.deactivateEvents = new __WEBPACK_IMPORTED_MODULE_2__angular_core__["EventEmitter"]();</p><p>        this.name = name || PRIMARY_OUTLET;</p><p>        parentContexts.onChildOutletCreated(this.name, this);</p><p>    }</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    RouterOutlet.prototype.ngOnDestroy = function () { this.parentContexts.onChildOutletDestroyed(this.name); };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    RouterOutlet.prototype.ngOnInit = function () {</p><p>        if (!this.activated) {</p><p>            // If the outlet was not instantiated at the time the route got activated we need to populate</p><p>            // the outlet when it is initialized (ie inside a NgIf)</p><p>            var /** @type {?} */ context = this.parentContexts.getContext(this.name);</p><p>            if (context && context.route) {</p><p>                if (context.attachRef) {</p><p>                    // `attachRef` is populated when there is an existing component to mount</p><p>                    this.attach(context.attachRef, context.route);</p><p>                }</p><p>                else {</p><p>                    // otherwise the component defined in the configuration is created</p><p>                    this.activateWith(context.route, context.resolver || null);</p><p>                }</p><p>            }</p><p>        }</p><p>    };</p><p>    Object.defineProperty(RouterOutlet.prototype, "locationInjector", {</p><p>        /**</p><p>         * @deprecated since v4 *</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this.location.injector; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(RouterOutlet.prototype, "locationFactoryResolver", {</p><p>        /**</p><p>         * @deprecated since v4 *</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return this.resolver; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(RouterOutlet.prototype, "isActivated", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () { return !!this.activated; },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(RouterOutlet.prototype, "component", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () {</p><p>            if (!this.activated)</p><p>                throw new Error('Outlet is not activated');</p><p>            return this.activated.instance;</p><p>        },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(RouterOutlet.prototype, "activatedRoute", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () {</p><p>            if (!this.activated)</p><p>                throw new Error('Outlet is not activated');</p><p>            return (this._activatedRoute);</p><p>        },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    Object.defineProperty(RouterOutlet.prototype, "activatedRouteData", {</p><p>        /**</p><p>         * @return {?}</p><p>         */</p><p>        get: function () {</p><p>            if (this._activatedRoute) {</p><p>                return this._activatedRoute.snapshot.data;</p><p>            }</p><p>            return {};</p><p>        },</p><p>        enumerable: true,</p><p>        configurable: true</p><p>    });</p><p>    /**</p><p>     * Called when the `RouteReuseStrategy` instructs to detach the subtree</p><p>     * @return {?}</p><p>     */</p><p>    RouterOutlet.prototype.detach = function () {</p><p>        if (!this.activated)</p><p>            throw new Error('Outlet is not activated');</p><p>        this.location.detach();</p><p>        var /** @type {?} */ cmp = this.activated;</p><p>        this.activated = null;</p><p>        this._activatedRoute = null;</p><p>        return cmp;</p><p>    };</p><p>    /**</p><p>     * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree</p><p>     * @param {?} ref</p><p>     * @param {?} activatedRoute</p><p>     * @return {?}</p><p>     */</p><p>    RouterOutlet.prototype.attach = function (ref, activatedRoute) {</p><p>        this.activated = ref;</p><p>        this._activatedRoute = activatedRoute;</p><p>        this.location.insert(ref.hostView);</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    RouterOutlet.prototype.deactivate = function () {</p><p>        if (this.activated) {</p><p>            var /** @type {?} */ c = this.component;</p><p>            this.activated.destroy();</p><p>            this.activated = null;</p><p>            this._activatedRoute = null;</p><p>            this.deactivateEvents.emit(c);</p><p>        }</p><p>    };</p><p>    /**</p><p>     * @param {?} activatedRoute</p><p>     * @param {?} resolver</p><p>     * @return {?}</p><p>     */</p><p>    RouterOutlet.prototype.activateWith = function (activatedRoute, resolver) {</p><p>        if (this.isActivated) {</p><p>            throw new Error('Cannot activate an already activated outlet');</p><p>        }</p><p>        this._activatedRoute = activatedRoute;</p><p>        var /** @type {?} */ snapshot = activatedRoute._futureSnapshot;</p><p>        var /** @type {?} */ component = (((snapshot._routeConfig)).component);</p><p>        resolver = resolver || this.resolver;</p><p>        var /** @type {?} */ factory = resolver.resolveComponentFactory(component);</p><p>        var /** @type {?} */ childContexts = this.parentContexts.getOrCreateContext(this.name).children;</p><p>        var /** @type {?} */ injector = new OutletInjector(activatedRoute, childContexts, this.location.injector);</p><p>        this.activated = this.location.createComponent(factory, this.location.length, injector);</p><p>        // Calling `markForCheck` to make sure we will run the change detection when the</p><p>        // `RouterOutlet` is inside a `ChangeDetectionStrategy.OnPush` component.</p><p>        this.changeDetector.markForCheck();</p><p>        this.activateEvents.emit(this.activated.instance);</p><p>    };</p><p>    return RouterOutlet;</p><p>}());</p><p>RouterOutlet.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Directive"], args: [{ selector: 'router-outlet', exportAs: 'outlet' },] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>RouterOutlet.ctorParameters = function () { return [</p><p>    { type: ChildrenOutletContexts, },</p><p>    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["ViewContainerRef"], },</p><p>    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["ComponentFactoryResolver"], },</p><p>    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Attribute"], args: ['name',] },] },</p><p>    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["ChangeDetectorRef"], },</p><p>]; };</p><p>RouterOutlet.propDecorators = {</p><p>    'activateEvents': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Output"], args: ['activate',] },],</p><p>    'deactivateEvents': [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Output"], args: ['deactivate',] },],</p><p>};</p><p>var OutletInjector = (function () {</p><p>    /**</p><p>     * @param {?} route</p><p>     * @param {?} childContexts</p><p>     * @param {?} parent</p><p>     */</p><p>    function OutletInjector(route, childContexts, parent) {</p><p>        this.route = route;</p><p>        this.childContexts = childContexts;</p><p>        this.parent = parent;</p><p>    }</p><p>    /**</p><p>     * @param {?} token</p><p>     * @param {?=} notFoundValue</p><p>     * @return {?}</p><p>     */</p><p>    OutletInjector.prototype.get = function (token, notFoundValue) {</p><p>        if (token === ActivatedRoute) {</p><p>            return this.route;</p><p>        }</p><p>        if (token === ChildrenOutletContexts) {</p><p>            return this.childContexts;</p><p>        }</p><p>        return this.parent.get(token, notFoundValue);</p><p>    };</p><p>    return OutletInjector;</p><p>}());</p><p>/**</p><p>*@license</p><p>*Copyright Google Inc. All Rights Reserved.</p><p>*</p><p>*Use of this source code is governed by an MIT-style license that can be</p><p>*found in the LICENSE file at https://angular.io/license</p><p>*/</p><p>/**</p><p> * \@whatItDoes Provides a preloading strategy.</p><p> *</p><p> * \@experimental</p><p> * @abstract</p><p> */</p><p>var PreloadingStrategy = (function () {</p><p>    function PreloadingStrategy() {</p><p>    }</p><p>    /**</p><p>     * @abstract</p><p>     * @param {?} route</p><p>     * @param {?} fn</p><p>     * @return {?}</p><p>     */</p><p>    PreloadingStrategy.prototype.preload = function (route, fn) { };</p><p>    return PreloadingStrategy;</p><p>}());</p><p>/**</p><p> * \@whatItDoes Provides a preloading strategy that preloads all modules as quickly as possible.</p><p> *</p><p> * \@howToUse</p><p> *</p><p> * ```</p><p> * RouteModule.forRoot(ROUTES, {preloadingStrategy: PreloadAllModules})</p><p> * ```</p><p> *</p><p> * \@experimental</p><p> */</p><p>var PreloadAllModules = (function () {</p><p>    function PreloadAllModules() {</p><p>    }</p><p>    /**</p><p>     * @param {?} route</p><p>     * @param {?} fn</p><p>     * @return {?}</p><p>     */</p><p>    PreloadAllModules.prototype.preload = function (route, fn) {</p><p>        return __WEBPACK_IMPORTED_MODULE_15_rxjs_operator_catch__["_catch"].call(fn(), function () { return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(null); });</p><p>    };</p><p>    return PreloadAllModules;</p><p>}());</p><p>/**</p><p> * \@whatItDoes Provides a preloading strategy that does not preload any modules.</p><p> *</p><p> * \@description</p><p> *</p><p> * This strategy is enabled by default.</p><p> *</p><p> * \@experimental</p><p> */</p><p>var NoPreloading = (function () {</p><p>    function NoPreloading() {</p><p>    }</p><p>    /**</p><p>     * @param {?} route</p><p>     * @param {?} fn</p><p>     * @return {?}</p><p>     */</p><p>    NoPreloading.prototype.preload = function (route, fn) { return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(null); };</p><p>    return NoPreloading;</p><p>}());</p><p>/**</p><p> * The preloader optimistically loads all router configurations to</p><p> * make navigations into lazily-loaded sections of the application faster.</p><p> *</p><p> * The preloader runs in the background. When the router bootstraps, the preloader</p><p> * starts listening to all navigation events. After every such event, the preloader</p><p> * will check if any configurations can be loaded lazily.</p><p> *</p><p> * If a route is protected by `canLoad` guards, the preloaded will not load it.</p><p> *</p><p> * \@stable</p><p> */</p><p>var RouterPreloader = (function () {</p><p>    /**</p><p>     * @param {?} router</p><p>     * @param {?} moduleLoader</p><p>     * @param {?} compiler</p><p>     * @param {?} injector</p><p>     * @param {?} preloadingStrategy</p><p>     */</p><p>    function RouterPreloader(router, moduleLoader, compiler, injector, preloadingStrategy) {</p><p>        this.router = router;</p><p>        this.injector = injector;</p><p>        this.preloadingStrategy = preloadingStrategy;</p><p>        var onStartLoad = function (r) { return router.triggerEvent(new RouteConfigLoadStart(r)); };</p><p>        var onEndLoad = function (r) { return router.triggerEvent(new RouteConfigLoadEnd(r)); };</p><p>        this.loader = new RouterConfigLoader(moduleLoader, compiler, onStartLoad, onEndLoad);</p><p>    }</p><p>    ;</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    RouterPreloader.prototype.setUpPreloading = function () {</p><p>        var _this = this;</p><p>        var /** @type {?} */ navigations$ = __WEBPACK_IMPORTED_MODULE_21_rxjs_operator_filter__["filter"].call(this.router.events, function (e) { return e instanceof NavigationEnd; });</p><p>        this.subscription = __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_concatMap__["concatMap"].call(navigations$, function () { return _this.preload(); }).subscribe(function () { });</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    RouterPreloader.prototype.preload = function () {</p><p>        var /** @type {?} */ ngModule = this.injector.get(__WEBPACK_IMPORTED_MODULE_2__angular_core__["NgModuleRef"]);</p><p>        return this.processRoutes(ngModule, this.router.config);</p><p>    };</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    RouterPreloader.prototype.ngOnDestroy = function () { this.subscription.unsubscribe(); };</p><p>    /**</p><p>     * @param {?} ngModule</p><p>     * @param {?} routes</p><p>     * @return {?}</p><p>     */</p><p>    RouterPreloader.prototype.processRoutes = function (ngModule, routes) {</p><p>        var /** @type {?} */ res = [];</p><p>        for (var _i = 0, routes_5 = routes; _i < routes_5.length; _i++) {</p><p>            var route = routes_5[_i];</p><p>            // we already have the config loaded, just recurse</p><p>            if (route.loadChildren && !route.canLoad && route._loadedConfig) {</p><p>                var /** @type {?} */ childConfig = route._loadedConfig;</p><p>                res.push(this.processRoutes(childConfig.module, childConfig.routes));</p><p>                // no config loaded, fetch the config</p><p>            }</p><p>            else if (route.loadChildren && !route.canLoad) {</p><p>                res.push(this.preloadConfig(ngModule, route));</p><p>                // recurse into children</p><p>            }</p><p>            else if (route.children) {</p><p>                res.push(this.processRoutes(ngModule, route.children));</p><p>            }</p><p>        }</p><p>        return __WEBPACK_IMPORTED_MODULE_19_rxjs_operator_mergeAll__["mergeAll"].call(Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_from__["from"])(res));</p><p>    };</p><p>    /**</p><p>     * @param {?} ngModule</p><p>     * @param {?} route</p><p>     * @return {?}</p><p>     */</p><p>    RouterPreloader.prototype.preloadConfig = function (ngModule, route) {</p><p>        var _this = this;</p><p>        return this.preloadingStrategy.preload(route, function () {</p><p>            var /** @type {?} */ loaded$ = _this.loader.load(ngModule.injector, route);</p><p>            return __WEBPACK_IMPORTED_MODULE_12_rxjs_operator_mergeMap__["mergeMap"].call(loaded$, function (config) {</p><p>                route._loadedConfig = config;</p><p>                return _this.processRoutes(config.module, config.routes);</p><p>            });</p><p>        });</p><p>    };</p><p>    return RouterPreloader;</p><p>}());</p><p>RouterPreloader.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>RouterPreloader.ctorParameters = function () { return [</p><p>    { type: Router, },</p><p>    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["NgModuleFactoryLoader"], },</p><p>    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Compiler"], },</p><p>    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Injector"], },</p><p>    { type: PreloadingStrategy, },</p><p>]; };</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * \@whatItDoes Contains a list of directives</p><p> * \@stable</p><p> */</p><p>var ROUTER_DIRECTIVES = [RouterOutlet, RouterLink, RouterLinkWithHref, RouterLinkActive];</p><p>/**</p><p> * \@whatItDoes Is used in DI to configure the router.</p><p> * \@stable</p><p> */</p><p>var ROUTER_CONFIGURATION = new __WEBPACK_IMPORTED_MODULE_2__angular_core__["InjectionToken"]('ROUTER_CONFIGURATION');</p><p>/**</p><p> * \@docsNotRequired</p><p> */</p><p>var ROUTER_FORROOT_GUARD = new __WEBPACK_IMPORTED_MODULE_2__angular_core__["InjectionToken"]('ROUTER_FORROOT_GUARD');</p><p>var ROUTER_PROVIDERS = [</p><p>    __WEBPACK_IMPORTED_MODULE_1__angular_common__["Location"],</p><p>    { provide: UrlSerializer, useClass: DefaultUrlSerializer },</p><p>    {</p><p>        provide: Router,</p><p>        useFactory: setupRouter,</p><p>        deps: [</p><p>            __WEBPACK_IMPORTED_MODULE_2__angular_core__["ApplicationRef"], UrlSerializer, ChildrenOutletContexts, __WEBPACK_IMPORTED_MODULE_1__angular_common__["Location"], __WEBPACK_IMPORTED_MODULE_2__angular_core__["Injector"],</p><p>            __WEBPACK_IMPORTED_MODULE_2__angular_core__["NgModuleFactoryLoader"], __WEBPACK_IMPORTED_MODULE_2__angular_core__["Compiler"], ROUTES, ROUTER_CONFIGURATION,</p><p>            [UrlHandlingStrategy, new __WEBPACK_IMPORTED_MODULE_2__angular_core__["Optional"]()], [RouteReuseStrategy, new __WEBPACK_IMPORTED_MODULE_2__angular_core__["Optional"]()]</p><p>        ]</p><p>    },</p><p>    ChildrenOutletContexts,</p><p>    { provide: ActivatedRoute, useFactory: rootRoute, deps: [Router] },</p><p>    { provide: __WEBPACK_IMPORTED_MODULE_2__angular_core__["NgModuleFactoryLoader"], useClass: __WEBPACK_IMPORTED_MODULE_2__angular_core__["SystemJsNgModuleLoader"] },</p><p>    RouterPreloader,</p><p>    NoPreloading,</p><p>    PreloadAllModules,</p><p>    { provide: ROUTER_CONFIGURATION, useValue: { enableTracing: false } },</p><p>];</p><p>/**</p><p> * @return {?}</p><p> */</p><p>function routerNgProbeToken() {</p><p>    return new __WEBPACK_IMPORTED_MODULE_2__angular_core__["NgProbeToken"]('Router', Router);</p><p>}</p><p>/**</p><p> * \@whatItDoes Adds router directives and providers.</p><p> *</p><p> * \@howToUse</p><p> *</p><p> * RouterModule can be imported multiple times: once per lazily-loaded bundle.</p><p> * Since the router deals with a global shared resource--location, we cannot have</p><p> * more than one router service active.</p><p> *</p><p> * That is why there are two ways to create the module: `RouterModule.forRoot` and</p><p> * `RouterModule.forChild`.</p><p> *</p><p> * * `forRoot` creates a module that contains all the directives, the given routes, and the router</p><p> *   service itself.</p><p> * * `forChild` creates a module that contains all the directives and the given routes, but does not</p><p> *   include the router service.</p><p> *</p><p> * When registered at the root, the module should be used as follows</p><p> *</p><p> * ```</p><p> * \@NgModule({</p><p> *   imports: [RouterModule.forRoot(ROUTES)]</p><p> * })</p><p> * class MyNgModule {}</p><p> * ```</p><p> *</p><p> * For submodules and lazy loaded submodules the module should be used as follows:</p><p> *</p><p> * ```</p><p> * \@NgModule({</p><p> *   imports: [RouterModule.forChild(ROUTES)]</p><p> * })</p><p> * class MyNgModule {}</p><p> * ```</p><p> *</p><p> * \@description</p><p> *</p><p> * Managing state transitions is one of the hardest parts of building applications. This is</p><p> * especially true on the web, where you also need to ensure that the state is reflected in the URL.</p><p> * In addition, we often want to split applications into multiple bundles and load them on demand.</p><p> * Doing this transparently is not trivial.</p><p> *</p><p> * The Angular router solves these problems. Using the router, you can declaratively specify</p><p> * application states, manage state transitions while taking care of the URL, and load bundles on</p><p> * demand.</p><p> *</p><p> * [Read this developer guide](https://angular.io/docs/ts/latest/guide/router.html) to get an</p><p> * overview of how the router should be used.</p><p> *</p><p> * \@stable</p><p> */</p><p>var RouterModule = (function () {</p><p>    /**</p><p>     * @param {?} guard</p><p>     * @param {?} router</p><p>     */</p><p>    function RouterModule(guard, router) {</p><p>    }</p><p>    /**</p><p>     * Creates a module with all the router providers and directives. It also optionally sets up an</p><p>     * application listener to perform an initial navigation.</p><p>     *</p><p>     * Options:</p><p>     * * `enableTracing` makes the router log all its internal events to the console.</p><p>     * * `useHash` enables the location strategy that uses the URL fragment instead of the history</p><p>     * API.</p><p>     * * `initialNavigation` disables the initial navigation.</p><p>     * * `errorHandler` provides a custom error handler.</p><p>     * @param {?} routes</p><p>     * @param {?=} config</p><p>     * @return {?}</p><p>     */</p><p>    RouterModule.forRoot = function (routes, config) {</p><p>        return {</p><p>            ngModule: RouterModule,</p><p>            providers: [</p><p>                ROUTER_PROVIDERS,</p><p>                provideRoutes(routes),</p><p>                {</p><p>                    provide: ROUTER_FORROOT_GUARD,</p><p>                    useFactory: provideForRootGuard,</p><p>                    deps: [[Router, new __WEBPACK_IMPORTED_MODULE_2__angular_core__["Optional"](), new __WEBPACK_IMPORTED_MODULE_2__angular_core__["SkipSelf"]()]]</p><p>                },</p><p>                { provide: ROUTER_CONFIGURATION, useValue: config ? config : {} },</p><p>                {</p><p>                    provide: __WEBPACK_IMPORTED_MODULE_1__angular_common__["LocationStrategy"],</p><p>                    useFactory: provideLocationStrategy,</p><p>                    deps: [</p><p>                        __WEBPACK_IMPORTED_MODULE_1__angular_common__["PlatformLocation"], [new __WEBPACK_IMPORTED_MODULE_2__angular_core__["Inject"](__WEBPACK_IMPORTED_MODULE_1__angular_common__["APP_BASE_HREF"]), new __WEBPACK_IMPORTED_MODULE_2__angular_core__["Optional"]()], ROUTER_CONFIGURATION</p><p>                    ]</p><p>                },</p><p>                {</p><p>                    provide: PreloadingStrategy,</p><p>                    useExisting: config && config.preloadingStrategy ? config.preloadingStrategy :</p><p>                        NoPreloading</p><p>                },</p><p>                { provide: __WEBPACK_IMPORTED_MODULE_2__angular_core__["NgProbeToken"], multi: true, useFactory: routerNgProbeToken },</p><p>                provideRouterInitializer(),</p><p>            ],</p><p>        };</p><p>    };</p><p>    /**</p><p>     * Creates a module with all the router directives and a provider registering routes.</p><p>     * @param {?} routes</p><p>     * @return {?}</p><p>     */</p><p>    RouterModule.forChild = function (routes) {</p><p>        return { ngModule: RouterModule, providers: [provideRoutes(routes)] };</p><p>    };</p><p>    return RouterModule;</p><p>}());</p><p>RouterModule.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["NgModule"], args: [{ declarations: ROUTER_DIRECTIVES, exports: ROUTER_DIRECTIVES },] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>RouterModule.ctorParameters = function () { return [</p><p>    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Optional"] }, { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Inject"], args: [ROUTER_FORROOT_GUARD,] },] },</p><p>    { type: Router, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Optional"] },] },</p><p>]; };</p><p>/**</p><p> * @param {?} platformLocationStrategy</p><p> * @param {?} baseHref</p><p> * @param {?=} options</p><p> * @return {?}</p><p> */</p><p>function provideLocationStrategy(platformLocationStrategy, baseHref, options) {</p><p>    if (options === void 0) { options = {}; }</p><p>    return options.useHash ? new __WEBPACK_IMPORTED_MODULE_1__angular_common__["HashLocationStrategy"](platformLocationStrategy, baseHref) :</p><p>        new __WEBPACK_IMPORTED_MODULE_1__angular_common__["PathLocationStrategy"](platformLocationStrategy, baseHref);</p><p>}</p><p>/**</p><p> * @param {?} router</p><p> * @return {?}</p><p> */</p><p>function provideForRootGuard(router) {</p><p>    if (router) {</p><p>        throw new Error("RouterModule.forRoot() called twice. Lazy loaded modules should use RouterModule.forChild() instead.");</p><p>    }</p><p>    return 'guarded';</p><p>}</p><p>/**</p><p> * \@whatItDoes Registers routes.</p><p> *</p><p> * \@howToUse</p><p> *</p><p> * ```</p><p> * \@NgModule({</p><p> *   imports: [RouterModule.forChild(ROUTES)],</p><p> *   providers: [provideRoutes(EXTRA_ROUTES)]</p><p> * })</p><p> * class MyNgModule {}</p><p> * ```</p><p> *</p><p> * \@stable</p><p> * @param {?} routes</p><p> * @return {?}</p><p> */</p><p>function provideRoutes(routes) {</p><p>    return [</p><p>        { provide: __WEBPACK_IMPORTED_MODULE_2__angular_core__["ANALYZE_FOR_ENTRY_COMPONENTS"], multi: true, useValue: routes },</p><p>        { provide: ROUTES, multi: true, useValue: routes },</p><p>    ];</p><p>}</p><p>/**</p><p> * @param {?} ref</p><p> * @param {?} urlSerializer</p><p> * @param {?} contexts</p><p> * @param {?} location</p><p> * @param {?} injector</p><p> * @param {?} loader</p><p> * @param {?} compiler</p><p> * @param {?} config</p><p> * @param {?=} opts</p><p> * @param {?=} urlHandlingStrategy</p><p> * @param {?=} routeReuseStrategy</p><p> * @return {?}</p><p> */</p><p>function setupRouter(ref, urlSerializer, contexts, location, injector, loader, compiler, config, opts, urlHandlingStrategy, routeReuseStrategy) {</p><p>    if (opts === void 0) { opts = {}; }</p><p>    var /** @type {?} */ router = new Router(null, urlSerializer, contexts, location, injector, loader, compiler, flatten(config));</p><p>    if (urlHandlingStrategy) {</p><p>        router.urlHandlingStrategy = urlHandlingStrategy;</p><p>    }</p><p>    if (routeReuseStrategy) {</p><p>        router.routeReuseStrategy = routeReuseStrategy;</p><p>    }</p><p>    if (opts.errorHandler) {</p><p>        router.errorHandler = opts.errorHandler;</p><p>    }</p><p>    if (opts.enableTracing) {</p><p>        var /** @type {?} */ dom_1 = Object(__WEBPACK_IMPORTED_MODULE_20__angular_platform_browser__["ɵgetDOM"])();</p><p>        router.events.subscribe(function (e) {</p><p>            dom_1.logGroup("Router Event: " + ((e.constructor)).name);</p><p>            dom_1.log(e.toString());</p><p>            dom_1.log(e);</p><p>            dom_1.logGroupEnd();</p><p>        });</p><p>    }</p><p>    return router;</p><p>}</p><p>/**</p><p> * @param {?} router</p><p> * @return {?}</p><p> */</p><p>function rootRoute(router) {</p><p>    return router.routerState.root;</p><p>}</p><p>/**</p><p> * To initialize the router properly we need to do in two steps:</p><p> *</p><p> * We need to start the navigation in a APP_INITIALIZER to block the bootstrap if</p><p> * a resolver or a guards executes asynchronously. Second, we need to actually run</p><p> * activation in a BOOTSTRAP_LISTENER. We utilize the afterPreactivation</p><p> * hook provided by the router to do that.</p><p> *</p><p> * The router navigation starts, reaches the point when preactivation is done, and then</p><p> * pauses. It waits for the hook to be resolved. We then resolve it only in a bootstrap listener.</p><p> */</p><p>var RouterInitializer = (function () {</p><p>    /**</p><p>     * @param {?} injector</p><p>     */</p><p>    function RouterInitializer(injector) {</p><p>        this.injector = injector;</p><p>        this.initNavigation = false;</p><p>        this.resultOfPreactivationDone = new __WEBPACK_IMPORTED_MODULE_4_rxjs_Subject__["Subject"]();</p><p>    }</p><p>    /**</p><p>     * @return {?}</p><p>     */</p><p>    RouterInitializer.prototype.appInitializer = function () {</p><p>        var _this = this;</p><p>        var /** @type {?} */ p = this.injector.get(__WEBPACK_IMPORTED_MODULE_1__angular_common__["LOCATION_INITIALIZED"], Promise.resolve(null));</p><p>        return p.then(function () {</p><p>            var /** @type {?} */ resolve = ((null));</p><p>            var /** @type {?} */ res = new Promise(function (r) { return resolve = r; });</p><p>            var /** @type {?} */ router = _this.injector.get(Router);</p><p>            var /** @type {?} */ opts = _this.injector.get(ROUTER_CONFIGURATION);</p><p>            if (_this.isLegacyDisabled(opts) || _this.isLegacyEnabled(opts)) {</p><p>                resolve(true);</p><p>            }</p><p>            else if (opts.initialNavigation === 'disabled') {</p><p>                router.setUpLocationChangeListener();</p><p>                resolve(true);</p><p>            }</p><p>            else if (opts.initialNavigation === 'enabled') {</p><p>                router.hooks.afterPreactivation = function () {</p><p>                    // only the initial navigation should be delayed</p><p>                    if (!_this.initNavigation) {</p><p>                        _this.initNavigation = true;</p><p>                        resolve(true);</p><p>                        return _this.resultOfPreactivationDone;</p><p>                        // subsequent navigations should not be delayed</p><p>                    }</p><p>                    else {</p><p>                        return (Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_of__["of"])(null));</p><p>                    }</p><p>                };</p><p>                router.initialNavigation();</p><p>            }</p><p>            else {</p><p>                throw new Error("Invalid initialNavigation options: '" + opts.initialNavigation + "'");</p><p>            }</p><p>            return res;</p><p>        });</p><p>    };</p><p>    /**</p><p>     * @param {?} bootstrappedComponentRef</p><p>     * @return {?}</p><p>     */</p><p>    RouterInitializer.prototype.bootstrapListener = function (bootstrappedComponentRef) {</p><p>        var /** @type {?} */ opts = this.injector.get(ROUTER_CONFIGURATION);</p><p>        var /** @type {?} */ preloader = this.injector.get(RouterPreloader);</p><p>        var /** @type {?} */ router = this.injector.get(Router);</p><p>        var /** @type {?} */ ref = this.injector.get(__WEBPACK_IMPORTED_MODULE_2__angular_core__["ApplicationRef"]);</p><p>        if (bootstrappedComponentRef !== ref.components[0]) {</p><p>            return;</p><p>        }</p><p>        if (this.isLegacyEnabled(opts)) {</p><p>            router.initialNavigation();</p><p>        }</p><p>        else if (this.isLegacyDisabled(opts)) {</p><p>            router.setUpLocationChangeListener();</p><p>        }</p><p>        preloader.setUpPreloading();</p><p>        router.resetRootComponentType(ref.componentTypes[0]);</p><p>        this.resultOfPreactivationDone.next(/** @type {?} */ ((null)));</p><p>        this.resultOfPreactivationDone.complete();</p><p>    };</p><p>    /**</p><p>     * @param {?} opts</p><p>     * @return {?}</p><p>     */</p><p>    RouterInitializer.prototype.isLegacyEnabled = function (opts) {</p><p>        return opts.initialNavigation === 'legacy_enabled' || opts.initialNavigation === true ||</p><p>            opts.initialNavigation === undefined;</p><p>    };</p><p>    /**</p><p>     * @param {?} opts</p><p>     * @return {?}</p><p>     */</p><p>    RouterInitializer.prototype.isLegacyDisabled = function (opts) {</p><p>        return opts.initialNavigation === 'legacy_disabled' || opts.initialNavigation === false;</p><p>    };</p><p>    return RouterInitializer;</p><p>}());</p><p>RouterInitializer.decorators = [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"] },</p><p>];</p><p>/**</p><p> * @nocollapse</p><p> */</p><p>RouterInitializer.ctorParameters = function () { return [</p><p>    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__["Injector"], },</p><p>]; };</p><p>/**</p><p> * @param {?} r</p><p> * @return {?}</p><p> */</p><p>function getAppInitializer(r) {</p><p>    return r.appInitializer.bind(r);</p><p>}</p><p>/**</p><p> * @param {?} r</p><p> * @return {?}</p><p> */</p><p>function getBootstrapListener(r) {</p><p>    return r.bootstrapListener.bind(r);</p><p>}</p><p>/**</p><p> * A token for the router initializer that will be called after the app is bootstrapped.</p><p> *</p><p> * \@experimental</p><p> */</p><p>var ROUTER_INITIALIZER = new __WEBPACK_IMPORTED_MODULE_2__angular_core__["InjectionToken"]('Router Initializer');</p><p>/**</p><p> * @return {?}</p><p> */</p><p>function provideRouterInitializer() {</p><p>    return [</p><p>        RouterInitializer,</p><p>        {</p><p>            provide: __WEBPACK_IMPORTED_MODULE_2__angular_core__["APP_INITIALIZER"],</p><p>            multi: true,</p><p>            useFactory: getAppInitializer,</p><p>            deps: [RouterInitializer]</p><p>        },</p><p>        { provide: ROUTER_INITIALIZER, useFactory: getBootstrapListener, deps: [RouterInitializer] },</p><p>        { provide: __WEBPACK_IMPORTED_MODULE_2__angular_core__["APP_BOOTSTRAP_LISTENER"], multi: true, useExisting: ROUTER_INITIALIZER },</p><p>    ];</p><p>}</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * @module</p><p> * @description</p><p> * Entry point for all public APIs of the common package.</p><p> */</p><p>/**</p><p> * \@stable</p><p> */</p><p>var VERSION = new __WEBPACK_IMPORTED_MODULE_2__angular_core__["Version"]('4.3.5');</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * @license</p><p> * Copyright Google Inc. All Rights Reserved.</p><p> *</p><p> * Use of this source code is governed by an MIT-style license that can be</p><p> * found in the LICENSE file at https://angular.io/license</p><p> */</p><p>/**</p><p> * @module</p><p> * @description</p><p> * Entry point for all public APIs of the router package.</p><p> */</p><p>// This file only reexports content of the `src` folder. Keep it that way.</p><p>/**</p><p> * Generated bundle index. Do not edit.</p><p> */</p><p></p><p>//# sourceMappingURL=router.es5.js.map</p><p></p><p></p><p>/***/ })</p><p></p><p>}</p>
  
### Reference
* http://blogs.wsj.com/cio/2013/10/08/adobe-source-code-leak-is-bad-news-for-u-s-government/

  
#### CWE Id : 540
  
#### WASC Id : 13
  
#### Source ID : 3

  
  
  
  
### Sub Resource Integrity Attribute Missing
##### Medium (High)
  
  
  
  
#### Description
<p>The integrity attribute is missing on a script or link tag served by an external server. The integrity tag prevents an attacker who have gained access to this server from injecting a malicious content. </p>
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr](https://datacollecte.equipements.sports.gouv.fr)
  
  
  * Method: `GET`
  
  
  * Evidence: `<script src="https://www.google.com/recaptcha/api.js?render=explicit&onload=initRecaptcha" async defer></script>`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/](https://datacollecte.equipements.sports.gouv.fr/)
  
  
  * Method: `GET`
  
  
  * Evidence: `<script src="https://www.google.com/recaptcha/api.js?render=explicit&onload=initRecaptcha" async defer></script>`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/robots.txt](https://datacollecte.equipements.sports.gouv.fr/robots.txt)
  
  
  * Method: `GET`
  
  
  * Evidence: `<script src="https://www.google.com/recaptcha/api.js?render=explicit&onload=initRecaptcha" async defer></script>`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/sitemap.xml](https://datacollecte.equipements.sports.gouv.fr/sitemap.xml)
  
  
  * Method: `GET`
  
  
  * Evidence: `<script src="https://www.google.com/recaptcha/api.js?render=explicit&onload=initRecaptcha" async defer></script>`
  
  
  
  
Instances: 4
  
### Solution
<p>Provide a valid integrity attribute to the tag.</p>
  
### Reference
* https://developer.mozilla.org/en/docs/Web/Security/Subresource_Integrity

  
#### CWE Id : 16
  
#### WASC Id : 15
  
#### Source ID : 3

  
  
  
  
### Vulnerable JS Library
##### Medium (Medium)
  
  
  
  
#### Description
<p>The identified library bootstrap, version 3.3.7 is vulnerable.</p>
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/styles.bundle.js](https://datacollecte.equipements.sports.gouv.fr/styles.bundle.js)
  
  
  * Method: `GET`
  
  
  * Evidence: `* Bootstrap v3.3.7`
  
  
  
  
Instances: 1
  
### Solution
<p>Please upgrade to the latest version of bootstrap.</p>
  
### Other information
<p>CVE-2019-8331</p><p>CVE-2018-14041</p><p>CVE-2018-14040</p><p>CVE-2018-14042</p><p></p>
  
### Reference
* https://github.com/twbs/bootstrap/issues/28236
* https://github.com/twbs/bootstrap/issues/20184
* 

  
#### CWE Id : 829
  
#### Source ID : 3

  
  
  
  
### Cookie Without SameSite Attribute
##### Low (Medium)
  
  
  
  
#### Description
<p>A cookie has been set without the SameSite attribute, which means that the cookie can be sent as a result of a 'cross-site' request. The SameSite attribute is an effective counter measure to cross-site request forgery, cross-site script inclusion, and timing attacks.</p>
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr](https://datacollecte.equipements.sports.gouv.fr)
  
  
  * Method: `GET`
  
  
  * Parameter: `BIGipServerpool-dsb5-dataes.cegedim.cloud-HTTP`
  
  
  * Evidence: `Set-Cookie: BIGipServerpool-dsb5-dataes.cegedim.cloud-HTTP`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/](https://datacollecte.equipements.sports.gouv.fr/)
  
  
  * Method: `GET`
  
  
  * Parameter: `BIGipServerpool-dsb5-dataes.cegedim.cloud-HTTP`
  
  
  * Evidence: `Set-Cookie: BIGipServerpool-dsb5-dataes.cegedim.cloud-HTTP`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/robots.txt](https://datacollecte.equipements.sports.gouv.fr/robots.txt)
  
  
  * Method: `GET`
  
  
  * Parameter: `BIGipServerpool-dsb5-dataes.cegedim.cloud-HTTP`
  
  
  * Evidence: `Set-Cookie: BIGipServerpool-dsb5-dataes.cegedim.cloud-HTTP`
  
  
  
  
Instances: 3
  
### Solution
<p>Ensure that the SameSite attribute is set to either 'lax' or ideally 'strict' for all cookies.</p>
  
### Reference
* https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site

  
#### CWE Id : 16
  
#### WASC Id : 13
  
#### Source ID : 3

  
  
  
  
### Cross-Domain JavaScript Source File Inclusion
##### Low (Medium)
  
  
  
  
#### Description
<p>The page includes one or more script files from a third-party domain.</p>
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/sitemap.xml](https://datacollecte.equipements.sports.gouv.fr/sitemap.xml)
  
  
  * Method: `GET`
  
  
  * Parameter: `https://www.google.com/recaptcha/api.js?render=explicit&onload=initRecaptcha`
  
  
  * Evidence: `<script src="https://www.google.com/recaptcha/api.js?render=explicit&onload=initRecaptcha" async defer></script>`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/robots.txt](https://datacollecte.equipements.sports.gouv.fr/robots.txt)
  
  
  * Method: `GET`
  
  
  * Parameter: `https://www.google.com/recaptcha/api.js?render=explicit&onload=initRecaptcha`
  
  
  * Evidence: `<script src="https://www.google.com/recaptcha/api.js?render=explicit&onload=initRecaptcha" async defer></script>`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/](https://datacollecte.equipements.sports.gouv.fr/)
  
  
  * Method: `GET`
  
  
  * Parameter: `https://www.google.com/recaptcha/api.js?render=explicit&onload=initRecaptcha`
  
  
  * Evidence: `<script src="https://www.google.com/recaptcha/api.js?render=explicit&onload=initRecaptcha" async defer></script>`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr](https://datacollecte.equipements.sports.gouv.fr)
  
  
  * Method: `GET`
  
  
  * Parameter: `https://www.google.com/recaptcha/api.js?render=explicit&onload=initRecaptcha`
  
  
  * Evidence: `<script src="https://www.google.com/recaptcha/api.js?render=explicit&onload=initRecaptcha" async defer></script>`
  
  
  
  
Instances: 4
  
### Solution
<p>Ensure JavaScript source files are loaded from only trusted sources, and the sources can't be controlled by end users of the application.</p>
  
### Reference
* 

  
#### CWE Id : 829
  
#### WASC Id : 15
  
#### Source ID : 3

  
  
  
  
### CSP: Notices
##### Low (Medium)
  
  
  
  
#### Description
<p>Warnings:</p><p>1:1: The upgrade-insecure-requests directive is an experimental directive that will be likely added to the CSP specification.</p><p></p>
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr](https://datacollecte.equipements.sports.gouv.fr)
  
  
  * Method: `GET`
  
  
  * Parameter: `Content-Security-Policy`
  
  
  * Evidence: `upgrade-insecure-requests`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/](https://datacollecte.equipements.sports.gouv.fr/)
  
  
  * Method: `GET`
  
  
  * Parameter: `Content-Security-Policy`
  
  
  * Evidence: `upgrade-insecure-requests`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/robots.txt](https://datacollecte.equipements.sports.gouv.fr/robots.txt)
  
  
  * Method: `GET`
  
  
  * Parameter: `Content-Security-Policy`
  
  
  * Evidence: `upgrade-insecure-requests`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/sitemap.xml](https://datacollecte.equipements.sports.gouv.fr/sitemap.xml)
  
  
  * Method: `GET`
  
  
  * Parameter: `Content-Security-Policy`
  
  
  * Evidence: `upgrade-insecure-requests`
  
  
  
  
Instances: 4
  
### Solution
<p>Ensure that your web server, application server, load balancer, etc. is properly configured to set the Content-Security-Policy header.</p>
  
### Reference
* http://www.w3.org/TR/CSP2/
* http://www.w3.org/TR/CSP/
* http://caniuse.com/#search=content+security+policy
* http://content-security-policy.com/
* https://github.com/shapesecurity/salvation
* https://developers.google.com/web/fundamentals/security/csp#policy_applies_to_a_wide_variety_of_resources

  
#### CWE Id : 16
  
#### WASC Id : 15
  
#### Source ID : 3

  
  
  
  
### Dangerous JS Functions
##### Low (Low)
  
  
  
  
#### Description
<p>A dangerous JS function seems to be in use that would leave the site vulnerable.</p>
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/main.bundle.js](https://datacollecte.equipements.sports.gouv.fr/main.bundle.js)
  
  
  * Method: `GET`
  
  
  * Evidence: `eVal`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/polyfills.bundle.js](https://datacollecte.equipements.sports.gouv.fr/polyfills.bundle.js)
  
  
  * Method: `GET`
  
  
  * Evidence: `eVal`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/scripts.bundle.js](https://datacollecte.equipements.sports.gouv.fr/scripts.bundle.js)
  
  
  * Method: `GET`
  
  
  * Evidence: `eVal`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/vendor.bundle.js](https://datacollecte.equipements.sports.gouv.fr/vendor.bundle.js)
  
  
  * Method: `GET`
  
  
  * Evidence: `bypassSecurityTrustHtml`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/styles.bundle.js](https://datacollecte.equipements.sports.gouv.fr/styles.bundle.js)
  
  
  * Method: `GET`
  
  
  * Evidence: `eVal`
  
  
  
  
Instances: 5
  
### Solution
<p>See the references for security advice on the use of these functions.</p>
  
### Reference
* https://angular.io/guide/security

  
#### CWE Id : 749
  
#### Source ID : 3

  
  
  
  
### Feature Policy Header Not Set
##### Low (Medium)
  
  
  
  
#### Description
<p>Feature Policy Header is an added layer of security that helps to restrict from unauthorized access or usage of browser/client features by web resources. This policy ensures the user privacy by limiting or specifying the features of the browsers can be used by the web resources. Feature Policy provides a set of standard HTTP headers that allow website owners to limit which features of browsers can be used by the page such as camera, microphone, location, full screen etc.</p>
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/polyfills.bundle.js](https://datacollecte.equipements.sports.gouv.fr/polyfills.bundle.js)
  
  
  * Method: `GET`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/](https://datacollecte.equipements.sports.gouv.fr/)
  
  
  * Method: `GET`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr](https://datacollecte.equipements.sports.gouv.fr)
  
  
  * Method: `GET`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/inline.bundle.js](https://datacollecte.equipements.sports.gouv.fr/inline.bundle.js)
  
  
  * Method: `GET`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/styles.bundle.js](https://datacollecte.equipements.sports.gouv.fr/styles.bundle.js)
  
  
  * Method: `GET`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/main.bundle.js](https://datacollecte.equipements.sports.gouv.fr/main.bundle.js)
  
  
  * Method: `GET`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/robots.txt](https://datacollecte.equipements.sports.gouv.fr/robots.txt)
  
  
  * Method: `GET`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/sitemap.xml](https://datacollecte.equipements.sports.gouv.fr/sitemap.xml)
  
  
  * Method: `GET`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/vendor.bundle.js](https://datacollecte.equipements.sports.gouv.fr/vendor.bundle.js)
  
  
  * Method: `GET`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/scripts.bundle.js](https://datacollecte.equipements.sports.gouv.fr/scripts.bundle.js)
  
  
  * Method: `GET`
  
  
  
  
Instances: 10
  
### Solution
<p>Ensure that your web server, application server, load balancer, etc. is configured to set the Feature-Policy header.</p>
  
### Reference
* https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Feature-Policy
* https://developers.google.com/web/updates/2018/06/feature-policy
* https://scotthelme.co.uk/a-new-security-header-feature-policy/
* https://w3c.github.io/webappsec-feature-policy/
* https://www.smashingmagazine.com/2018/12/feature-policy/

  
#### CWE Id : 16
  
#### WASC Id : 15
  
#### Source ID : 3

  
  
  
  
### Incomplete or No Cache-control and Pragma HTTP Header Set
##### Low (Medium)
  
  
  
  
#### Description
<p>The cache-control and pragma HTTP header have not been set properly or are missing allowing the browser and proxies to cache content.</p>
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/](https://datacollecte.equipements.sports.gouv.fr/)
  
  
  * Method: `GET`
  
  
  * Parameter: `Cache-Control`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr](https://datacollecte.equipements.sports.gouv.fr)
  
  
  * Method: `GET`
  
  
  * Parameter: `Cache-Control`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/robots.txt](https://datacollecte.equipements.sports.gouv.fr/robots.txt)
  
  
  * Method: `GET`
  
  
  * Parameter: `Cache-Control`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/sitemap.xml](https://datacollecte.equipements.sports.gouv.fr/sitemap.xml)
  
  
  * Method: `GET`
  
  
  * Parameter: `Cache-Control`
  
  
  
  
Instances: 4
  
### Solution
<p>Whenever possible ensure the cache-control HTTP header is set with no-cache, no-store, must-revalidate; and that the pragma HTTP header is set with no-cache.</p>
  
### Reference
* https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html#web-content-caching

  
#### CWE Id : 525
  
#### WASC Id : 13
  
#### Source ID : 3

  
  
  
  
### Base64 Disclosure
##### Informational (Medium)
  
  
  
  
#### Description
<p>Base64 encoded data was disclosed by the application/web server. Note: in the interests of performance not all base64 strings in the response were analyzed individually, the entire response should be looked at by the analyst/security team/developer(s).</p>
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/main.bundle.js](https://datacollecte.equipements.sports.gouv.fr/main.bundle.js)
  
  
  * Method: `GET`
  
  
  * Evidence: `eyJmaWxlIjoiRDovMDJfZGV2cy9hcHAvbmV0YXBzeXMvUkVTL3RpcmFtaXN1LXJlcy12Mi9SRVMvc3JjL0NsaWVudC9yZXMvc3JjL2FwcC9hcHAuY29tcG9uZW50LmNzcy5zaGltLm5nc3R5bGUudHMiLCJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJuZzovLy9EOi8wMl9kZXZzL2FwcC9uZXRhcHN5cy9SRVMvdGlyYW1pc3UtcmVzLXYyL1JFUy9zcmMvQ2xpZW50L3Jlcy9zcmMvYXBwL2FwcC5jb21wb25lbnQuY3NzIl0sInNvdXJjZXNDb250ZW50IjpbIiAiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OzsifQ==`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr](https://datacollecte.equipements.sports.gouv.fr)
  
  
  * Method: `GET`
  
  
  * Evidence: `e1VQ+MeQLOdSiCsqJlLL3fNyljz02Sv9XmKIdlSZcdqJ4Kkx6Zzl9vQ/PI4C2BxpNcp5I5AWQA/BquN2c18SOltQbqU=`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/vendor.bundle.js](https://datacollecte.equipements.sports.gouv.fr/vendor.bundle.js)
  
  
  * Method: `GET`
  
  
  * Evidence: `__WEBPACK_IMPORTED_MODULE_0__angular_core__`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/styles.bundle.js](https://datacollecte.equipements.sports.gouv.fr/styles.bundle.js)
  
  
  * Method: `GET`
  
  
  * Evidence: `iVBORw0KGgoAAAANSUhEUgAAAEYAAAAsCAYAAADYQc64AAAAAXNSR0IArs4c6QAAAAlwSFlzAAAWJQAAFiUBSVIk8AAAATpJREFUaAXtmLGNg1AQRM3JtVAECSGiAURIdwQ0QC0IUQBN+KyTWI1sz8l3BmOkR8L8Cf4uTzMJyeX6nHjuCHzdORg/BABjggAYwBgCxiYxgDEEjE1iAGMIGJvEAMYQMDaJAYwhYGwSY8Ccjb+p3XVd3F9VVeh3irquY1zbtqEXQWIWEjdvwNwAWY67VCnP82X+KU3T0MMwhN5aNE3z6wgSY/AAxoBJ9v7nO01TrFaWZegtatX3fdxfFEXoR4LEPKJy9QBjwOxeJd1ri1r9pT66C4lRGqIBIzBUflSVdLFXavXf+uh8EqM0RANGYKj82Crpks/Uao366EwSozREA0ZgqDxElXTheZ7jOI5j6CzLQq8hSIyhCBgD5nBVMt+xuk1iDFLAAMYQMDaJAYwhYGwSAxhDwNgkxoD5Bg+KURfM/L2eAAAAAElFTkSuQmCC`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/robots.txt](https://datacollecte.equipements.sports.gouv.fr/robots.txt)
  
  
  * Method: `GET`
  
  
  * Evidence: `dWgSpUNI7UVh+i4qJlLL3fNyljz02a1dtHCr0sCKNM02y1pJADN41CiqUyTKq5nE3JELqW6mHXI1TeYVFniV+2Pp2Tc=`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/](https://datacollecte.equipements.sports.gouv.fr/)
  
  
  * Method: `GET`
  
  
  * Evidence: `CeVYDrbLsVvK+FoqJlLL3fNyljz02SWbS22rnfXaxbVANOkuVYTr15QmzJtYTQ8uKBcnq/DUGEzKNcduCCzwrBXO4ec=`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/scripts.bundle.js](https://datacollecte.equipements.sports.gouv.fr/scripts.bundle.js)
  
  
  * Method: `GET`
  
  
  * Evidence: `info/licences/Licence_CeCILL-B_V1-en`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/polyfills.bundle.js](https://datacollecte.equipements.sports.gouv.fr/polyfills.bundle.js)
  
  
  * Method: `GET`
  
  
  * Evidence: `__WEBPACK_IMPORTED_MODULE_0_core_js_client_shim_min_js__`
  
  
  
  
Instances: 8
  
### Solution
<p>Manually confirm that the Base64 data does not leak sensitive information, and that the data cannot be aggregated/used to exploit other vulnerabilities.</p>
  
### Other information
<p>{"file":"D:/02_devs/app/netapsys/RES/tiramisu-res-v2/RES/src/Client/res/src/app/app.component.css.shim.ngstyle.ts","version":3,"sourceRoot":"","sources":["ng:///D:/02_devs/app/netapsys/RES/tiramisu-res-v2/RES/src/Client/res/src/app/app.component.css"],"sourcesContent":[" "],"mappings":"AAAA;;;;;;;;"}</p>
  
### Reference
* http://projects.webappsec.org/w/page/13246936/Information%20Leakage

  
#### CWE Id : 200
  
#### WASC Id : 13
  
#### Source ID : 3

  
  
  
  
### Information Disclosure - Suspicious Comments
##### Informational (Low)
  
  
  
  
#### Description
<p>The response appears to contain suspicious comments which may help an attacker. Note: Matches made within script blocks or files are against the entire content not only comments.</p>
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/styles.bundle.js](https://datacollecte.equipements.sports.gouv.fr/styles.bundle.js)
  
  
  * Method: `GET`
  
  
  * Evidence: `query`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/polyfills.bundle.js](https://datacollecte.equipements.sports.gouv.fr/polyfills.bundle.js)
  
  
  * Method: `GET`
  
  
  * Evidence: `bugs`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/polyfills.bundle.js](https://datacollecte.equipements.sports.gouv.fr/polyfills.bundle.js)
  
  
  * Method: `GET`
  
  
  * Evidence: `from`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/styles.bundle.js](https://datacollecte.equipements.sports.gouv.fr/styles.bundle.js)
  
  
  * Method: `GET`
  
  
  * Evidence: `username`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/styles.bundle.js](https://datacollecte.equipements.sports.gouv.fr/styles.bundle.js)
  
  
  * Method: `GET`
  
  
  * Evidence: `user`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/styles.bundle.js](https://datacollecte.equipements.sports.gouv.fr/styles.bundle.js)
  
  
  * Method: `GET`
  
  
  * Evidence: `bug`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/styles.bundle.js](https://datacollecte.equipements.sports.gouv.fr/styles.bundle.js)
  
  
  * Method: `GET`
  
  
  * Evidence: `select`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/polyfills.bundle.js](https://datacollecte.equipements.sports.gouv.fr/polyfills.bundle.js)
  
  
  * Method: `GET`
  
  
  * Evidence: `TODO`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/styles.bundle.js](https://datacollecte.equipements.sports.gouv.fr/styles.bundle.js)
  
  
  * Method: `GET`
  
  
  * Evidence: `TODO`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/styles.bundle.js](https://datacollecte.equipements.sports.gouv.fr/styles.bundle.js)
  
  
  * Method: `GET`
  
  
  * Evidence: `from`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/polyfills.bundle.js](https://datacollecte.equipements.sports.gouv.fr/polyfills.bundle.js)
  
  
  * Method: `GET`
  
  
  * Evidence: `bug`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/polyfills.bundle.js](https://datacollecte.equipements.sports.gouv.fr/polyfills.bundle.js)
  
  
  * Method: `GET`
  
  
  * Evidence: `select`
  
  
  
  
Instances: 12
  
### Solution
<p>Remove all comments that return information that may help an attacker and fix any underlying problems they refer to.</p>
  
### Other information
<p>The following pattern was used: \bQUERY\b and was detected 2 times, the first in the element starting with: "exports.push([module.i, ".ui-widget *{box-sizing:border-box}.ui-helper-hidden{display:none}.ui-helper-hidden-accessible{border:0", see evidence field for the suspicious comment/snippet.</p>
  
### Reference
* 

  
#### CWE Id : 200
  
#### WASC Id : 13
  
#### Source ID : 3

  
  
  
  
### Modern Web Application
##### Informational (Medium)
  
  
  
  
#### Description
<p>The application appears to be a modern web application. If you need to explore it automatically then the Ajax Spider may well be more effective than the standard one.</p>
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/sitemap.xml](https://datacollecte.equipements.sports.gouv.fr/sitemap.xml)
  
  
  * Method: `GET`
  
  
  * Evidence: `<script src="https://www.google.com/recaptcha/api.js?render=explicit&onload=initRecaptcha" async defer></script>`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/vendor.bundle.js](https://datacollecte.equipements.sports.gouv.fr/vendor.bundle.js)
  
  
  * Method: `GET`
  
  
  * Evidence: `<a *ngIf=\"isEllipsis(pageNumber)\" class=\"page-link\">...</a>`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/](https://datacollecte.equipements.sports.gouv.fr/)
  
  
  * Method: `GET`
  
  
  * Evidence: `<script src="https://www.google.com/recaptcha/api.js?render=explicit&onload=initRecaptcha" async defer></script>`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr](https://datacollecte.equipements.sports.gouv.fr)
  
  
  * Method: `GET`
  
  
  * Evidence: `<script src="https://www.google.com/recaptcha/api.js?render=explicit&onload=initRecaptcha" async defer></script>`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/robots.txt](https://datacollecte.equipements.sports.gouv.fr/robots.txt)
  
  
  * Method: `GET`
  
  
  * Evidence: `<script src="https://www.google.com/recaptcha/api.js?render=explicit&onload=initRecaptcha" async defer></script>`
  
  
  
  
Instances: 5
  
### Solution
<p>This is an informational alert and so no changes are required.</p>
  
### Other information
<p>No links have been found while there are scripts, which is an indication that this is a modern web application.</p>
  
### Reference
* 

  
#### Source ID : 3

  
  
  
  
### Storable and Cacheable Content
##### Informational (Medium)
  
  
  
  
#### Description
<p>The response contents are storable by caching components such as proxy servers, and may be retrieved directly from the cache, rather than from the origin server by the caching servers, in response to similar requests from other users.  If the response data is sensitive, personal or user-specific, this may result in sensitive information being leaked. In some cases, this may even result in a user gaining complete control of the session of another user, depending on the configuration of the caching components in use in their environment. This is primarily an issue where "shared" caching servers such as "proxy" caches are configured on the local network. This configuration is typically found in corporate or educational environments, for instance.</p>
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/assets/Images/loader.gif](https://datacollecte.equipements.sports.gouv.fr/assets/Images/loader.gif)
  
  
  * Method: `GET`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/polyfills.bundle.js](https://datacollecte.equipements.sports.gouv.fr/polyfills.bundle.js)
  
  
  * Method: `GET`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/scripts.bundle.js](https://datacollecte.equipements.sports.gouv.fr/scripts.bundle.js)
  
  
  * Method: `GET`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/robots.txt](https://datacollecte.equipements.sports.gouv.fr/robots.txt)
  
  
  * Method: `GET`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/inline.bundle.js](https://datacollecte.equipements.sports.gouv.fr/inline.bundle.js)
  
  
  * Method: `GET`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/favicon.ico](https://datacollecte.equipements.sports.gouv.fr/favicon.ico)
  
  
  * Method: `GET`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/styles.bundle.js](https://datacollecte.equipements.sports.gouv.fr/styles.bundle.js)
  
  
  * Method: `GET`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/](https://datacollecte.equipements.sports.gouv.fr/)
  
  
  * Method: `GET`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr](https://datacollecte.equipements.sports.gouv.fr)
  
  
  * Method: `GET`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/sitemap.xml](https://datacollecte.equipements.sports.gouv.fr/sitemap.xml)
  
  
  * Method: `GET`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/main.bundle.js](https://datacollecte.equipements.sports.gouv.fr/main.bundle.js)
  
  
  * Method: `GET`
  
  
  
  
Instances: 11
  
### Solution
<p>Validate that the response does not contain sensitive, personal or user-specific information.  If it does, consider the use of the following HTTP response headers, to limit, or prevent the content being stored and retrieved from the cache by another user:</p><p>Cache-Control: no-cache, no-store, must-revalidate, private</p><p>Pragma: no-cache</p><p>Expires: 0</p><p>This configuration directs both HTTP 1.0 and HTTP 1.1 compliant caching servers to not store the response, and to not retrieve the response (without validation) from the cache, in response to a similar request. </p>
  
### Other information
<p>In the absence of an explicitly specified caching lifetime directive in the response, a liberal lifetime heuristic of 1 year was assumed. This is permitted by rfc7234.</p>
  
### Reference
* https://tools.ietf.org/html/rfc7234
* https://tools.ietf.org/html/rfc7231
* http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html (obsoleted by rfc7234)

  
#### CWE Id : 524
  
#### WASC Id : 13
  
#### Source ID : 3

  
  
  
  
### Timestamp Disclosure - Unix
##### Informational (Low)
  
  
  
  
#### Description
<p>A timestamp was disclosed by the application/web server - Unix</p>
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/styles.bundle.js](https://datacollecte.equipements.sports.gouv.fr/styles.bundle.js)
  
  
  * Method: `GET`
  
  
  * Evidence: `80000000`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/styles.bundle.js](https://datacollecte.equipements.sports.gouv.fr/styles.bundle.js)
  
  
  * Method: `GET`
  
  
  * Evidence: `66666667`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/styles.bundle.js](https://datacollecte.equipements.sports.gouv.fr/styles.bundle.js)
  
  
  * Method: `GET`
  
  
  * Evidence: `33333333`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/polyfills.bundle.js](https://datacollecte.equipements.sports.gouv.fr/polyfills.bundle.js)
  
  
  * Method: `GET`
  
  
  * Evidence: `115759028`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/styles.bundle.js](https://datacollecte.equipements.sports.gouv.fr/styles.bundle.js)
  
  
  * Method: `GET`
  
  
  * Evidence: `42857143`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/polyfills.bundle.js](https://datacollecte.equipements.sports.gouv.fr/polyfills.bundle.js)
  
  
  * Method: `GET`
  
  
  * Evidence: `62425156`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/styles.bundle.js](https://datacollecte.equipements.sports.gouv.fr/styles.bundle.js)
  
  
  * Method: `GET`
  
  
  * Evidence: `26603875`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/styles.bundle.js](https://datacollecte.equipements.sports.gouv.fr/styles.bundle.js)
  
  
  * Method: `GET`
  
  
  * Evidence: `00000000`
  
  
  
  
* URL: [https://datacollecte.equipements.sports.gouv.fr/polyfills.bundle.js](https://datacollecte.equipements.sports.gouv.fr/polyfills.bundle.js)
  
  
  * Method: `GET`
  
  
  * Evidence: `94906265`
  
  
  
  
Instances: 9
  
### Solution
<p>Manually confirm that the timestamp data is not sensitive, and that the data cannot be aggregated to disclose exploitable patterns.</p>
  
### Other information
<p>80000000, which evaluates to: 1972-07-14 22:13:20</p>
  
### Reference
* http://projects.webappsec.org/w/page/13246936/Information%20Leakage

  
#### CWE Id : 200
  
#### WASC Id : 13
  
#### Source ID : 3
